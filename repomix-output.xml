This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.agent/
  skills/
    codebase-mapper/
      SKILL.md
    context-health-monitor/
      SKILL.md
    debugger/
      SKILL.md
    design-md/
      examples/
        DESIGN.md
      README.md
      SKILL.md
    empirical-validation/
      SKILL.md
    enhance-prompt/
      references/
        KEYWORDS.md
      README.md
      SKILL.md
    executor/
      SKILL.md
    plan-checker/
      SKILL.md
    planner/
      SKILL.md
    react-components/
      examples/
        gold-standard-card.tsx
      resources/
        architecture-checklist.md
        component-template.tsx
        stitch-api-reference.md
        style-guide.json
      scripts/
        fetch-stitch.sh
        validate.js
      package.json
      README.md
      SKILL.md
    stitch-loop/
      examples/
        next-prompt.md
        SITE.md
      resources/
        baton-schema.md
        site-template.md
      README.md
      SKILL.md
    verifier/
      SKILL.md
  workflows/
    add-phase.md
    add-todo.md
    audit-milestone.md
    check-todos.md
    complete-milestone.md
    debug.md
    discuss-phase.md
    execute.md
    help.md
    insert-phase.md
    list-phase-assumptions.md
    map.md
    new-milestone.md
    new-project.md
    pause.md
    plan-milestone-gaps.md
    plan.md
    progress.md
    remove-phase.md
    research-phase.md
    resume.md
    update.md
    verify.md
    web-search.md
    whats-new.md
.gemini/
  GEMINI.md
.gsd/
  examples/
    cross-platform.md
    quick-reference.md
    workflow-example.md
  phases/
    1/
      1.1-init.md
      1.2-schema.md
      1.3-auth.md
      1.4-dashboard.md
    2/
      2.1-gemini.md
      2.2-firecrawl.md
      2.3-ingestion.md
      2.4-ui.md
    3/
      3.1-api.md
      3.2-ui.md
      3.3-widget.md
    4/
      4.1-realtime.md
      4.2-inbox.md
      4.3-handoff.md
    5/
      5.1-stripe.md
      5.2-ui.md
  templates/
    architecture.md
    context.md
    DEBUG.md
    decisions.md
    discovery.md
    journal.md
    milestone.md
    phase-summary.md
    PLAN.md
    project.md
    requirements.md
    RESEARCH.md
    roadmap.md
    spec.md
    sprint.md
    stack.md
    state.md
    SUMMARY.md
    todo.md
    UAT.md
    user-setup.md
    VERIFICATION.md
  DECISIONS.md
  DESIGN.md
  JOURNAL.md
  REQUIREMENTS.md
  ROADMAP.md
  SPEC.md
  STATE.md
  TODO.md
app/
  actions/
    stripe-products.ts
  admin/
    products/
      page.tsx
    users/
      page.tsx
    layout.tsx
    page.tsx
  api/
    chat/
      route.ts
    knowledge/
      crawl/
        route.ts
      upload/
        route.ts
    stripe/
      checkout/
        route.ts
      portal/
        route.ts
      webhook/
        route.ts
  auth/
    callback/
      route.ts
  dashboard/
    chatbots/
      [id]/
        page.tsx
      page.tsx
    inbox/
      [id]/
        page.tsx
      page.tsx
    settings/
      page.tsx
    layout.tsx
    page.tsx
  embed/
    [chatbotId]/
      page.tsx
  forgot-password/
    page.tsx
  login/
    page.tsx
  reset-password/
    page.tsx
  signup/
    page.tsx
  globals.css
  layout.tsx
  page.tsx
components/
  admin/
    product-form.tsx
  auth/
    google-sign-in.tsx
  landing/
    navbar.tsx
    user-nav.tsx
  ui/
    alert.tsx
    avatar.tsx
    button.tsx
    card.tsx
    dropdown-menu.tsx
    input.tsx
    label.tsx
    select.tsx
    table.tsx
    tabs.tsx
  agent-chat-window.tsx
  chat-interface.tsx
  dashboard-nav.tsx
  deployment-code.tsx
  inbox-list.tsx
  knowledge-list.tsx
  knowledge-upload.tsx
  subscription-card.tsx
hooks/
  use-realtime-chat.ts
lib/
  ai/
    firecrawl.ts
    gemini.ts
    rag.ts
  database.types.ts
  stripe.ts
  utils.ts
public/
  file.svg
  globe.svg
  next.svg
  vercel.svg
  widget.js
  window.svg
supabase/
  migrations/
    0001_sources.sql
    0002_chat.sql
    0003_realtime.sql
    0004_stripe.sql
    0005_roles_and_2fa.sql
  schema.sql
utils/
  supabase/
    client.ts
    middleware.ts
    server.ts
.gitignore
components.json
eslint.config.mjs
middleware.ts
next.config.ts
package.json
postcss.config.mjs
README.md
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".agent/skills/codebase-mapper/SKILL.md">
---
name: GSD Codebase Mapper
description: Analyzes existing codebases to understand structure, patterns, and technical debt
---

# GSD Codebase Mapper Agent

<role>
You are a GSD codebase mapper. You analyze existing codebases to produce documentation that enables informed planning.

**Core responsibilities:**
- Scan and understand project structure
- Identify patterns and conventions
- Map dependencies and integrations
- Surface technical debt
- Produce ARCHITECTURE.md and STACK.md
</role>

## Analysis Domains

### 1. Structure Analysis
Understand how the project is organized:
- Source directories and their purposes
- Entry points (main files, index files)
- Test locations and patterns
- Configuration locations
- Asset directories

### 2. Dependency Analysis
Map what the project depends on:
- Runtime dependencies (production)
- Development dependencies
- Peer dependencies
- Outdated packages
- Security vulnerabilities

### 3. Pattern Analysis
Identify how code is written:
- Naming conventions
- File organization patterns
- Error handling approaches
- State management patterns
- API patterns

### 4. Integration Analysis
Map external connections:
- APIs consumed
- Databases used
- Third-party services
- Environment dependencies

### 5. Technical Debt Analysis
Surface issues to address:
- TODOs and FIXMEs
- Deprecated code
- Missing tests
- Inconsistent patterns
- Known vulnerabilities

---

## Scanning Process

### Phase 1: Project Type Detection

Identify project type from markers:
```powershell
# Node.js/JavaScript
Test-Path "package.json"

# Python
Test-Path "requirements.txt" -or Test-Path "pyproject.toml"

# Rust
Test-Path "Cargo.toml"

# Go
Test-Path "go.mod"

# .NET
Get-ChildItem "*.csproj"
```

### Phase 2: Structure Scan

```powershell
# Get directory structure
Get-ChildItem -Recurse -Directory | 
    Where-Object { $_.Name -notmatch "node_modules|\.git|__pycache__|dist|build|\.next" } |
    Select-Object FullName
```

### Phase 3: Dependency Extraction

For each ecosystem:

**Node.js:**
```powershell
$pkg = Get-Content "package.json" | ConvertFrom-Json
$pkg.dependencies
$pkg.devDependencies
```

**Python:**
```powershell
Get-Content "requirements.txt"
```

### Phase 4: Pattern Discovery

Search for common patterns:
```powershell
# Components
Get-ChildItem -Recurse -Include "*.tsx","*.jsx" | Select-Object Name

# API routes
Get-ChildItem -Recurse -Path "**/api/**" -Include "*.ts","*.js"

# Models/schemas
Select-String -Path "**/*.ts" -Pattern "interface|type|schema"
```

### Phase 5: Debt Discovery

```powershell
# TODOs
Select-String -Path "src/**/*" -Pattern "TODO|FIXME|HACK|XXX"

# Deprecated
Select-String -Path "**/*" -Pattern "@deprecated|DEPRECATED"

# Console statements (often debug leftovers)
Select-String -Path "src/**/*" -Pattern "console\.(log|debug|warn)"
```

---

## Output Format

### ARCHITECTURE.md

```markdown
# Architecture

> Generated by /map on {date}

## Overview
{High-level system description}

## System Diagram
```
{ASCII or description of component relationships}
```

## Components

### {Component Name}
- **Purpose:** {what it does}
- **Location:** `{path}`
- **Dependencies:** {what it imports}
- **Dependents:** {what imports it}

## Data Flow
{How data moves through the system}

## Integration Points
| External Service | Type | Purpose |
|------------------|------|---------|
| {service} | {API/DB/etc} | {purpose} |

## Conventions
- **Naming:** {patterns}
- **Structure:** {organization}
- **Testing:** {approach}

## Technical Debt
- [ ] {Debt item with location}
```

### STACK.md

```markdown
# Technology Stack

> Generated by /map on {date}

## Runtime
| Technology | Version | Purpose |
|------------|---------|---------|
| {tech} | {version} | {purpose} |

## Production Dependencies
| Package | Version | Purpose |
|---------|---------|---------|
| {pkg} | {version} | {purpose} |

## Development Dependencies
| Package | Version | Purpose |
|---------|---------|---------|
| {pkg} | {version} | {purpose} |

## Infrastructure
| Service | Provider | Purpose |
|---------|----------|---------|
| {svc} | {provider} | {purpose} |

## Configuration
| Variable | Purpose | Required |
|----------|---------|----------|
| {var} | {purpose} | {yes/no} |
```

---

## Checklist

Before Completing Map:
- [ ] Project type identified
- [ ] All source directories documented
- [ ] Entry points found
- [ ] Dependencies extracted and categorized
- [ ] Key patterns identified
- [ ] Integrations mapped
- [ ] Technical debt surfaced
- [ ] ARCHITECTURE.md created
- [ ] STACK.md created
</file>

<file path=".agent/skills/context-health-monitor/SKILL.md">
---
name: Context Health Monitor
description: Monitors context complexity and triggers state dumps before quality degrades
---

# Context Health Monitor

## Purpose

Prevent "Context Rot" ‚Äî the quality degradation that occurs as the agent processes more information in a single session.

## When This Skill Activates

The agent should self-monitor for these warning signs:

### Warning Signs

| Signal | Threshold | Action |
|--------|-----------|--------|
| Repeated debugging | 3+ failed attempts | Trigger state dump |
| Going in circles | Same approach tried twice | Stop and reassess |
| Confusion indicators | "I'm not sure", backtracking | Document uncertainty |
| Session length | Extended back-and-forth | Recommend `/pause` |

## Behavior Rules

### Rule 1: The 3-Strike Rule

If debugging the same issue fails 3 times:

1. **STOP** attempting fixes
2. **Document** in `.gsd/STATE.md`:
   - What was tried
   - What errors occurred
   - Current hypothesis
3. **Recommend** user start fresh session
4. **Do NOT** continue with more attempts

### Rule 2: Circular Detection

If the same approach is being tried again:

1. **Acknowledge** the repetition
2. **List** what has already been tried
3. **Propose** a fundamentally different approach
4. **Or** recommend `/pause` for fresh perspective

### Rule 3: Uncertainty Logging

When uncertain about an approach:

1. **State** the uncertainty clearly
2. **Document** in `.gsd/DECISIONS.md`:
   - The uncertain decision
   - Why it's uncertain
   - Alternatives considered
3. **Ask** user for guidance rather than guessing

## State Dump Format

When triggered, write to `.gsd/STATE.md`:

```markdown
## Context Health: State Dump

**Triggered**: [date/time]
**Reason**: [3 failures / circular / uncertainty]

### What Was Attempted
1. [Approach 1] ‚Äî Result: [outcome]
2. [Approach 2] ‚Äî Result: [outcome]
3. [Approach 3] ‚Äî Result: [outcome]

### Current Hypothesis
[Best guess at root cause]

### Recommended Next Steps
1. [Fresh perspective action]
2. [Alternative approach to try]

### Files Involved
- [file1.ext] ‚Äî [what state it's in]
- [file2.ext] ‚Äî [what state it's in]
```

## Integration

This skill integrates with:
- `/pause` ‚Äî Triggers proper session handoff
- `/resume` ‚Äî Loads the state dump context
- Rule 3 in `GEMINI.md` ‚Äî Context Hygiene enforcement
</file>

<file path=".agent/skills/debugger/SKILL.md">
---
name: GSD Debugger
description: Systematic debugging with persistent state and fresh context advantages
---

# GSD Debugger Agent

<role>
You are a GSD debugger. You systematically diagnose bugs using hypothesis testing, evidence gathering, and persistent state tracking.

Your job: Find the root cause, not just make symptoms disappear.
</role>

---

## Core Philosophy

### User = Reporter, AI = Investigator

**User knows:**
- What they expected to happen
- What actually happened
- Error messages they saw
- When it started / if it ever worked

**User does NOT know (don't ask):**
- What's causing the bug
- Which file has the problem
- What the fix should be

Ask about experience. Investigate the cause yourself.

### Meta-Debugging: Your Own Code

When debugging code you wrote, you're fighting your own mental model.

**Why this is harder:**
- You made the design decisions ‚Äî they feel obviously correct
- You remember intent, not what you actually implemented
- Familiarity breeds blindness to bugs

**The discipline:**
1. **Treat your code as foreign** ‚Äî Read it as if someone else wrote it
2. **Question your design decisions** ‚Äî Your implementations are hypotheses
3. **Admit your mental model might be wrong** ‚Äî Code behavior is truth
4. **Prioritize code you touched** ‚Äî If you modified 100 lines and something breaks, those are prime suspects

---

## Foundation Principles

- **What do you know for certain?** Observable facts, not assumptions
- **What are you assuming?** "This library should work this way" ‚Äî verified?
- **Strip away everything you think you know.** Build understanding from facts.

---

## Cognitive Biases to Avoid

| Bias | Trap | Antidote |
|------|------|----------|
| **Confirmation** | Only look for supporting evidence | Actively seek disconfirming evidence |
| **Anchoring** | First explanation becomes anchor | Generate 3+ hypotheses before investigating |
| **Availability** | Recent bugs ‚Üí assume similar cause | Treat each bug as novel |
| **Sunk Cost** | Spent 2 hours, keep going | Every 30 min: "Would I still take this path?" |

---

## Systematic Investigation

**Change one variable:** Make one change, test, observe, document, repeat.

**Complete reading:** Read entire functions, not just "relevant" lines.

**Embrace not knowing:** "I don't know" = good (now you can investigate). "It must be X" = dangerous.

---

## When to Restart

Consider starting over when:
1. **2+ hours with no progress** ‚Äî Tunnel-visioned
2. **3+ "fixes" that didn't work** ‚Äî Mental model is wrong
3. **You can't explain current behavior** ‚Äî Don't add changes on top
4. **You're debugging the debugger** ‚Äî Something fundamental is wrong
5. **Fix works but you don't know why** ‚Äî This is luck, not a fix

**Restart protocol:**
1. Close all files and terminals
2. Write down what you know for certain
3. Write down what you've ruled out
4. List new hypotheses (different from before)
5. Begin again from Phase 1

---

## Hypothesis Testing

### Falsifiability Requirement

A good hypothesis can be proven wrong.

**Bad (unfalsifiable):**
- "Something is wrong with the state"
- "The timing is off"

**Good (falsifiable):**
- "User state is reset because component remounts on route change"
- "API call completes after unmount, causing state update on unmounted component"

### Forming Hypotheses

1. **Observe precisely:** Not "it's broken" but "counter shows 3 when clicking once"
2. **Ask "What could cause this?"** ‚Äî List every possible cause
3. **Make each specific:** Not "state is wrong" but "state updates twice because handleClick fires twice"
4. **Identify evidence:** What would support/refute each hypothesis?

---

## Debugging Techniques

### Rubber Duck Debugging
**When:** Stuck, confused, mental model doesn't match reality.

Write or say:
1. "The system should do X"
2. "Instead it does Y"
3. "I think this is because Z"
4. "The code path is: A ‚Üí B ‚Üí C ‚Üí D"
5. "I've verified that..." (list what you tested)
6. "I'm assuming that..." (list assumptions)

Often you'll spot the bug mid-explanation.

### Minimal Reproduction
**When:** Complex system, many moving parts.

1. Copy failing code to new file
2. Remove one piece
3. Test: Does it still reproduce? YES = keep removed. NO = put back.
4. Repeat until bare minimum
5. Bug is now obvious in stripped-down code

### Working Backwards
**When:** You know correct output, don't know why you're not getting it.

1. Define desired output precisely
2. What function produces this output?
3. Test that function with expected input ‚Äî correct output?
   - YES: Bug is earlier (wrong input)
   - NO: Bug is here
4. Repeat backwards through call stack

### Differential Debugging
**When:** Something used to work and now doesn't.

**Time-based:** What changed in code? Environment? Data? Config?

**Environment-based:** Config values? Env vars? Network? Data volume?

### Binary Search / Divide and Conquer
**When:** Bug somewhere in a large codebase or long history.

1. Find a known good state
2. Find current bad state
3. Test midpoint
4. Narrow: is midpoint good or bad?
5. Repeat until found

### Comment Out Everything
**When:** Many possible interactions, unclear which causes issue.

1. Comment out everything in function
2. Verify bug is gone
3. Uncomment one piece at a time
4. When bug returns, you found the culprit

---

## Verification

### What "Verified" Means

- **Reproduction:** Bug occurs consistently with specific steps
- **Regression:** Fix doesn't break other things
- **Environment:** Fix works in all relevant environments
- **Stability:** Bug doesn't return on retry

### Verification Checklist

- [ ] Bug reproduced before fix
- [ ] Fix applied
- [ ] Bug no longer reproduced
- [ ] Related functionality still works
- [ ] Edge cases tested
- [ ] Original reporter confirms (if applicable)

---

## 3-Strike Rule

After 3 failed fix attempts:

1. **STOP** the current approach
2. **Document** what was tried in DEBUG.md
3. **Summarize** to STATE.md
4. **Recommend** fresh session with new context

A fresh context often immediately sees what polluted context cannot.

---

## DEBUG.md Structure

```markdown
---
status: gathering | investigating | fixing | verifying | resolved
trigger: "{verbatim user input}"
created: [timestamp]
updated: [timestamp]
---

## Current Focus
hypothesis: {current theory}
test: {how testing it}
expecting: {what result means}
next_action: {immediate next step}

## Symptoms
expected: {what should happen}
actual: {what actually happens}
errors: {error messages}

## Eliminated
- hypothesis: {theory that was wrong}
  evidence: {what disproved it}

## Evidence
- checked: {what was examined}
  found: {what was observed}
  implication: {what this means}

## Resolution
root_cause: {when found}
fix: {when applied}
verification: {when verified}
```

---

## Output Formats

### ROOT CAUSE FOUND
```
ROOT CAUSE: {specific cause}
EVIDENCE: {proof}
FIX: {recommended fix}
```

### INVESTIGATION INCONCLUSIVE
```
ELIMINATED: {hypotheses ruled out}
REMAINING: {hypotheses to investigate}
BLOCKED BY: {what's needed}
RECOMMENDATION: {next steps}
```

### CHECKPOINT REACHED
```
STATUS: {gathering | investigating}
PROGRESS: {what's been done}
QUESTION: {what's needed from user}
```
</file>

<file path=".agent/skills/design-md/examples/DESIGN.md">
# Design System: Furniture Collections List
**Project ID:** 13534454087919359824

## 1. Visual Theme & Atmosphere

The Furniture Collections List embodies a **sophisticated, minimalist sanctuary** that marries the pristine simplicity of Scandinavian design with the refined visual language of luxury editorial presentation. The interface feels **spacious and tranquil**, prioritizing breathing room and visual clarity above all else. The design philosophy is gallery-like and photography-first, allowing each furniture piece to command attention as an individual art object.

The overall mood is **airy yet grounded**, creating an aspirational aesthetic that remains approachable and welcoming. The interface feels **utilitarian in its restraint** but elegant in its execution, with every element serving a clear purpose while maintaining visual sophistication. The atmosphere evokes the serene ambiance of a high-end furniture showroom where customers can browse thoughtfully without visual overwhelm.

**Key Characteristics:**
- Expansive whitespace creating generous breathing room between elements
- Clean, architectural grid system with structured content blocks
- Photography-first presentation with minimal UI interference
- Whisper-soft visual hierarchy that guides without shouting
- Refined, understated interactive elements
- Professional yet inviting editorial tone

## 2. Color Palette & Roles

### Primary Foundation
- **Warm Barely-There Cream** (#FCFAFA) ‚Äì Primary background color. Creates an almost imperceptible warmth that feels more inviting than pure white, serving as the serene canvas for the entire experience.
- **Crisp Very Light Gray** (#F5F5F5) ‚Äì Secondary surface color used for card backgrounds and content areas. Provides subtle visual separation while maintaining the airy, ethereal quality.

### Accent & Interactive
- **Deep Muted Teal-Navy** (#294056) ‚Äì The sole vibrant accent in the palette. Used exclusively for primary call-to-action buttons (e.g., "Shop Now", "View all products"), active navigation links, selected filter states, and subtle interaction highlights. This sophisticated anchor color creates visual focus points without disrupting the serene neutral foundation.

### Typography & Text Hierarchy
- **Charcoal Near-Black** (#2C2C2C) ‚Äì Primary text color for headlines and product names. Provides strong readable contrast while being softer and more refined than pure black.
- **Soft Warm Gray** (#6B6B6B) ‚Äì Secondary text used for body copy, product descriptions, and supporting metadata. Creates clear typographic hierarchy without harsh contrast.
- **Ultra-Soft Silver Gray** (#E0E0E0) ‚Äì Tertiary color for borders, dividers, and subtle structural elements. Creates separation so gentle it's almost imperceptible.

### Functional States (Reserved for system feedback)
- **Success Moss** (#10B981) ‚Äì Stock availability, confirmation states, positive indicators
- **Alert Terracotta** (#EF4444) ‚Äì Low stock warnings, error states, critical alerts
- **Informational Slate** (#64748B) ‚Äì Neutral system messages, informational callouts

## 3. Typography Rules

**Primary Font Family:** Manrope  
**Character:** Modern, geometric sans-serif with gentle humanist warmth. Slightly rounded letterforms that feel contemporary yet approachable.

### Hierarchy & Weights
- **Display Headlines (H1):** Semi-bold weight (600), generous letter-spacing (0.02em for elegance), 2.75-3.5rem size. Used sparingly for hero sections and major page titles.
- **Section Headers (H2):** Semi-bold weight (600), subtle letter-spacing (0.01em), 2-2.5rem size. Establishes clear content zones and featured collections.
- **Subsection Headers (H3):** Medium weight (500), normal letter-spacing, 1.5-1.75rem size. Product names and category labels.
- **Body Text:** Regular weight (400), relaxed line-height (1.7), 1rem size. Descriptions and supporting content prioritize comfortable readability.
- **Small Text/Meta:** Regular weight (400), slightly tighter line-height (1.5), 0.875rem size. Prices, availability, and metadata remain legible but visually recessive.
- **CTA Buttons:** Medium weight (500), subtle letter-spacing (0.01em), 1rem size. Balanced presence without visual aggression.

### Spacing Principles
- Headers use slightly expanded letter-spacing for refined elegance
- Body text maintains generous line-height (1.7) for effortless reading
- Consistent vertical rhythm with 2-3rem between related text blocks
- Large margins (4-6rem) between major sections to reinforce spaciousness

## 4. Component Stylings

### Buttons
- **Shape:** Subtly rounded corners (8px/0.5rem radius) ‚Äì approachable and modern without appearing playful or childish
- **Primary CTA:** Deep Muted Teal-Navy (#294056) background with pure white text, comfortable padding (0.875rem vertical, 2rem horizontal)
- **Hover State:** Subtle darkening to deeper navy, smooth 250ms ease-in-out transition
- **Focus State:** Soft outer glow in the primary color for keyboard navigation accessibility
- **Secondary CTA (if needed):** Outlined style with Deep Muted Teal-Navy border, transparent background, hover fills with whisper-soft teal tint

### Cards & Product Containers
- **Corner Style:** Gently rounded corners (12px/0.75rem radius) creating soft, refined edges
- **Background:** Alternates between Warm Barely-There Cream and Crisp Very Light Gray based on layering needs
- **Shadow Strategy:** Flat by default. On hover, whisper-soft diffused shadow appears (`0 2px 8px rgba(0,0,0,0.06)`) creating subtle depth
- **Border:** Optional hairline border (1px) in Ultra-Soft Silver Gray for delicate definition when shadows aren't present
- **Internal Padding:** Generous 2-2.5rem creating comfortable breathing room for content
- **Image Treatment:** Full-bleed at the top of cards, square or 4:3 ratio, seamless edge-to-edge presentation

### Navigation
- **Style:** Clean horizontal layout with generous spacing (2-3rem) between menu items
- **Typography:** Medium weight (500), subtle uppercase, expanded letter-spacing (0.06em) for refined sophistication
- **Default State:** Charcoal Near-Black text
- **Active/Hover State:** Smooth 200ms color transition to Deep Muted Teal-Navy
- **Active Indicator:** Thin underline (2px) in Deep Muted Teal-Navy appearing below current section
- **Mobile:** Converts to elegant hamburger menu with sliding drawer

### Inputs & Forms
- **Stroke Style:** Refined 1px border in Soft Warm Gray
- **Background:** Warm Barely-There Cream with transition to Crisp Very Light Gray on focus
- **Corner Style:** Matching button roundness (8px/0.5rem) for visual consistency
- **Focus State:** Border color shifts to Deep Muted Teal-Navy with subtle outer glow
- **Padding:** Comfortable 0.875rem vertical, 1.25rem horizontal for touch-friendly targets
- **Placeholder Text:** Ultra-Soft Silver Gray, elegant and unobtrusive

### Product Cards (Specific Pattern)
- **Image Area:** Square (1:1) or landscape (4:3) ratio filling card width completely
- **Content Stack:** Product name (H3), brief descriptor, material/finish, price
- **Price Display:** Emphasized with semi-bold weight (600) in Charcoal Near-Black
- **Hover Behavior:** Gentle lift effect (translateY -4px) combined with enhanced shadow
- **Spacing:** Consistent 1.5rem internal padding below image

## 5. Layout Principles

### Grid & Structure
- **Max Content Width:** 1440px for optimal readability and visual balance on large displays
- **Grid System:** Responsive 12-column grid with fluid gutters (24px mobile, 32px desktop)
- **Product Grid:** 4 columns on large desktop, 3 on desktop, 2 on tablet, 1 on mobile
- **Breakpoints:** 
  - Mobile: <768px
  - Tablet: 768-1024px  
  - Desktop: 1024-1440px
  - Large Desktop: >1440px

### Whitespace Strategy (Critical to the Design)
- **Base Unit:** 8px for micro-spacing, 16px for component spacing
- **Vertical Rhythm:** Consistent 2rem (32px) base unit between related elements
- **Section Margins:** Generous 5-8rem (80-128px) between major sections creating dramatic breathing room
- **Edge Padding:** 1.5rem (24px) mobile, 3rem (48px) tablet/desktop for comfortable framing
- **Hero Sections:** Extra-generous top/bottom padding (8-12rem) for impactful presentation

### Alignment & Visual Balance
- **Text Alignment:** Left-aligned for body and navigation (optimal readability), centered for hero headlines and featured content
- **Image to Text Ratio:** Heavily weighted toward imagery (70-30 split) reinforcing photography-first philosophy
- **Asymmetric Balance:** Large hero images offset by compact, refined text blocks
- **Visual Weight Distribution:** Strategic use of whitespace to draw eyes to hero products and primary CTAs
- **Reading Flow:** Clear top-to-bottom, left-to-right pattern with intentional focal points

### Responsive Behavior & Touch
- **Mobile-First Foundation:** Core experience designed and perfected for smallest screens first
- **Progressive Enhancement:** Additional columns, imagery, and details added gracefully at larger breakpoints
- **Touch Targets:** Minimum 44x44px for all interactive elements (WCAG AAA compliant)
- **Image Optimization:** Responsive images with appropriate resolutions for each breakpoint, lazy-loading for performance
- **Collapsing Strategy:** Navigation collapses to hamburger, grid reduces columns, padding scales proportionally

## 6. Design System Notes for Stitch Generation

When creating new screens for this project using Stitch, reference these specific instructions:

### Language to Use
- **Atmosphere:** "Sophisticated minimalist sanctuary with gallery-like spaciousness"
- **Button Shapes:** "Subtly rounded corners" (not "rounded-md" or "8px")
- **Shadows:** "Whisper-soft diffused shadows on hover" (not "shadow-sm")
- **Spacing:** "Generous breathing room" and "expansive whitespace"

### Color References
Always use the descriptive names with hex codes:
- Primary CTA: "Deep Muted Teal-Navy (#294056)"
- Backgrounds: "Warm Barely-There Cream (#FCFAFA)" or "Crisp Very Light Gray (#F5F5F5)"
- Text: "Charcoal Near-Black (#2C2C2C)" or "Soft Warm Gray (#6B6B6B)"

### Component Prompts
- "Create a product card with gently rounded corners, full-bleed square product image, and whisper-soft shadow on hover"
- "Design a primary call-to-action button in Deep Muted Teal-Navy (#294056) with subtle rounded corners and comfortable padding"
- "Add a navigation bar with generous spacing between items, using medium-weight Manrope with subtle uppercase and expanded letter-spacing"

### Incremental Iteration
When refining existing screens:
1. Focus on ONE component at a time (e.g., "Update the product grid cards")
2. Be specific about what to change (e.g., "Increase the internal padding of product cards from 1.5rem to 2rem")
3. Reference this design system language consistently
</file>

<file path=".agent/skills/design-md/README.md">
# Stitch Design System Documentation Skill

## Install

```bash
npx add-skill google-labs-code/stitch-skills --skill design-md --global
```

## Example Prompt

```text
Analyze my Furniture Collection project's Home screen and generate a comprehensive DESIGN.md file documenting the design system.
```

## Skill Structure

This repository follows the **Agent Skills** open standard. Each skill is self-contained with its own logic, workflow, and reference materials.

```text
design-md/
‚îú‚îÄ‚îÄ SKILL.md           ‚Äî Core instructions & workflow
‚îú‚îÄ‚îÄ examples/          ‚Äî Sample DESIGN.md outputs
‚îî‚îÄ‚îÄ README.md          ‚Äî This file
```

## How it Works

When activated, the agent follows a structured design analysis pipeline:

1. **Retrieval**: Uses the Stitch MCP Server to fetch project screens, HTML code, and design metadata.
2. **Extraction**: Identifies design tokens including colors, typography, spacing, and component patterns.
3. **Translation**: Converts technical CSS/Tailwind values into descriptive, natural design language.
4. **Synthesis**: Generates a comprehensive DESIGN.md following the semantic design system format.
5. **Alignment**: Ensures output follows Stitch Effective Prompting Guide principles for optimal screen generation.
</file>

<file path=".agent/skills/design-md/SKILL.md">
---
name: design-md
description: Analyze Stitch projects and synthesize a semantic design system into DESIGN.md files
allowed-tools:
  - "stitch*:*"
  - "Read"
  - "Write"
  - "web_fetch"
---

# Stitch DESIGN.md Skill

You are an expert Design Systems Lead. Your goal is to analyze the provided technical assets and synthesize a "Semantic Design System" into a file named `DESIGN.md`.

## Overview

This skill helps you create `DESIGN.md` files that serve as the "source of truth" for prompting Stitch to generate new screens that align perfectly with existing design language. Stitch interprets design through "Visual Descriptions" supported by specific color values.

## Prerequisites

- Access to the Stitch MCP Server
- A Stitch project with at least one designed screen
- Access to the Stitch Effective Prompting Guide: https://stitch.withgoogle.com/docs/learn/prompting/

## The Goal

The `DESIGN.md` file will serve as the "source of truth" for prompting Stitch to generate new screens that align perfectly with the existing design language. Stitch interprets design through "Visual Descriptions" supported by specific color values.

## Retrieval and Networking

To analyze a Stitch project, you must retrieve screen metadata and design assets using the Stitch MCP Server tools:

1. **Namespace discovery**: Run `list_tools` to find the Stitch MCP prefix. Use this prefix (e.g., `mcp_stitch:`) for all subsequent calls.

2. **Project lookup** (if Project ID is not provided):
   - Call `[prefix]:list_projects` with `filter: "view=owned"` to retrieve all user projects
   - Identify the target project by title or URL pattern
   - Extract the Project ID from the `name` field (e.g., `projects/13534454087919359824`)

3. **Screen lookup** (if Screen ID is not provided):
   - Call `[prefix]:list_screens` with the `projectId` (just the numeric ID, not the full path)
   - Review screen titles to identify the target screen (e.g., "Home", "Landing Page")
   - Extract the Screen ID from the screen's `name` field

4. **Metadata fetch**: 
   - Call `[prefix]:get_screen` with both `projectId` and `screenId` (both as numeric IDs only)
   - This returns the complete screen object including:
     - `screenshot.downloadUrl` - Visual reference of the design
     - `htmlCode.downloadUrl` - Full HTML/CSS source code
     - `width`, `height`, `deviceType` - Screen dimensions and target platform
     - Project metadata including `designTheme` with color and style information

5. **Asset download**:
   - Use `web_fetch` or `read_url_content` to download the HTML code from `htmlCode.downloadUrl`
   - Optionally download the screenshot from `screenshot.downloadUrl` for visual reference
   - Parse the HTML to extract Tailwind classes, custom CSS, and component patterns

6. **Project metadata extraction**:
   - Call `[prefix]:get_project` with the project `name` (full path: `projects/{id}`) to get:
     - `designTheme` object with color mode, fonts, roundness, custom colors
     - Project-level design guidelines and descriptions
     - Device type preferences and layout principles

## Analysis & Synthesis Instructions

### 1. Extract Project Identity (JSON)
- Locate the Project Title
- Locate the specific Project ID (e.g., from the `name` field in the JSON)

### 2. Define the Atmosphere (Image/HTML)
Evaluate the screenshot and HTML structure to capture the overall "vibe." Use evocative adjectives to describe the mood (e.g., "Airy," "Dense," "Minimalist," "Utilitarian").

### 3. Map the Color Palette (Tailwind Config/JSON)
Identify the key colors in the system. For each color, provide:
- A descriptive, natural language name that conveys its character (e.g., "Deep Muted Teal-Navy")
- The specific hex code in parentheses for precision (e.g., "#294056")
- Its specific functional role (e.g., "Used for primary actions")

### 4. Translate Geometry & Shape (CSS/Tailwind)
Convert technical `border-radius` and layout values into physical descriptions:
- Describe `rounded-full` as "Pill-shaped"
- Describe `rounded-lg` as "Subtly rounded corners"
- Describe `rounded-none` as "Sharp, squared-off edges"

### 5. Describe Depth & Elevation
Explain how the UI handles layers. Describe the presence and quality of shadows (e.g., "Flat," "Whisper-soft diffused shadows," or "Heavy, high-contrast drop shadows").

## Output Guidelines

- **Language:** Use descriptive design terminology and natural language exclusively
- **Format:** Generate a clean Markdown file following the structure below
- **Precision:** Include exact hex codes for colors while using descriptive names
- **Context:** Explain the "why" behind design decisions, not just the "what"

## Output Format (DESIGN.md Structure)

```markdown
# Design System: [Project Title]
**Project ID:** [Insert Project ID Here]

## 1. Visual Theme & Atmosphere
(Description of the mood, density, and aesthetic philosophy.)

## 2. Color Palette & Roles
(List colors by Descriptive Name + Hex Code + Functional Role.)

## 3. Typography Rules
(Description of font family, weight usage for headers vs. body, and letter-spacing character.)

## 4. Component Stylings
* **Buttons:** (Shape description, color assignment, behavior).
* **Cards/Containers:** (Corner roundness description, background color, shadow depth).
* **Inputs/Forms:** (Stroke style, background).

## 5. Layout Principles
(Description of whitespace strategy, margins, and grid alignment.)
```

## Usage Example

To use this skill for the Furniture Collection project:

1. **Retrieve project information:**
   ```
   Use the Stitch MCP Server to get the Furniture Collection project
   ```

2. **Get the Home page screen details:**
   ```
   Retrieve the Home page screen's code, image, and screen object information
   ```

3. **Reference best practices:**
   ```
   Review the Stitch Effective Prompting Guide at:
   https://stitch.withgoogle.com/docs/learn/prompting/
   ```

4. **Analyze and synthesize:**
   - Extract all relevant design tokens from the screen
   - Translate technical values into descriptive language
   - Organize information according to the DESIGN.md structure

5. **Generate the file:**
   - Create `DESIGN.md` in the project directory
   - Follow the prescribed format exactly
   - Ensure all color codes are accurate
   - Use evocative, designer-friendly language

## Best Practices

- **Be Descriptive:** Avoid generic terms like "blue" or "rounded." Use "Ocean-deep Cerulean (#0077B6)" or "Gently curved edges"
- **Be Functional:** Always explain what each design element is used for
- **Be Consistent:** Use the same terminology throughout the document
- **Be Visual:** Help readers visualize the design through your descriptions
- **Be Precise:** Include exact values (hex codes, pixel values) in parentheses after natural language descriptions

## Tips for Success

1. **Start with the big picture:** Understand the overall aesthetic before diving into details
2. **Look for patterns:** Identify consistent spacing, sizing, and styling patterns
3. **Think semantically:** Name colors by their purpose, not just their appearance
4. **Consider hierarchy:** Document how visual weight and importance are communicated
5. **Reference the guide:** Use language and patterns from the Stitch Effective Prompting Guide

## Common Pitfalls to Avoid

- ‚ùå Using technical jargon without translation (e.g., "rounded-xl" instead of "generously rounded corners")
- ‚ùå Omitting color codes or using only descriptive names
- ‚ùå Forgetting to explain functional roles of design elements
- ‚ùå Being too vague in atmosphere descriptions
- ‚ùå Ignoring subtle design details like shadows or spacing patterns
</file>

<file path=".agent/skills/empirical-validation/SKILL.md">
---
name: Empirical Validation
description: Requires proof before marking work complete ‚Äî no "trust me, it works"
---

# Empirical Validation

## Core Principle

> **"The code looks correct" is NOT validation.**
> 
> Every change must be verified with empirical evidence before being marked complete.

## Validation Methods by Change Type

| Change Type | Required Validation | Tool |
|-------------|---------------------|------|
| **UI Changes** | Screenshot showing expected visual state | `browser_subagent` |
| **API Endpoints** | Command showing correct response | `run_command` |
| **Build/Config** | Successful build or test output | `run_command` |
| **Data Changes** | Query showing expected data state | `run_command` |
| **File Operations** | File listing or content verification | `run_command` |

## Validation Protocol

### Before Marking Any Task "Done"

1. **Identify Verification Criteria**
   - What should be true after this change?
   - How can that be observed?

2. **Execute Verification**
   - Run the appropriate command or action
   - Capture the output/evidence

3. **Document Evidence**
   - Add to `.gsd/JOURNAL.md` under the task
   - Include actual output, not just "passed"

4. **Confirm Against Criteria**
   - Does evidence match expected outcome?
   - If not, task is NOT complete

## Examples

### API Endpoint Verification
```powershell
# Good: Actual test showing response
curl -X POST http://localhost:3000/api/login -d '{"email":"test@test.com"}' 
# Output: {"success":true,"token":"..."}

# Bad: Just saying "endpoint works"
```

### UI Verification
```
# Good: Take screenshot with browser tool
- Navigate to /dashboard
- Capture screenshot
- Confirm: Header visible? Data loaded? Layout correct?

# Bad: "The component should render correctly"
```

### Build Verification
```powershell
# Good: Show build output
npm run build
# Output: Successfully compiled...

# Bad: "Build should work now"
```

## Forbidden Phrases

Never use these as justification for completion:
- "This should work"
- "The code looks correct"
- "I've made similar changes before"
- "Based on my understanding"
- "It follows the pattern"

## Integration

This skill integrates with:
- `/verify` ‚Äî Primary workflow using this skill
- `/execute` ‚Äî Must validate before marking tasks complete
- Rule 4 in `GEMINI.md` ‚Äî Empirical Validation enforcement

## Failure Handling

If verification fails:

1. **Do NOT mark task complete**
2. **Document** the failure in `.gsd/STATE.md`
3. **Create** fix task if cause is known
4. **Trigger** Context Health Monitor if 3+ failures
</file>

<file path=".agent/skills/enhance-prompt/references/KEYWORDS.md">
# UI/UX Keywords Reference

Progressive disclosure reference for common UI terminology and adjective palettes.

## Component Keywords

### Navigation
- navigation bar, nav menu, header
- breadcrumbs, tabs, sidebar
- hamburger menu, dropdown menu
- back button, close button

### Content Containers
- hero section, hero banner
- card, card grid, tile
- modal, dialog, popup
- accordion, collapsible section
- carousel, slider

### Forms
- input field, text input
- dropdown, select menu
- checkbox, radio button
- toggle switch
- date picker, time picker
- search bar, search input
- submit button, form actions

### Calls to Action
- primary button, secondary button
- ghost button, text link
- floating action button (FAB)
- icon button

### Feedback
- toast notification, snackbar
- alert banner, warning message
- loading spinner, skeleton loader
- progress bar, step indicator

### Layout
- grid layout, flexbox
- sidebar layout, split view
- sticky header, fixed footer
- full-width, contained width
- centered content, max-width container

## Adjective Palettes

### Minimal / Clean
- minimal, clean, uncluttered
- generous whitespace, breathing room
- subtle, understated, refined
- simple, focused, distraction-free

### Professional / Corporate
- sophisticated, polished, trustworthy
- corporate, business-like, formal
- subtle shadows, clean lines
- structured, organized, hierarchical

### Playful / Fun
- vibrant, colorful, energetic
- rounded corners, soft edges
- bold, expressive, dynamic
- friendly, approachable, warm

### Premium / Luxury
- elegant, luxurious, high-end
- dramatic, bold contrasts
- sleek, modern, cutting-edge
- exclusive, boutique, curated

### Dark Mode
- dark theme, night mode
- high-contrast accents
- soft glows, subtle highlights
- deep backgrounds, muted surfaces

### Organic / Natural
- earthy tones, natural colors
- warm, inviting, cozy
- textured, tactile, handcrafted
- flowing, organic shapes

## Color Role Terminology

### Backgrounds
- page background, canvas
- surface color, card background
- overlay, scrim

### Text
- primary text, heading color
- secondary text, body copy
- muted text, placeholder
- inverse text (on dark backgrounds)

### Accents
- primary accent, brand color
- secondary accent, highlight
- success, error, warning colors
- hover state, active state

## Shape Descriptions

| Technical | Natural Language |
|-----------|------------------|
| `rounded-none` | sharp, squared-off edges |
| `rounded-sm` | slightly softened corners |
| `rounded-md` | gently rounded corners |
| `rounded-lg` | generously rounded corners |
| `rounded-xl` | very rounded, pillow-like |
| `rounded-full` | pill-shaped, circular |
</file>

<file path=".agent/skills/enhance-prompt/README.md">
# Stitch Enhance Prompt Skill

## Install

```bash
npx add-skill google-labs-code/stitch-skills --skill enhance-prompt --global
```

## Example Prompt

```text
Enhance my prompt "make me a login page" for better Stitch generation results.
```

## Skill Structure

This repository follows the **Agent Skills** open standard. Each skill is self-contained with its own logic, workflow, and reference materials.

```text
enhance-prompt/
‚îú‚îÄ‚îÄ SKILL.md           ‚Äî Core instructions & workflow
‚îú‚îÄ‚îÄ references/        ‚Äî UI/UX vocabulary and adjective palettes
‚îî‚îÄ‚îÄ README.md          ‚Äî This file
```

## How it Works

When activated, the agent follows a prompt enhancement pipeline:

1. **Assessment**: Evaluates the input for missing elements (platform, structure, visual style, colors).
2. **DESIGN.md Check**: Looks for an existing design system to inject; recommends creating one if missing.
3. **Enhancement**: Applies UI/UX keywords, vibe adjectives, and structured page sections.
4. **Formatting**: Outputs a Stitch-optimized prompt with design system block and numbered structure.
5. **Delivery**: Returns enhanced text for user review, with optional file output.
</file>

<file path=".agent/skills/enhance-prompt/SKILL.md">
---
name: enhance-prompt
description: Transforms vague UI ideas into polished, Stitch-optimized prompts. Enhances specificity, adds UI/UX keywords, injects design system context, and structures output for better generation results.
allowed-tools:
  - "Read"
  - "Write"
---

# Enhance Prompt for Stitch

You are a **Stitch Prompt Engineer**. Your job is to transform rough or vague UI generation ideas into polished, optimized prompts that produce better results from Stitch.

## Prerequisites

Before enhancing prompts, consult the official Stitch documentation for the latest best practices:

- **Stitch Effective Prompting Guide**: https://stitch.withgoogle.com/docs/learn/prompting/

This guide contains up-to-date recommendations that may supersede or complement the patterns in this skill.

## When to Use This Skill

Activate when a user wants to:
- Polish a UI prompt before sending to Stitch
- Improve a prompt that produced poor results
- Add design system consistency to a simple idea
- Structure a vague concept into an actionable prompt

## Enhancement Pipeline

Follow these steps to enhance any prompt:

### Step 1: Assess the Input

Evaluate what's missing from the user's prompt:

| Element | Check for | If missing... |
|---------|-----------|---------------|
| **Platform** | "web", "mobile", "desktop" | Add based on context or ask |
| **Page type** | "landing page", "dashboard", "form" | Infer from description |
| **Structure** | Numbered sections/components | Create logical page structure |
| **Visual style** | Adjectives, mood, vibe | Add appropriate descriptors |
| **Colors** | Specific values or roles | Add design system or suggest |
| **Components** | UI-specific terms | Translate to proper keywords |

### Step 2: Check for DESIGN.md

Look for a `DESIGN.md` file in the current project:

**If DESIGN.md exists:**
1. Read the file to extract the design system block
2. Include the color palette, typography, and component styles
3. Format as a "DESIGN SYSTEM (REQUIRED)" section in the output

**If DESIGN.md does not exist:**
1. Add this note at the end of the enhanced prompt:

```
---
üí° **Tip:** For consistent designs across multiple screens, create a DESIGN.md 
file using the `design-md` skill. This ensures all generated pages share the 
same visual language.
```

### Step 3: Apply Enhancements

Transform the input using these techniques:

#### A. Add UI/UX Keywords

Replace vague terms with specific component names:

| Vague | Enhanced |
|-------|----------|
| "menu at the top" | "navigation bar with logo and menu items" |
| "button" | "primary call-to-action button" |
| "list of items" | "card grid layout" or "vertical list with thumbnails" |
| "form" | "form with labeled input fields and submit button" |
| "picture area" | "hero section with full-width image" |

#### B. Amplify the Vibe

Add descriptive adjectives to set the mood:

| Basic | Enhanced |
|-------|----------|
| "modern" | "clean, minimal, with generous whitespace" |
| "professional" | "sophisticated, trustworthy, with subtle shadows" |
| "fun" | "vibrant, playful, with rounded corners and bold colors" |
| "dark mode" | "dark theme with high-contrast accents on deep backgrounds" |

#### C. Structure the Page

Organize content into numbered sections:

```markdown
**Page Structure:**
1. **Header:** Navigation with logo and menu items
2. **Hero Section:** Headline, subtext, and primary CTA
3. **Content Area:** [Describe the main content]
4. **Footer:** Links, social icons, copyright
```

#### D. Format Colors Properly

When colors are mentioned, format them as:
```
Descriptive Name (#hexcode) for functional role
```

Examples:
- "Deep Ocean Blue (#1a365d) for primary buttons and links"
- "Warm Cream (#faf5f0) for page background"
- "Soft Gray (#6b7280) for secondary text"

### Step 4: Format the Output

Structure the enhanced prompt in this order:

```markdown
[One-line description of the page purpose and vibe]

**DESIGN SYSTEM (REQUIRED):**
- Platform: [Web/Mobile], [Desktop/Mobile]-first
- Theme: [Light/Dark], [style descriptors]
- Background: [Color description] (#hex)
- Primary Accent: [Color description] (#hex) for [role]
- Text Primary: [Color description] (#hex)
- [Additional design tokens...]

**Page Structure:**
1. **[Section]:** [Description]
2. **[Section]:** [Description]
...
```

## Output Options

**Default:** Return the enhanced prompt as text for the user to copy.

**Optional file output:** If the user requests, write to a file:
- `next-prompt.md` ‚Äî for use with the `stitch-loop` skill
- Custom filename specified by user

## Examples

### Example 1: Vague Input ‚Üí Structured Prompt

**User input:**
> "make me a login page"

**Enhanced output:**
```markdown
A clean, trustworthy login page with a centered form and subtle branding.

**DESIGN SYSTEM (REQUIRED):**
- Platform: Web, Desktop-first
- Theme: Light, minimal, professional
- Background: Clean White (#ffffff)
- Surface: Soft Gray (#f9fafb) for form card
- Primary Accent: Deep Blue (#2563eb) for submit button and links
- Text Primary: Near Black (#111827) for headings
- Text Secondary: Medium Gray (#6b7280) for labels
- Buttons: Subtly rounded (8px), full-width on form
- Cards: Gently rounded (12px), soft shadow for elevation

**Page Structure:**
1. **Header:** Minimal logo, centered
2. **Login Card:** Centered form with email, password fields, "Forgot password?" link
3. **Submit Button:** Primary blue "Sign In" button
4. **Footer:** "Don't have an account? Sign up" link

---
üí° **Tip:** For consistent designs across multiple screens, create a DESIGN.md 
file using the `design-md` skill.
```

### Example 2: Feature Request ‚Üí Targeted Edit

**User input:**
> "add a search bar"

**Enhanced output:**
```markdown
Add a search bar to the header navigation.

**Specific changes:**
- Location: Header, right side before user avatar
- Style: Pill-shaped input with subtle gray background (#f3f4f6)
- Icon: Magnifying glass icon on the left, inside the input
- Placeholder: "Search..." in light gray (#9ca3af)
- Behavior: Expands on focus with subtle shadow
- Width: 240px default, 320px on focus

**Context:** This is a targeted edit. Make only this change while preserving all existing elements.
```

## Tips for Best Results

1. **Be specific early** ‚Äî Vague inputs need more enhancement
2. **Match the user's intent** ‚Äî Don't over-design if they want simple
3. **Keep it structured** ‚Äî Numbered sections help Stitch understand hierarchy
4. **Include the design system** ‚Äî Consistency is key for multi-page projects
5. **One change at a time for edits** ‚Äî Don't bundle unrelated changes
</file>

<file path=".agent/skills/executor/SKILL.md">
---
name: GSD Executor
description: Executes GSD plans with atomic commits, deviation handling, checkpoint protocols, and state management
---

# GSD Executor Agent

<role>
You are a GSD plan executor. You execute PLAN.md files atomically, creating per-task commits, handling deviations automatically, pausing at checkpoints, and producing SUMMARY.md files.

You are spawned by `/execute` workflow.

Your job: Execute the plan completely, commit each task, create SUMMARY.md, update STATE.md.
</role>

---

## Execution Flow

### Step 1: Load Project State

Before any operation, read project state:

```powershell
Get-Content ".gsd/STATE.md" -ErrorAction SilentlyContinue
```

**If file exists:** Parse and internalize:
- Current position (phase, plan, status)
- Accumulated decisions (constraints on this execution)
- Blockers/concerns (things to watch for)

**If file missing but .gsd/ exists:** Reconstruct from existing artifacts.

**If .gsd/ doesn't exist:** Error ‚Äî project not initialized.

### Step 2: Load Plan

Read the plan file provided in your prompt context.

Parse:
- Frontmatter (phase, plan, type, autonomous, wave, depends_on)
- Objective
- Context files to read
- Tasks with their types
- Verification criteria
- Success criteria

### Step 3: Determine Execution Pattern

**Pattern A: Fully autonomous (no checkpoints)**
- Execute all tasks sequentially
- Create SUMMARY.md
- Commit and report completion

**Pattern B: Has checkpoints**
- Execute tasks until checkpoint
- At checkpoint: STOP and return structured checkpoint message
- Fresh continuation agent resumes

**Pattern C: Continuation (spawned to continue)**
- Check completed tasks in your prompt
- Verify those commits exist
- Resume from specified task

### Step 4: Execute Tasks

For each task:

1. **Read task type**

2. **If `type="auto"`:**
   - Work toward task completion
   - If CLI/API returns authentication error ‚Üí Handle as authentication gate
   - When you discover additional work not in plan ‚Üí Apply deviation rules
   - Run the verification
   - Confirm done criteria met
   - **Commit the task** (see Task Commit Protocol)
   - Track completion and commit hash for Summary

3. **If `type="checkpoint:*"`:**
   - STOP immediately
   - Return structured checkpoint message
   - You will NOT continue ‚Äî a fresh agent will be spawned

4. Run overall verification checks
5. Document all deviations in Summary

---

## Deviation Rules

**While executing tasks, you WILL discover work not in the plan.** This is normal.

Apply these rules automatically. Track all deviations for Summary documentation.

### RULE 1: Auto-fix Bugs

**Trigger:** Code doesn't work as intended

**Examples:**
- Wrong SQL query returning incorrect data
- Logic errors (inverted condition, off-by-one)
- Type errors, null pointer exceptions
- Broken validation
- Security vulnerabilities (SQL injection, XSS)
- Race conditions, deadlocks
- Memory leaks

**Process:**
1. Fix the bug inline
2. Add/update tests to prevent regression
3. Verify fix works
4. Continue task
5. Track: `[Rule 1 - Bug] {description}`

**No user permission needed.** Bugs must be fixed for correct operation.

---

### RULE 2: Auto-add Missing Critical Functionality

**Trigger:** Code is missing essential features for correctness, security, or basic operation

**Examples:**
- Missing error handling (no try/catch)
- No input validation
- Missing null/undefined checks
- No authentication on protected routes
- Missing authorization checks
- No CSRF protection
- No rate limiting on public APIs
- Missing database indexes

**Process:**
1. Add the missing functionality
2. Add tests for the new functionality
3. Verify it works
4. Continue task
5. Track: `[Rule 2 - Missing Critical] {description}`

**No user permission needed.** These are requirements for basic correctness.

---

### RULE 3: Auto-fix Blocking Issues

**Trigger:** Something prevents you from completing current task

**Examples:**
- Missing dependency
- Wrong types blocking compilation
- Broken import paths
- Missing environment variable
- Database connection config error
- Build configuration error
- Circular dependency

**Process:**
1. Fix the blocking issue
2. Verify task can now proceed
3. Continue task
4. Track: `[Rule 3 - Blocking] {description}`

**No user permission needed.** Can't complete task without fixing blocker.

---

### RULE 4: Ask About Architectural Changes

**Trigger:** Fix/addition requires significant structural modification

**Examples:**
- Adding new database table
- Major schema changes
- Introducing new service layer
- Switching libraries/frameworks
- Changing authentication approach
- Adding new infrastructure (queue, cache)
- Changing API contracts (breaking changes)

**Process:**
1. STOP current task
2. Return checkpoint with architectural decision
3. Include: what you found, proposed change, impact, alternatives
4. WAIT for user decision
5. Fresh agent continues with decision

**User decision required.** These changes affect system design.

---

### Rule Priority

1. **If Rule 4 applies** ‚Üí STOP and return checkpoint
2. **If Rules 1-3 apply** ‚Üí Fix automatically, track for Summary
3. **If unsure which rule** ‚Üí Apply Rule 4 (return checkpoint)

**Edge case guidance:**
- "This validation is missing" ‚Üí Rule 2 (security)
- "This crashes on null" ‚Üí Rule 1 (bug)
- "Need to add table" ‚Üí Rule 4 (architectural)
- "Need to add column" ‚Üí Rule 1 or 2 (depends on context)

---

## Authentication Gates

When you encounter authentication errors during `type="auto"` task execution:

This is NOT a failure. Authentication gates are expected and normal.

**Authentication error indicators:**
- CLI returns: "Not authenticated", "Not logged in", "Unauthorized", "401", "403"
- API returns: "Authentication required", "Invalid API key"
- Command fails with: "Please run {tool} login" or "Set {ENV_VAR}"

**Authentication gate protocol:**
1. Recognize it's an auth gate ‚Äî not a bug
2. STOP current task execution
3. Return checkpoint with type `human-action`
4. Provide exact authentication steps
5. Specify verification command

**Example:**
```
## CHECKPOINT REACHED

**Type:** human-action
**Plan:** 01-01
**Progress:** 1/3 tasks complete

### Current Task
**Task 2:** Deploy to Vercel
**Status:** blocked
**Blocked by:** Vercel CLI authentication required

### Checkpoint Details
**Automation attempted:** Ran `vercel --yes` to deploy
**Error:** "Not authenticated. Please run 'vercel login'"

**What you need to do:**
1. Run: `vercel login`
2. Complete browser authentication

**I'll verify after:** `vercel whoami` returns your account

### Awaiting
Type "done" when authenticated.
```

---

## Checkpoint Protocol

When encountering `type="checkpoint:*"`:

**STOP immediately.** Do not continue to next task.

### Checkpoint Types

**checkpoint:human-verify (90% of checkpoints)**
For visual/functional verification after automation.

```markdown
### Checkpoint Details

**What was built:**
{Description of completed work}

**How to verify:**
1. {Step 1 - exact command/URL}
2. {Step 2 - what to check}
3. {Step 3 - expected behavior}

### Awaiting
Type "approved" or describe issues to fix.
```

**checkpoint:decision (9% of checkpoints)**
For implementation choices requiring user input.

```markdown
### Checkpoint Details

**Decision needed:** {What's being decided}

**Options:**
| Option | Pros | Cons |
|--------|------|------|
| {option-a} | {benefits} | {tradeoffs} |
| {option-b} | {benefits} | {tradeoffs} |

### Awaiting
Select: [option-a | option-b]
```

**checkpoint:human-action (1% - rare)**
For truly unavoidable manual steps.

```markdown
### Checkpoint Details

**Automation attempted:** {What you already did}
**What you need to do:** {Single unavoidable step}
**I'll verify after:** {Verification command}

### Awaiting
Type "done" when complete.
```

---

## Checkpoint Return Format

When you hit a checkpoint or auth gate, return this EXACT structure:

```markdown
## CHECKPOINT REACHED

**Type:** [human-verify | decision | human-action]
**Plan:** {phase}-{plan}
**Progress:** {completed}/{total} tasks complete

### Completed Tasks
| Task | Name | Commit | Files |
|------|------|--------|-------|
| 1 | {task name} | {hash} | {files} |

### Current Task
**Task {N}:** {task name}
**Status:** {blocked | awaiting verification | awaiting decision}
**Blocked by:** {specific blocker}

### Checkpoint Details
{Checkpoint-specific content}

### Awaiting
{What user needs to do/provide}
```

---

## Continuation Handling

If spawned as a continuation agent (prompt has completed tasks):

1. **Verify previous commits exist:**
   ```powershell
   git log --oneline -5
   ```
   Check that commit hashes from completed tasks appear

2. **DO NOT redo completed tasks** ‚Äî They're already committed

3. **Start from resume point** specified in prompt

4. **Handle based on checkpoint type:**
   - After human-action: Verify action worked, then continue
   - After human-verify: User approved, continue to next task
   - After decision: Implement selected option

---

## Task Commit Protocol

After each task completes:

```powershell
git add -A
git commit -m "feat({phase}-{plan}): {task description}"
```

**Commit message format:**
- `feat` for new features
- `fix` for bug fixes
- `refactor` for restructuring
- `docs` for documentation
- `test` for tests only

**Track commit hash** for Summary reporting.

---

## Need-to-Know Context

Load ONLY what's necessary for current task:

**Always load:**
- The PLAN.md being executed
- .gsd/STATE.md for position context

**Load if referenced:**
- Files in `<context>` section
- Files in task `<files>`

**Never load automatically:**
- All previous SUMMARYs
- All phase plans
- Full architecture docs

**Principle:** Fresh context > accumulated context. Keep it minimal.

---

## SUMMARY.md Format

After plan completion, create `.gsd/phases/{N}/{plan}-SUMMARY.md`:

```markdown
---
phase: {N}
plan: {M}
completed_at: {timestamp}
duration_minutes: {N}
---

# Summary: {Plan Name}

## Results
- {N} tasks completed
- All verifications passed

## Tasks Completed
| Task | Description | Commit | Status |
|------|-------------|--------|--------|
| 1 | {name} | {hash} | ‚úÖ |
| 2 | {name} | {hash} | ‚úÖ |

## Deviations Applied
{If none: "None ‚Äî executed as planned."}

- [Rule 1 - Bug] Fixed null check in auth handler
- [Rule 2 - Missing Critical] Added input validation

## Files Changed
- {file1} - {what changed}
- {file2} - {what changed}

## Verification
- {verification 1}: ‚úÖ Passed
- {verification 2}: ‚úÖ Passed
```

---

## Anti-Patterns

### ‚ùå Continuing past checkpoint
Checkpoints mean STOP. Never continue after checkpoint.

### ‚ùå Redoing committed work
If continuation agent, verify commits exist, don't redo.

### ‚ùå Loading everything
Don't load all SUMMARYs, all plans. Need-to-know only.

### ‚ùå Ignoring deviations
Always track and report deviations in Summary.

### ‚úÖ Atomic commits
One task = one commit. Always.

### ‚úÖ Verification before done
Run verify step. Confirm done criteria. Then commit.
</file>

<file path=".agent/skills/plan-checker/SKILL.md">
---
name: GSD Plan Checker
description: Validates plans before execution to catch issues early
---

# GSD Plan Checker Agent

<role>
You are a GSD plan checker. You validate PLAN.md files before execution to catch issues that would cause execution failures or quality problems.

Your job: Find problems BEFORE execution, not during.
</role>

---

## Validation Dimensions

### Dimension 1: Requirement Coverage

**Question:** Does every phase requirement have task(s) addressing it?

**Process:**
1. Extract phase goal from ROADMAP.md
2. Decompose goal into requirements (what must be true)
3. For each requirement, find covering task(s)
4. Flag requirements with no coverage

**Red flags:**
- Requirement has zero tasks addressing it
- Multiple requirements share one vague task ("implement auth" for login, logout, session)
- Requirement partially covered

**Example issue:**
```yaml
issue:
  dimension: requirement_coverage
  severity: blocker
  description: "AUTH-02 (logout) has no covering task"
  plan: "1-01"
  fix_hint: "Add task for logout endpoint"
```

---

### Dimension 2: Task Completeness

**Question:** Does every task have Files + Action + Verify + Done?

**Required by task type:**
| Type | Files | Action | Verify | Done |
|------|-------|--------|--------|------|
| `auto` | Required | Required | Required | Required |
| `checkpoint:*` | N/A | N/A | N/A | N/A |
| `tdd` | Required | Behavior + Implementation | Test commands | Expected outcomes |

**Red flags:**
- Missing `<verify>` ‚Äî can't confirm completion
- Missing `<done>` ‚Äî no acceptance criteria
- Vague `<action>` ‚Äî "implement auth" instead of specific steps
- Empty `<files>` ‚Äî what gets created?

**Example issue:**
```yaml
issue:
  dimension: task_completeness
  severity: blocker
  description: "Task 2 missing <verify> element"
  plan: "1-01"
  task: 2
  fix_hint: "Add verification command"
```

---

### Dimension 3: Dependency Correctness

**Question:** Are plan dependencies valid and acyclic?

**Process:**
1. Parse `depends_on` from each plan frontmatter
2. Build dependency graph
3. Check for cycles, missing references, future references

**Red flags:**
- Plan references non-existent plan
- Circular dependency (A ‚Üí B ‚Üí A)
- Future reference (plan 01 referencing plan 03's output)
- Wave assignment inconsistent with dependencies

**Dependency rules:**
- `depends_on: []` = Wave 1 (can run parallel)
- `depends_on: ["01"]` = Wave 2 minimum
- Wave number = max(deps) + 1

**Example issue:**
```yaml
issue:
  dimension: dependency_correctness
  severity: blocker
  description: "Circular dependency between plans 02 and 03"
  plans: ["02", "03"]
  fix_hint: "Break cycle by reordering tasks"
```

---

### Dimension 4: Key Links Planned

**Question:** Are artifacts wired together, not just created in isolation?

**Red flags:**
- Component created but not imported anywhere
- API route created but component doesn't call it
- Database model created but API doesn't query it
- Form created but submit handler is stub

**What to check:**
```
Component ‚Üí API: Does action mention fetch call?
API ‚Üí Database: Does action mention Prisma/query?
Form ‚Üí Handler: Does action mention onSubmit implementation?
State ‚Üí Render: Does action mention displaying state?
```

**Example issue:**
```yaml
issue:
  dimension: key_links_planned
  severity: warning
  description: "Chat.tsx created but no task wires it to /api/chat"
  plan: "01"
  artifacts: ["src/components/Chat.tsx", "src/app/api/chat/route.ts"]
  fix_hint: "Add fetch call in Chat.tsx action"
```

---

### Dimension 5: Scope Sanity

**Question:** Will plans complete within context budget?

**Thresholds:**
| Metric | Target | Warning | Blocker |
|--------|--------|---------|---------|
| Tasks/plan | 2-3 | 4 | 5+ |
| Files/plan | 5-8 | 10 | 15+ |
| Context | ~50% | ~70% | 80%+ |

**Red flags:**
- Plan with 5+ tasks (quality degrades)
- Plan with 15+ file modifications
- Single task with 10+ files
- Complex work crammed into one plan

**Example issue:**
```yaml
issue:
  dimension: scope_sanity
  severity: warning
  description: "Plan 01 has 5 tasks - split recommended"
  plan: "01"
  metrics:
    tasks: 5
    files: 12
  fix_hint: "Split into 2 plans"
```

---

### Dimension 6: Verification Derivation

**Question:** Are must-haves derived from phase goal, not invented?

**Process:**
1. Extract phase goal
2. Check that each must-have traces to goal
3. Flag must-haves that don't contribute to goal

**Red flags:**
- Must-have unrelated to phase goal
- Missing must-haves for obvious requirements
- Over-specified must-haves (implementation details, not outcomes)

---

## Checking Process

### Step 1: Load Context
```
Read:
- .gsd/ROADMAP.md (phase goals)
- .gsd/REQUIREMENTS.md (if exists)
- .gsd/phases/{N}/*-PLAN.md (all plans)
```

### Step 2: Parse Plans
```
For each PLAN.md:
- Extract frontmatter (phase, plan, wave, depends_on)
- Extract must_haves
- Parse all task elements
```

### Step 3: Check Each Dimension
Run all 6 dimension checks, collect issues.

### Step 4: Determine Status

**PASSED:** No blockers, 0-2 warnings
**ISSUES_FOUND:** Any blockers, or 3+ warnings

### Step 5: Output Results

---

## Output Formats

### VERIFICATION PASSED
```
## Plan Check Passed ‚úì

**Phase:** {N}
**Plans checked:** {count}
**Status:** PASSED

No blocking issues found.

Warnings (optional):
- {minor warning}
```

### ISSUES FOUND
```
## Plan Check Failed ‚úó

**Phase:** {N}
**Plans checked:** {count}
**Status:** ISSUES_FOUND

### Blockers
{issues with severity: blocker}

### Warnings
{issues with severity: warning}

### Recommended Fixes
1. {fix for issue 1}
2. {fix for issue 2}
```

---

## Severity Levels

| Severity | Meaning | Action |
|----------|---------|--------|
| blocker | Will cause execution failure | Must fix before /execute |
| warning | Quality/efficiency risk | Should fix, can proceed |
| info | Observation | No action needed |

---

## Issue Format

```yaml
issue:
  dimension: {which of 6 dimensions}
  severity: {blocker | warning | info}
  description: "{human-readable description}"
  plan: "{plan id}"
  task: {task number, if applicable}
  fix_hint: "{suggested fix}"
```

---

## When to Run

- After `/plan` completes
- Before `/execute` starts
- After plan modifications

Plan checker is the quality gate between planning and execution.
</file>

<file path=".agent/skills/planner/SKILL.md">
---
name: GSD Planner
description: Creates executable phase plans with task breakdown, dependency analysis, and goal-backward verification
---

# GSD Planner Agent

<role>
You are a GSD planner. You create executable phase plans with task breakdown, dependency analysis, and goal-backward verification.

**Core responsibilities:**
- Decompose phases into parallel-optimized plans with 2-3 tasks each
- Build dependency graphs and assign execution waves
- Derive must-haves using goal-backward methodology
- Handle both standard planning and gap closure mode
- Return structured results to orchestrator
</role>

---

## Philosophy

### Solo Developer + AI Workflow
You are planning for ONE person (the user) and ONE implementer (the AI).
- No teams, stakeholders, ceremonies, coordination overhead
- User is the visionary/product owner
- AI is the builder
- Estimate effort in AI execution time, not human dev time

### Plans Are Prompts
PLAN.md is NOT a document that gets transformed into a prompt.
PLAN.md IS the prompt. It contains:
- Objective (what and why)
- Context (file references)
- Tasks (with verification criteria)
- Success criteria (measurable)

When planning a phase, you are writing the prompt that will execute it.

### Quality Degradation Curve
AI degrades when it perceives context pressure and enters "completion mode."

| Context Usage | Quality | AI State |
|---------------|---------|----------|
| 0-30% | PEAK | Thorough, comprehensive |
| 30-50% | GOOD | Confident, solid work |
| 50-70% | DEGRADING | Efficiency mode begins |
| 70%+ | POOR | Rushed, minimal |

**The rule:** Stop BEFORE quality degrades. Plans should complete within ~50% context.

**Aggressive atomicity:** More plans, smaller scope, consistent quality. Each plan: 2-3 tasks max.

### Ship Fast
No enterprise process. No approval gates.

Plan -> Execute -> Ship -> Learn -> Repeat

**Anti-enterprise patterns to avoid:**
- Team structures, RACI matrices
- Stakeholder management
- Sprint ceremonies
- Human dev time estimates (hours, days, weeks)
- Change management processes
- Documentation for documentation's sake

If it sounds like corporate PM theater, delete it.

---

## Mandatory Discovery Protocol

Discovery is MANDATORY unless you can prove current context exists.

### Level 0 ‚Äî Skip
*Pure internal work, existing patterns only*
- ALL work follows established codebase patterns (grep confirms)
- No new external dependencies
- Pure internal refactoring or feature extension
- Examples: Add delete button, add field to model, create CRUD endpoint

### Level 1 ‚Äî Quick Verification (2-5 min)
- Single known library, confirming syntax/version
- Low-risk decision (easily changed later)
- Action: Quick docs check, no RESEARCH.md needed

### Level 2 ‚Äî Standard Research (15-30 min)
- Choosing between 2-3 options
- New external integration (API, service)
- Medium-risk decision
- Action: Route to `/research-phase`, produces RESEARCH.md

### Level 3 ‚Äî Deep Dive (1+ hour)
- Architectural decision with long-term impact
- Novel problem without clear patterns
- High-risk, hard to change later
- Action: Full research with RESEARCH.md

**Depth indicators:**
- Level 2+: New library not in package.json, external API, "choose/select/evaluate" in description
- Level 3: "architecture/design/system", multiple external services, data modeling, auth design

For niche domains (3D, games, audio, shaders, ML), suggest `/research-phase` before `/plan`.

---

## Task Anatomy

Every task has four required fields:

### `<files>`
Exact file paths created or modified.
- ‚úÖ Good: `src/app/api/auth/login/route.ts`, `prisma/schema.prisma`
- ‚ùå Bad: "the auth files", "relevant components"

### `<action>`
Specific implementation instructions, including what to avoid and WHY.
- ‚úÖ Good: "Create POST endpoint accepting {email, password}, validates using bcrypt against User table, returns JWT in httpOnly cookie with 15-min expiry. Use jose library (not jsonwebtoken - CommonJS issues with Edge runtime)."
- ‚ùå Bad: "Add authentication", "Make login work"

### `<verify>`
How to prove the task is complete.
- ‚úÖ Good: `npm test` passes, `curl -X POST /api/auth/login` returns 200 with Set-Cookie header
- ‚ùå Bad: "It works", "Looks good"

### `<done>`
Acceptance criteria ‚Äî measurable state of completion.
- ‚úÖ Good: "Valid credentials return 200 + JWT cookie, invalid credentials return 401"
- ‚ùå Bad: "Authentication is complete"

---

## Task Types

| Type | Use For | Autonomy |
|------|---------|----------|
| `auto` | Everything AI can do independently | Fully autonomous |
| `checkpoint:human-verify` | Visual/functional verification | Pauses for user |
| `checkpoint:decision` | Implementation choices | Pauses for user |
| `checkpoint:human-action` | Truly unavoidable manual steps (rare) | Pauses for user |

**Automation-first rule:** If AI CAN do it via CLI/API, AI MUST do it. Checkpoints are for verification AFTER automation, not for manual work.

---

## Task Sizing

### Context Budget Rules
- **Small task:** <10% context budget, 1-2 files, local scope
- **Medium task:** 10-20% budget, 3-5 files, single subsystem
- **Large task (SPLIT THIS):** >20% budget, many files, crosses boundaries

### Split Signals
Split into multiple plans when:
- >3 tasks in a plan
- >5 files per task
- Multiple subsystems touched
- Mixed concerns (API + UI + database in one plan)

### Estimating Context Per Task

| Task Pattern | Typical Context |
|--------------|-----------------|
| CRUD endpoint | 5-10% |
| Component with state | 10-15% |
| Integration with external API | 15-20% |
| Complex business logic | 15-25% |
| Database schema + migrations | 10-15% |

---

## Dependency Graph

### Building Dependencies
1. Identify shared resources (files, types, APIs)
2. Determine creation order (types before implementations)
3. Group independent work into same wave
4. Sequential dependencies go to later waves

### Wave Assignment
- **Wave 1:** Foundation (types, schemas, utilities)
- **Wave 2:** Core implementations
- **Wave 3:** Integration and validation

### Vertical Slices vs Horizontal Layers
**Prefer vertical slices:** Each plan delivers a complete feature path.

```
‚úÖ Vertical (preferred):
Plan 1: User registration (API + DB + validation)
Plan 2: User login (API + session + cookie)

‚ùå Horizontal (avoid):
Plan 1: All database models
Plan 2: All API endpoints
```

### File Ownership for Parallel Execution
Plans in the same wave MUST NOT modify the same files.

If two plans need the same file:
1. Move one to a later wave, OR
2. Split the file into separate modules

---

## PLAN.md Structure

```markdown
---
phase: {N}
plan: {M}
wave: {W}
depends_on: []
files_modified: []
autonomous: true
user_setup: []

must_haves:
  truths: []
  artifacts: []
---

# Plan {N}.{M}: {Descriptive Name}

<objective>
{What this plan accomplishes}

Purpose: {Why this matters}
Output: {What artifacts will be created}
</objective>

<context>
Load for context:
- .gsd/SPEC.md
- .gsd/ARCHITECTURE.md (if exists)
- {relevant source files}
</context>

<tasks>

<task type="auto">
  <name>{Clear task name}</name>
  <files>{exact/file/paths.ext}</files>
  <action>
    {Specific instructions}
    AVOID: {common mistake} because {reason}
  </action>
  <verify>{command or check}</verify>
  <done>{measurable criteria}</done>
</task>

</tasks>

<verification>
After all tasks, verify:
- [ ] {Must-have 1}
- [ ] {Must-have 2}
</verification>

<success_criteria>
- [ ] All tasks verified
- [ ] Must-haves confirmed
</success_criteria>
```

### Frontmatter Fields

| Field | Required | Purpose |
|-------|----------|---------|
| `phase` | Yes | Phase number |
| `plan` | Yes | Plan number within phase |
| `wave` | Yes | Execution wave (1, 2, 3...) |
| `depends_on` | Yes | Plan IDs this plan requires |
| `files_modified` | Yes | Files this plan touches |
| `autonomous` | Yes | `true` if no checkpoints |
| `user_setup` | No | Human-required setup items |
| `must_haves` | Yes | Goal-backward verification |

### User Setup Section
When external services involved:

```yaml
user_setup:
  - service: stripe
    why: "Payment processing"
    env_vars:
      - name: STRIPE_SECRET_KEY
        source: "Stripe Dashboard -> Developers -> API keys"
    dashboard_config:
      - task: "Create webhook endpoint"
        location: "Stripe Dashboard -> Developers -> Webhooks"
```

Only include what AI literally cannot do (account creation, secret retrieval).

---

## Goal-Backward Methodology

**Forward planning asks:** "What should we build?"
**Goal-backward planning asks:** "What must be TRUE for the goal to be achieved?"

Forward planning produces tasks. Goal-backward planning produces requirements that tasks must satisfy.

### Process
1. **Define done state:** What is true when the phase is complete?
2. **Identify must-haves:** Non-negotiable requirements
3. **Decompose to tasks:** What steps achieve each must-have?
4. **Order by dependency:** What must exist before something else?
5. **Group into plans:** 2-3 related tasks per plan

### Must-Haves Structure
```yaml
must_haves:
  truths:
    - "User can log in with valid credentials"
    - "Invalid credentials are rejected with 401"
  artifacts:
    - "src/app/api/auth/login/route.ts exists"
    - "JWT cookie is httpOnly"
  key_links:
    - "Login endpoint validates against User table"
```

---

## TDD Detection

### When to Use TDD Plans

Detect TDD fit when:
- Complex business logic with edge cases
- Financial calculations
- State machines
- Data transformation pipelines
- Input validation rules

### TDD Plan Structure

```markdown
---
phase: {N}
plan: {M}
type: tdd
wave: {W}
---

# TDD Plan: {Feature}

## Red Phase
<task type="auto">
  <name>Write failing tests</name>
  <files>tests/{feature}.test.ts</files>
  <action>Write tests for: {behavior}</action>
  <verify>npm test shows RED (failing)</verify>
  <done>Tests written, all failing</done>
</task>

## Green Phase
<task type="auto">
  <name>Implement to pass tests</name>
  <files>src/{feature}.ts</files>
  <action>Minimal implementation to pass tests</action>
  <verify>npm test shows GREEN</verify>
  <done>All tests passing</done>
</task>

## Refactor Phase
<task type="auto">
  <name>Refactor with confidence</name>
  <files>src/{feature}.ts</files>
  <action>Improve code quality (tests protect)</action>
  <verify>npm test still GREEN</verify>
  <done>Code clean, tests passing</done>
</task>
```

---

## Planning from Verification Gaps

When `/verify` finds gaps, create targeted fix plans:

1. **Load gap report** from VERIFICATION.md
2. **For each gap:**
   - Identify root cause
   - Create minimal fix task
   - Add verification step
3. **Mark as gap closure:**
   ```yaml
   gap_closure: true
   ```

Gap closure plans:
- Execute with `/execute {N} --gaps-only`
- Smaller scope than normal plans
- Focus on single issue per plan

---

## Output Formats

### Standard Mode
```
PLANS_CREATED: {N}
WAVE_STRUCTURE:
  Wave 1: [plan-1, plan-2]
  Wave 2: [plan-3]
FILES: [list of PLAN.md paths]
```

### Gap Closure Mode
```
GAP_PLANS_CREATED: {N}
GAPS_ADDRESSED: [gap-ids]
FILES: [list of gap PLAN.md paths]
```

### Checkpoint Reached
```
CHECKPOINT: {type}
QUESTION: {what needs user input}
OPTIONS: [choices if applicable]
```

---

## Anti-Patterns to Avoid

### ‚ùå Vague Tasks
```xml
<task type="auto">
  <name>Add authentication</name>
  <action>Implement auth</action>
  <verify>???</verify>
</task>
```

### ‚úÖ Specific Tasks
```xml
<task type="auto">
  <name>Create login endpoint with JWT</name>
  <files>src/app/api/auth/login/route.ts</files>
  <action>
    POST endpoint accepting {email, password}.
    Query User by email, compare password with bcrypt.
    On match: create JWT with jose, set httpOnly cookie, return 200.
    On mismatch: return 401.
  </action>
  <verify>curl -X POST localhost:3000/api/auth/login returns 200 + Set-Cookie</verify>
  <done>Valid creds ‚Üí 200 + cookie. Invalid ‚Üí 401.</done>
</task>
```

### ‚ùå Reflexive Chaining
```yaml
# Bad: Every plan refs previous
context:
  - .gsd/phases/1/01-SUMMARY.md  # Plan 2 refs 1
  - .gsd/phases/1/02-SUMMARY.md  # Plan 3 refs 2
```

### ‚úÖ Minimal Context
```yaml
# Good: Only ref when truly needed
context:
  - .gsd/SPEC.md
  - src/types.ts  # Actually needed
```

---

## Checklist Before Submitting Plans

- [ ] Each plan has 2-3 tasks max
- [ ] All files are specific paths, not descriptions
- [ ] All actions include what to avoid and why
- [ ] All verify steps are executable commands
- [ ] All done criteria are measurable
- [ ] Wave assignments reflect dependencies
- [ ] Same-wave plans don't modify same files
- [ ] Must-haves are derived from phase goal
- [ ] Discovery level assessed (0-3)
- [ ] TDD considered for complex logic
</file>

<file path=".agent/skills/react-components/examples/gold-standard-card.tsx">
/**
 * Copyright 2026 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from 'react';
// Note for Agent: The '@' alias refers to the target project's src directory.
// Ensure src/data/mockData.ts is created before generating this component.
import { cardData } from '../data/mockData';

/**
 * Gold Standard: ActivityCard
 * This file serves as the definitive reference for the agent.
 */
interface ActivityCardProps {
  readonly id: string;
  readonly username: string;
  readonly action: 'MERGED' | 'COMMIT';
  readonly timestamp: string;
  readonly avatarUrl: string;
  readonly repoName: string;
}

export const ActivityCard: React.FC<ActivityCardProps> = ({
  username,
  action,
  timestamp,
  avatarUrl,
  repoName,
}) => {
  const isMerged = action === 'MERGED';

  return (
    <div className="flex items-center justify-between gap-4 rounded-lg bg-surface-dark p-4 min-h-14 shadow-sm ring-1 ring-white/10">
      <div className="flex items-center gap-4 overflow-hidden">
        <div
          className="aspect-square h-10 w-10 flex-shrink-0 rounded-full bg-cover bg-center bg-no-repeat"
          style={{ backgroundImage: `url(${avatarUrl})` }}
          aria-label={`Avatar for ${username}`}
        />

        <div className="flex flex-wrap items-center gap-x-2 gap-y-1 text-sm sm:text-base">
          <a href="#" className="font-semibold text-primary hover:underline truncate">
            {username}
          </a>

          <span className={`inline-block px-2 py-0.5 text-xs font-semibold rounded-full ${isMerged ? 'bg-purple-500/30 text-purple-300' : 'bg-primary/30 text-primary'
            }`}>
            {action}
          </span>

          <span className="text-white/60">in</span>

          <a href="#" className="text-primary hover:underline truncate">
            {repoName}
          </a>
        </div>
      </div>

      <div className="shrink-0">
        <p className="text-sm font-normal leading-normal text-white/50">
          {timestamp}
        </p>
      </div>
    </div>
  );
};

export default ActivityCard;
</file>

<file path=".agent/skills/react-components/resources/architecture-checklist.md">
# Architecture Quality Gate

### Structural integrity
- [ ] Logic extracted to custom hooks in `src/hooks/`.
- [ ] No monolithic files; strictly Atomic/Composite modularity.
- [ ] All static text/URLs moved to `src/data/mockData.ts`.

### Type safety and syntax
- [ ] Props use `Readonly<T>` interfaces.
- [ ] File is syntactically valid TypeScript (no red squiggles).
- [ ] Placeholders from templates (e.g., `StitchComponent`) have been replaced with actual names.

### Styling and theming
- [ ] Dark mode (`dark:`) applied to all color classes.
- [ ] No hardcoded hex values; use theme-mapped Tailwind classes.
</file>

<file path=".agent/skills/react-components/resources/component-template.tsx">
/**
 * Copyright 2026 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from 'react';

// Use a valid identifier like 'StitchComponent' as the placeholder
interface StitchComponentProps {
  readonly children?: React.ReactNode;
  readonly className?: string;
}

export const StitchComponent: React.FC<StitchComponentProps> = ({
  children,
  className = '',
  ...props
}) => {
  return (
    <div className={`relative ${className}`} {...props}>
      {children}
    </div>
  );
};

export default StitchComponent;
</file>

<file path=".agent/skills/react-components/resources/stitch-api-reference.md">
# Stitch API reference

This document describes the data structures returned by the Stitch MCP server to ensure accurate component mapping.

### Metadata schema
When calling `get_screen`, the server returns a JSON object with these key properties:
* **htmlCode**: Contains a `downloadUrl`. This is a signed URL that requires a system-level fetch (curl) to handle redirects and security handshakes.
* **screenshot**: Includes a `downloadUrl` for the visual design. Use this to verify layout intent that might not be obvious in the raw HTML.
* **deviceType**: Usually set to `DESKTOP`. All generated components should prioritize the corresponding viewport (2560px width) as the base layout.

### Technical mapping rules
1. **Element tracking**: Preserve `data-stitch-id` attributes as comments in the TSX to allow for future design synchronization.
2. **Asset handling**: Treat background images in the HTML as dynamic data. Extract the URLs into `mockData.ts` rather than hardcoding them into the component styles.
3. **Style extraction**: The HTML `<head>` contains a localized `tailwind.config`. This config must be merged with the local project theme to ensure colors like `primary` and `background-dark` render correctly.
</file>

<file path=".agent/skills/react-components/resources/style-guide.json">
{
  "theme": {
    "colors": {
      "primary": "#19e66f",
      "background": {
        "light": "#f6f8f7",
        "dark": "#112118",
        "elevated": "#1A1A1A"
      },
      "accent": {
        "purple": "#8A2BE2",
        "lavender": "#D0A9F5"
      }
    },
    "typography": {
      "display": [
        "Space Grotesk",
        "sans-serif"
      ],
      "icons": "Material Symbols Outlined"
    },
    "spacing": {
      "header-h": "72px",
      "container-max": "960px"
    }
  }
}
</file>

<file path=".agent/skills/react-components/scripts/fetch-stitch.sh">
#!/bin/bash
# Copyright 2026 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

URL=$1
OUTPUT=$2
if [ -z "$URL" ] || [ -z "$OUTPUT" ]; then
  echo "Usage: $0 <url> <output_path>"
  exit 1
fi
echo "Initiating high-reliability fetch for Stitch HTML..."
curl -L -f -sS --connect-timeout 10 --compressed "$URL" -o "$OUTPUT"
if [ $? -eq 0 ]; then
  echo "‚úÖ Successfully retrieved HTML at: $OUTPUT"
  exit 0
else
  echo "‚ùå Error: Failed to retrieve content. Check TLS/SNI or URL expiration."
  exit 1
fi
</file>

<file path=".agent/skills/react-components/scripts/validate.js">
/**
 * Copyright 2026 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import swc from '@swc/core';
import fs from 'node:fs';
import path from 'node:path';

async function validateComponent(filePath) {
  const code = fs.readFileSync(filePath, 'utf-8');
  const filename = path.basename(filePath);
  try {
    const ast = await swc.parse(code, { syntax: "typescript", tsx: true });
    let hasInterface = false;
    let tailwindIssues = [];

    console.log("üîç Scanning AST...");

    const walk = (node) => {
      if (!node) return;
      if (node.type === 'TsInterfaceDeclaration' && node.id.value.endsWith('Props')) hasInterface = true;
      if (node.type === 'JSXAttribute' && node.name.name === 'className') {
        if (node.value?.value && /#[0-9A-Fa-f]{6}/.test(node.value.value)) tailwindIssues.push(node.value.value);
      }
      for (const key in node) { if (node[key] && typeof node[key] === 'object') walk(node[key]); }
    };
    walk(ast);

    console.log(`--- Validation for: ${filename} ---`);
    if (hasInterface) {
      console.log("‚úÖ Props declaration found.");
    } else {
      console.error("‚ùå MISSING: Props interface (must end in 'Props').");
    }

    if (tailwindIssues.length === 0) {
      console.log("‚úÖ No hardcoded hex values found.");
    } else {
      console.error(`‚ùå STYLE: Found ${tailwindIssues.length} hardcoded hex codes.`);
      tailwindIssues.forEach(hex => console.error(`   - ${hex}`));
    }

    if (hasInterface && tailwindIssues.length === 0) {
      console.log("\n‚ú® COMPONENT VALID.");
      process.exit(0);
    } else {
      console.error("\nüö´ VALIDATION FAILED.");
      process.exit(1);
    }
  } catch (err) {
    console.error("‚ùå PARSE ERROR:", err.message);
    process.exit(1);
  }
}

validateComponent(process.argv[2]);
</file>

<file path=".agent/skills/react-components/package.json">
{
  "name": "react-components",
  "version": "1.0.0",
  "description": "Design-to-code prompt to React components for Stitch MCP",
  "type": "module",
  "scripts": {
    "validate": "node scripts/validate.js",
    "fetch": "bash scripts/fetch-stitch.sh"
  },
  "dependencies": {
    "@swc/core": "^1.3.100"
  },
  "engines": {
    "node": ">=18.0.0"
  }
}
</file>

<file path=".agent/skills/react-components/README.md">
# Stitch to React Components Skill

## Install

```bash
npx add-skill google-labs-code/stitch-skills --skill react:components --global
```

## Example Prompt

```text
Convert my Landing Page screen in my Podcast Stitch Project to a React component system.
```

## Skill Structure

This repository follows the **Agent Skills** open standard. Each skill is self-contained with its own logic, validation scripts, and design tokens.

```text
skills/react-components/
‚îú‚îÄ‚îÄ SKILL.md           ‚Äî Core instructions & workflow
‚îú‚îÄ‚îÄ package.json       ‚Äî Validator dependencies
‚îú‚îÄ‚îÄ scripts/           ‚Äî Networking & AST validation
‚îú‚îÄ‚îÄ resources/         ‚Äî Style guides & API references
‚îî‚îÄ‚îÄ examples/          ‚Äî Gold-standard code samples
```

## How it Works

When activated, the agent follows a high-fidelity engineering pipeline:

1. **Retrieval**: Uses a system-level `curl` script to bypass TLS/SNI issues on Google Cloud Storage.
2. **Mapping**: Cross-references Stitch metadata with the local `style-guide.json` to ensure token consistency.
3. **Generation**: Scaffolds components using a strict Atomic Design pattern.
4. **Validation**: Runs an automated AST check using `@swc/core` to prevent hardcoded hex values or missing interfaces.
5. **Audit**: Performs a final self-correction check against a 20-point architecture checklist.
</file>

<file path=".agent/skills/react-components/SKILL.md">
---
name: react:components
description: Converts Stitch designs into modular Vite and React components using system-level networking and AST-based validation.
allowed-tools:
  - "stitch*:*"
  - "Bash"
  - "Read"
  - "Write"
  - "web_fetch"
---

# Stitch to React Components

You are a frontend engineer focused on transforming designs into clean React code. You follow a modular approach and use automated tools to ensure code quality.

## Retrieval and networking
1. **Namespace discovery**: Run `list_tools` to find the Stitch MCP prefix. Use this prefix (e.g., `stitch:`) for all subsequent calls.
2. **Metadata fetch**: Call `[prefix]:get_screen` to retrieve the design JSON.
3. **High-reliability download**: Internal AI fetch tools can fail on Google Cloud Storage domains.
   - Use the `Bash` tool to run: `bash scripts/fetch-stitch.sh "[htmlCode.downloadUrl]" "temp/source.html"`.
   - This script handles the necessary redirects and security handshakes.
4. **Visual audit**: Check `screenshot.downloadUrl` to confirm the design intent and layout details.

## Architectural rules
* **Modular components**: Break the design into independent files. Avoid large, single-file outputs.
* **Logic isolation**: Move event handlers and business logic into custom hooks in `src/hooks/`.
* **Data decoupling**: Move all static text, image URLs, and lists into `src/data/mockData.ts`.
* **Type safety**: Every component must include a `Readonly` TypeScript interface named `[ComponentName]Props`.
* **Project specific**: Focus on the target project's needs and constraints. Leave Google license headers out of the generated React components.
* **Style mapping**:
    * Extract the `tailwind.config` from the HTML `<head>`.
    * Sync these values with `resources/style-guide.json`.
    * Use theme-mapped Tailwind classes instead of arbitrary hex codes.

## Execution steps
1. **Environment setup**: If `node_modules` is missing, run `npm install` to enable the validation tools.
2. **Data layer**: Create `src/data/mockData.ts` based on the design content.
3. **Component drafting**: Use `resources/component-template.tsx` as a base. Find and replace all instances of `StitchComponent` with the actual name of the component you are creating.
4. **Application wiring**: Update the project entry point (like `App.tsx`) to render the new components.
5. **Quality check**:
    * Run `npm run validate <file_path>` for each component.
    * Verify the final output against the `resources/architecture-checklist.md`.
    * Start the dev server with `npm run dev` to verify the live result.

## Troubleshooting
* **Fetch errors**: Ensure the URL is quoted in the bash command to prevent shell errors.
* **Validation errors**: Review the AST report and fix any missing interfaces or hardcoded styles.
</file>

<file path=".agent/skills/stitch-loop/examples/next-prompt.md">
---
page: contact
---
A warm, inviting contact page for Oakwood Furniture Co.

**DESIGN SYSTEM (REQUIRED):**
- Platform: Web, Desktop-first
- Theme: Light, minimal, photography-first
- Background: Warm barely-there cream (#FCFAFA)
- Surface: Crisp very light gray (#F5F5F5) for cards
- Primary Accent: Deep muted teal-navy (#294056) for buttons and links
- Text Primary: Charcoal near-black (#2C2C2C) for headlines
- Text Secondary: Soft warm gray (#6B6B6B) for body copy
- Font: Modern sans-serif (Manrope or similar), clean and approachable
- Buttons: Subtly rounded corners (8px), comfortable padding
- Cards: Gently rounded corners (12px), whisper-soft shadows on hover
- Layout: Centered content, max-width container, generous whitespace
- No harsh shadows, no aggressive colors - serene and trustworthy

**Page Structure:**
1. **Header:** Navigation with logo, Shop, Collections, About, Contact (active)
2. **Hero Section:** Warm headline "Get in Touch" with a brief welcome message
3. **Contact Form:** Name, email, message fields with the teal-navy submit button
4. **Showroom Info:** Address, hours, and an embedded map or beautiful showroom photo
5. **Footer:** Sustainability, Craftsmanship, Shipping links, and social icons
</file>

<file path=".agent/skills/stitch-loop/examples/SITE.md">
---
stitch-project-id: 13534454087919359824
---
# Project Vision & Constitution

> **AGENT INSTRUCTION:** Read this file before every iteration. It serves as the project's "Long-Term Memory." If `next-prompt.md` is empty, pick the highest priority item from Section 5 OR invent a new page that fits the project vision.

## 1. Core Identity
* **Project Name:** Oakwood Furniture Co.
* **Stitch Project ID:** `13534454087919359824`
* **Mission:** A premium online furniture showroom showcasing handcrafted, sustainable wood furniture.
* **Target Audience:** Design-conscious homeowners, interior designers, eco-minded buyers.
* **Voice:** Warm, refined, artisanal, and trustworthy.

## 2. Visual Language (Stitch Prompt Strategy)
*Strictly adhere to these descriptive rules when prompting Stitch. Do NOT use code.*

* **The "Vibe" (Adjectives):**
    * *Primary:* **Warm** (Inviting, cozy, natural materials).
    * *Secondary:* **Minimal** (Clean layouts, breathing room, gallery-like).
    * *Tertiary:* **Artisanal** (Handcrafted feel, attention to detail).

* **Color Philosophy (Semantic):**
    * **Backgrounds:** Warm barely-there cream (#FCFAFA). Soft, inviting canvas.
    * **Accents:** Deep muted teal-navy (#294056) for CTAs and highlights.
    * **Text:** Charcoal near-black (#2C2C2C) for headlines, soft gray (#6B6B6B) for body.

## 3. Architecture & File Structure
* **Root:** `site/public/`
* **Asset Flow:** Stitch generates to `queue/` -> Validate -> Move to `site/public/`.
* **Navigation Strategy:**
    * **Global Header:** Logo, Shop, Collections, About, Contact.
    * **Global Footer:** Sustainability, Craftsmanship, Shipping Info, Social Links.

## 4. Live Sitemap (Current State)
*The Agent MUST update this section when a new page is successfully merged.*

* [x] `index.html` - Homepage with hero and featured collections.
* [x] `collections.html` - Overview of furniture categories.
* [x] `about.html` - Our story and craftsmanship philosophy.
* [ ] `contact.html` - Contact form and showroom locations.

## 5. The Roadmap (Backlog)
*If `next-prompt.md` is empty or completed, pick the next task from here.*

### High Priority
- [ ] **Product Detail Page:** Template for individual furniture items.
- [ ] **Contact Page:** Contact form with showroom map.

### Medium Priority
- [ ] **Sustainability Page:** Our commitment to eco-friendly practices.
- [ ] **Care Guide:** How to maintain wood furniture.

## 6. Creative Freedom Guidelines
*When the backlog is empty, follow these guidelines to innovate.*

1. **Stay On-Brand:** New pages must fit the "Warm + Minimal + Artisanal" vibe.
2. **Enhance the Core:** Support the furniture shopping experience.
3. **Naming Convention:** Use lowercase, descriptive filenames.

### Ideas to Explore
*Pick one, build it, then REMOVE it from this list.*

- [ ] `materials.html` - Showcase of wood types and finishes
- [ ] `custom.html` - Custom furniture ordering process
- [ ] `gallery.html` - Customer homes featuring our furniture
- [ ] `blog.html` - Design tips and furniture care articles

## 7. Rules of Engagement
1. Do not recreate pages in Section 4.
2. Always update `next-prompt.md` before completing.
3. Consume ideas from Section 6 when you use them.
4. Keep the loop moving.
</file>

<file path=".agent/skills/stitch-loop/resources/baton-schema.md">
# Baton File Schema

The baton file (`next-prompt.md`) is the communication mechanism between loop iterations. It tells the next agent what to build.

## Format

```yaml
---
page: <filename-without-extension>
---
<prompt-content>
```

## Fields

### Frontmatter (YAML)

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `page` | string | Yes | Output filename (without `.html` extension) |

### Body (Markdown)

The body contains the full Stitch prompt, which must include:

1. **One-line description** with vibe/atmosphere keywords
2. **Design System block** (required) ‚Äî copied from `DESIGN.md` Section 6
3. **Page Structure** ‚Äî numbered list of sections/components

## Example

```markdown
---
page: achievements
---
A competitive, gamified achievements page with terminal aesthetics.

**DESIGN SYSTEM (REQUIRED):**
- Platform: Web, Desktop-first
- Theme: Dark, minimal, data-focused
- Background: Deep charcoal/near-black (#0f1419)
- Primary Accent: Teal/Cyan (#2dd4bf)
- Text Primary: White (#ffffff)
- Font: Clean sans-serif (Inter, SF Pro, or system default)
- Layout: Centered content, max-width container

**Page Structure:**
1. Header with title "Achievements" and navigation
2. Badge grid showing locked/unlocked states with icons
3. Progress section with milestone bars
4. Footer with links to other pages
```

## Validation Rules

Before completing an iteration, validate your baton:

- [ ] `page` frontmatter field exists and is a valid filename
- [ ] Prompt includes the design system block
- [ ] Prompt describes a page NOT already in `SITE.md` sitemap
- [ ] Prompt includes specific page structure details
</file>

<file path=".agent/skills/stitch-loop/resources/site-template.md">
# Site Template

Use these templates when setting up a new project for the build loop.

## SITE.md Template

```markdown
# Project Vision & Constitution

> **AGENT INSTRUCTION:** Read this file before every iteration. It serves as the project's "Long-Term Memory."

## 1. Core Identity
* **Project Name:** [Your project name]
* **Stitch Project ID:** [Your Stitch project ID]
* **Mission:** [What the site achieves]
* **Target Audience:** [Who uses this site]
* **Voice:** [Tone and personality descriptors]

## 2. Visual Language
*Reference these descriptors when prompting Stitch.*

* **The "Vibe" (Adjectives):**
    * *Primary:* [Main aesthetic keyword]
    * *Secondary:* [Supporting aesthetic]
    * *Tertiary:* [Additional flavor]

## 3. Architecture & File Structure
* **Root:** `site/public/`
* **Asset Flow:** Stitch generates to `queue/` ‚Üí Validate ‚Üí Move to `site/public/`
* **Navigation Strategy:** [How nav works]

## 4. Live Sitemap (Current State)
*Update this when a new page is successfully merged.*

* [x] `index.html` - [Description]
* [ ] `about.html` - [Description]

## 5. The Roadmap (Backlog)
*Pick the next task from here if available.*

### High Priority
- [ ] [Task description]
- [ ] [Task description]

### Medium Priority
- [ ] [Task description]

## 6. Creative Freedom Guidelines
*When the backlog is empty, follow these guidelines to innovate.*

1. **Stay On-Brand:** New pages must fit the established vibe
2. **Enhance the Core:** Support the site mission
3. **Naming Convention:** Use lowercase, descriptive filenames

### Ideas to Explore
*Pick one, build it, then REMOVE it from this list.*

- [ ] `stats.html` - [Description]
- [ ] `settings.html` - [Description]

## 7. Rules of Engagement
1. Do not recreate pages in Section 4
2. Always update `next-prompt.md` before completing
3. Consume ideas from Section 6 when you use them
```

## DESIGN.md Template

Generate this using the `design-md` skill from an existing Stitch screen, or create manually:

```markdown
# Design System: [Project Name]
**Project ID:** [Stitch Project ID]

## 1. Visual Theme & Atmosphere
[Describe mood, density, aesthetic philosophy]

## 2. Color Palette & Roles
- **[Descriptive Name]** (#hexcode) ‚Äì [Functional role]
- **[Descriptive Name]** (#hexcode) ‚Äì [Functional role]

## 3. Typography Rules
[Font family, weights, sizes, spacing]

## 4. Component Stylings
* **Buttons:** [Shape, color, behavior]
* **Cards:** [Corners, background, shadows]
* **Inputs:** [Stroke, background, focus states]

## 5. Layout Principles
[Whitespace strategy, margins, grid alignment]

## 6. Design System Notes for Stitch Generation
**Copy this block into every baton prompt:**

**DESIGN SYSTEM (REQUIRED):**
- Platform: [Web/Mobile], [Desktop/Mobile]-first
- Theme: [Dark/Light], [descriptors]
- Background: [Description] (#hex)
- Primary Accent: [Description] (#hex)
- Text Primary: [Description] (#hex)
- Font: [Description]
- Layout: [Description]
```
</file>

<file path=".agent/skills/stitch-loop/README.md">
# Stitch Build Loop Skill

Teaches agents to iteratively build websites using Stitch with an autonomous baton-passing loop pattern.

## Install

```bash
npx add-skill google-labs-code/stitch-skills --skill stitch-loop --global
```

## What It Does

Enables continuous, autonomous website development through a "baton" system:

1. Agent reads task from `next-prompt.md`
2. Generates page via Stitch MCP tools
3. Integrates into site structure
4. Writes next task to continue the loop

## Prerequisites

- Stitch MCP Server access
- A `DESIGN.md` file (generate with the `design-md` skill)
- A `SITE.md` file for project context

## Example Prompt

```text
Read my next-prompt.md and generate the page using Stitch, then prepare the next iteration.
```

## Skill Structure

```
stitch-loop/
‚îú‚îÄ‚îÄ SKILL.md              ‚Äî Core pattern instructions
‚îú‚îÄ‚îÄ README.md             ‚Äî This file
‚îú‚îÄ‚îÄ resources/
‚îÇ   ‚îú‚îÄ‚îÄ baton-schema.md   ‚Äî Baton file format spec
‚îÇ   ‚îî‚îÄ‚îÄ site-template.md  ‚Äî SITE.md/DESIGN.md templates
‚îî‚îÄ‚îÄ examples/
    ‚îú‚îÄ‚îÄ next-prompt.md    ‚Äî Example baton
    ‚îî‚îÄ‚îÄ SITE.md           ‚Äî Example site constitution
```

## Works With

- **`design-md` skill**: Generate `DESIGN.md` from existing Stitch screens
- **CI/CD**: GitHub Actions can trigger new iterations on push
- **Agent chains**: Dispatch to other agents (Jules, etc.)

## Learn More

See [SKILL.md](./SKILL.md) for complete instructions.
</file>

<file path=".agent/skills/stitch-loop/SKILL.md">
---
name: stitch-loop
description: Teaches agents to iteratively build websites using Stitch with an autonomous baton-passing loop pattern
allowed-tools:
  - "stitch*:*"
  - "chrome*:*"
  - "Read"
  - "Write"
  - "Bash"
---

# Stitch Build Loop

You are an **autonomous frontend builder** participating in an iterative site-building loop. Your goal is to generate a page using Stitch, integrate it into the site, and prepare instructions for the next iteration.

## Overview

The Build Loop pattern enables continuous, autonomous website development through a "baton" system. Each iteration:
1. Reads the current task from a baton file (`next-prompt.md`)
2. Generates a page using Stitch MCP tools
3. Integrates the page into the site structure
4. Writes the next task to the baton file for the next iteration

## Prerequisites

**Required:**
- Access to the Stitch MCP Server
- A Stitch project (existing or will be created)
- A `DESIGN.md` file (generate one using the `design-md` skill if needed)
- A `SITE.md` file documenting the site vision and roadmap

**Optional:**
- Chrome DevTools MCP Server ‚Äî enables visual verification of generated pages

## The Baton System

The `next-prompt.md` file acts as a relay baton between iterations:

```markdown
---
page: about
---
A page describing how jules.top tracking works.

**DESIGN SYSTEM (REQUIRED):**
[Copy from DESIGN.md Section 6]

**Page Structure:**
1. Header with navigation
2. Explanation of tracking methodology
3. Footer with links
```

**Critical rules:**
- The `page` field in YAML frontmatter determines the output filename
- The prompt content must include the design system block from `DESIGN.md`
- You MUST update this file before completing your work to continue the loop

## Execution Protocol

### Step 1: Read the Baton

Parse `next-prompt.md` to extract:
- **Page name** from the `page` frontmatter field
- **Prompt content** from the markdown body

### Step 2: Consult Context Files

Before generating, read these files:

| File | Purpose |
|------|---------|
| `SITE.md` | Site vision, **Stitch Project ID**, existing pages (sitemap), roadmap |
| `DESIGN.md` | Required visual style for Stitch prompts |

**Important checks:**
- Section 4 (Sitemap) ‚Äî Do NOT recreate pages that already exist
- Section 5 (Roadmap) ‚Äî Pick tasks from here if backlog exists
- Section 6 (Creative Freedom) ‚Äî Ideas for new pages if roadmap is empty

### Step 3: Generate with Stitch

Use the Stitch MCP tools to generate the page:

1. **Discover namespace**: Run `list_tools` to find the Stitch MCP prefix
2. **Get or create project**: 
   - If `stitch.json` exists, use the `projectId` from it
   - Otherwise, call `[prefix]:create_project` and save the ID to `stitch.json`
3. **Generate screen**: Call `[prefix]:generate_screen_from_text` with:
   - `projectId`: The project ID
   - `prompt`: The full prompt from the baton (including design system block)
   - `deviceType`: `DESKTOP` (or as specified)
4. **Retrieve assets**: Call `[prefix]:get_screen` to get:
   - `htmlCode.downloadUrl` ‚Äî Download and save as `queue/{page}.html`
   - `screenshot.downloadUrl` ‚Äî Download and save as `queue/{page}.png`

### Step 4: Integrate into Site

1. Move generated HTML from `queue/{page}.html` to `site/public/{page}.html`
2. Fix any asset paths to be relative to the public folder
3. Update navigation:
   - Find existing placeholder links (e.g., `href="#"`) and wire them to the new page
   - Add the new page to the global navigation if appropriate
4. Ensure consistent headers/footers across all pages

### Step 4.5: Visual Verification (Optional)

If the **Chrome DevTools MCP Server** is available, verify the generated page:

1. **Check availability**: Run `list_tools` to see if `chrome*` tools are present
2. **Start dev server**: Use Bash to start a local server (e.g., `npx serve site/public`)
3. **Navigate to page**: Call `[chrome_prefix]:navigate` to open `http://localhost:3000/{page}.html`
4. **Capture screenshot**: Call `[chrome_prefix]:screenshot` to capture the rendered page
5. **Visual comparison**: Compare against the Stitch screenshot (`queue/{page}.png`) for fidelity
6. **Stop server**: Terminate the dev server process

> **Note:** This step is optional. If Chrome DevTools MCP is not installed, skip to Step 5.

### Step 5: Update Site Documentation

Modify `SITE.md`:
- Add the new page to Section 4 (Sitemap) with `[x]`
- Remove any idea you consumed from Section 6 (Creative Freedom)
- Update Section 5 (Roadmap) if you completed a backlog item

### Step 6: Prepare the Next Baton (Critical)

**You MUST update `next-prompt.md` before completing.** This keeps the loop alive.

1. **Decide the next page**: 
   - Check `SITE.md` Section 5 (Roadmap) for pending items
   - If empty, pick from Section 6 (Creative Freedom)
   - Or invent something new that fits the site vision
2. **Write the baton** with proper YAML frontmatter:

```markdown
---
page: achievements
---
A competitive achievements page showing developer badges and milestones.

**DESIGN SYSTEM (REQUIRED):**
[Copy the entire design system block from DESIGN.md]

**Page Structure:**
1. Header with title and navigation
2. Badge grid showing unlocked/locked states
3. Progress bars for milestone tracking
```

## File Structure Reference

```
project/
‚îú‚îÄ‚îÄ next-prompt.md      # The baton ‚Äî current task
‚îú‚îÄ‚îÄ stitch.json         # Stitch project ID (persist this!)
‚îú‚îÄ‚îÄ DESIGN.md           # Visual design system (from design-md skill)
‚îú‚îÄ‚îÄ SITE.md             # Site vision, sitemap, roadmap
‚îú‚îÄ‚îÄ queue/              # Staging area for Stitch output
‚îÇ   ‚îú‚îÄ‚îÄ {page}.html
‚îÇ   ‚îî‚îÄ‚îÄ {page}.png
‚îî‚îÄ‚îÄ site/public/        # Production pages
    ‚îú‚îÄ‚îÄ index.html
    ‚îî‚îÄ‚îÄ {page}.html
```

## Orchestration Options

The loop can be driven by different orchestration layers:

| Method | How it works |
|--------|--------------|
| **CI/CD** | GitHub Actions triggers on `next-prompt.md` changes |
| **Human-in-loop** | Developer reviews each iteration before continuing |
| **Agent chains** | One agent dispatches to another (e.g., Jules API) |
| **Manual** | Developer runs the agent repeatedly with the same repo |

The skill is orchestration-agnostic ‚Äî focus on the pattern, not the trigger mechanism.

## Design System Integration

This skill works best with the `design-md` skill:

1. **First time setup**: Generate `DESIGN.md` using the `design-md` skill from an existing Stitch screen
2. **Every iteration**: Copy Section 6 ("Design System Notes for Stitch Generation") into your baton prompt
3. **Consistency**: All generated pages will share the same visual language

## Common Pitfalls

- ‚ùå Forgetting to update `next-prompt.md` (breaks the loop)
- ‚ùå Recreating a page that already exists in the sitemap
- ‚ùå Not including the design system block in the prompt
- ‚ùå Leaving placeholder links (`href="#"`) instead of wiring real navigation
- ‚ùå Forgetting to persist `stitch.json` after creating a new project

## Troubleshooting

| Issue | Solution |
|-------|----------|
| Stitch generation fails | Check that the prompt includes the design system block |
| Inconsistent styles | Ensure DESIGN.md is up-to-date and copied correctly |
| Loop stalls | Verify `next-prompt.md` was updated with valid frontmatter |
| Navigation broken | Check all internal links use correct relative paths |
</file>

<file path=".agent/skills/verifier/SKILL.md">
---
name: GSD Verifier
description: Validates implemented work against spec requirements with empirical evidence
---

# GSD Verifier Agent

<role>
You are a GSD verifier. You validate that implemented work achieves the stated phase goal through empirical evidence, not claims.

Your job: Verify must-haves, detect stubs, identify gaps, and produce VERIFICATION.md with structured findings.
</role>

---

## Core Principle

**Trust nothing. Verify everything.**

- SUMMARY.md says "completed" ‚Üí Verify it actually works
- Code exists ‚Üí Verify it's substantive, not a stub
- Function is called ‚Üí Verify the wiring actually connects
- Tests pass ‚Üí Verify they test the right things

---

## Verification Process

### Step 0: Check for Previous Verification

Before starting fresh, check if a previous VERIFICATION.md exists:

```powershell
Get-ChildItem ".gsd/phases/{N}/*-VERIFICATION.md" -ErrorAction SilentlyContinue
```

**If previous verification exists with gaps ‚Üí RE-VERIFICATION MODE:**
1. Parse previous VERIFICATION.md
2. Extract must-haves (truths, artifacts, key_links)
3. Extract gaps (items that failed)
4. Set `is_re_verification = true`
5. **Skip to Step 3** with optimization:
   - **Failed items:** Full 3-level verification
   - **Passed items:** Quick regression check only

**If no previous verification ‚Üí INITIAL MODE:**
Set `is_re_verification = false`, proceed with Step 1.

---

### Step 1: Load Context (Initial Mode Only)

Gather verification context:

```powershell
# Phase PLANs and SUMMARYs
Get-ChildItem ".gsd/phases/{N}/*-PLAN.md"
Get-ChildItem ".gsd/phases/{N}/*-SUMMARY.md"

# Phase goal from ROADMAP
Select-String -Path ".gsd/ROADMAP.md" -Pattern "Phase {N}"
```

Extract phase goal from ROADMAP.md. This is the outcome to verify, not the tasks.

---

### Step 2: Establish Must-Haves (Initial Mode Only)

**Option A: Must-haves in PLAN frontmatter**

```yaml
must_haves:
  truths:
    - "User can see existing messages"
    - "User can send a message"
  artifacts:
    - path: "src/components/Chat.tsx"
      provides: "Message list rendering"
  key_links:
    - from: "Chat.tsx"
      to: "api/chat"
      via: "fetch in useEffect"
```

**Option B: Derive from phase goal**

1. **State the goal:** Take phase goal from ROADMAP.md
2. **Derive truths:** "What must be TRUE for this goal?"
   - List 3-7 observable behaviors from user perspective
   - Each truth should be testable
3. **Derive artifacts:** "What must EXIST?"
   - Map truths to concrete files
   - Be specific: `src/components/Chat.tsx`, not "chat component"
4. **Derive key links:** "What must be CONNECTED?"
   - Identify critical wiring (component ‚Üí API ‚Üí DB)
   - These are where stubs hide

---

### Step 3: Verify Observable Truths

For each truth, determine if codebase enables it.

**Verification status:**
- ‚úì VERIFIED: All supporting artifacts pass all checks
- ‚úó FAILED: Artifacts missing, stub, or unwired
- ? UNCERTAIN: Can't verify programmatically (needs human)

For each truth:
1. Identify supporting artifacts
2. Check artifact status (Step 4)
3. Check wiring status (Step 5)
4. Determine truth status

---

### Step 4: Verify Artifacts (Three Levels)

For each required artifact, verify three levels:

#### Level 1: Existence
```powershell
Test-Path "src/components/Chat.tsx"
```
- File exists at expected path
- **If missing:** FAILED at Level 1

#### Level 2: Substantive
```powershell
Get-Content "src/components/Chat.tsx" | Select-String -Pattern "TODO|placeholder|stub"
```
- File contains real implementation
- Not a stub, placeholder, or minimal scaffold
- **If stub detected:** FAILED at Level 2

#### Level 3: Wired
- Imports are used, not just present
- Exports are consumed by other files
- Functions are called with correct arguments
- **If unwired:** FAILED at Level 3

---

### Step 5: Verify Key Links (Wiring)

For each key link, verify the connection exists:

**Pattern: Component ‚Üí API**
```powershell
# Check Chat.tsx calls /api/chat
Select-String -Path "src/components/Chat.tsx" -Pattern "fetch.*api/chat"
```

**Pattern: API ‚Üí Database**
```powershell
# Check route calls prisma
Select-String -Path "src/app/api/chat/route.ts" -Pattern "prisma\."
```

**Pattern: Form ‚Üí Handler**
```powershell
# Check onSubmit has implementation
Select-String -Path "src/components/Form.tsx" -Pattern "onSubmit" -Context 0,5
```

**Pattern: State ‚Üí Render**
```powershell
# Check state is used in JSX
Select-String -Path "src/components/Chat.tsx" -Pattern "messages\.map"
```

---

### Step 6: Check Requirements Coverage

If REQUIREMENTS.md exists:

```powershell
Select-String -Path ".gsd/REQUIREMENTS.md" -Pattern "Phase {N}"
```

For each requirement:
1. Identify which truths/artifacts support it
2. Determine status based on supporting infrastructure

**Requirement status:**
- ‚úì SATISFIED: All supporting truths verified
- ‚úó BLOCKED: Supporting truths failed
- ? NEEDS HUMAN: Can't verify programmatically

---

### Step 7: Scan for Anti-Patterns

Run anti-pattern detection on modified files:

```powershell
# TODO/FIXME comments
Select-String -Path "src/**/*.ts" -Pattern "TODO|FIXME|XXX|HACK"

# Placeholder content
Select-String -Path "src/**/*.tsx" -Pattern "placeholder|coming soon" 

# Empty implementations
Select-String -Path "src/**/*.ts" -Pattern "return null|return \{\}|return \[\]"

# Console.log only
Select-String -Path "src/**/*.ts" -Pattern "console\.log" -Context 2
```

**Categorize findings:**
- üõë Blocker: Prevents goal achievement
- ‚ö†Ô∏è Warning: Indicates incomplete work
- ‚ÑπÔ∏è Info: Notable but not problematic

---

### Step 8: Identify Human Verification Needs

Some things can't be verified programmatically:

**Always needs human:**
- Visual appearance (does it look right?)
- User flow completion
- Real-time behavior (WebSocket, SSE)
- External service integration
- Performance feel
- Error message clarity

**Format:**
```markdown
### 1. {Test Name}
**Test:** {What to do}
**Expected:** {What should happen}
**Why human:** {Why can't verify programmatically}
```

---

### Step 9: Determine Overall Status

**Status: passed**
- All truths VERIFIED
- All artifacts pass levels 1-3
- All key links WIRED
- No blocker anti-patterns

**Status: gaps_found**
- One or more truths FAILED
- OR artifacts MISSING/STUB
- OR key links NOT_WIRED
- OR blocker anti-patterns found

**Status: human_needed**
- All automated checks pass
- BUT items flagged for human verification

**Calculate score:**
```
score = verified_truths / total_truths
```

---

### Step 10: Structure Gap Output

When gaps found, structure for `/plan --gaps`:

```yaml
---
phase: {N}
verified: {timestamp}
status: gaps_found
score: {N}/{M} must-haves verified
gaps:
  - truth: "User can see existing messages"
    status: failed
    reason: "Chat.tsx doesn't fetch from API"
    artifacts:
      - path: "src/components/Chat.tsx"
        issue: "No useEffect with fetch call"
    missing:
      - "API call in useEffect to /api/chat"
      - "State for storing fetched messages"
      - "Render messages array in JSX"
---
```

---

## Stub Detection Patterns

### Universal Stub Patterns
```powershell
# Comment-based stubs
Select-String -Pattern "TODO|FIXME|XXX|HACK|PLACEHOLDER"

# Placeholder text
Select-String -Pattern "placeholder|lorem ipsum|coming soon" 

# Empty implementations
Select-String -Pattern "return null|return undefined|return \{\}|return \[\]"
```

### React Component Stubs
```javascript
// RED FLAGS:
return <div>Component</div>
return <div>Placeholder</div>
return <div>{/* TODO */}</div>
return null
return <></>

// Empty handlers:
onClick={() => {}}
onChange={() => console.log('clicked')}
onSubmit={(e) => e.preventDefault()}  // Only prevents default
```

### API Route Stubs
```typescript
// RED FLAGS:
export async function POST() {
  return Response.json({ message: "Not implemented" });
}

export async function GET() {
  return Response.json([]);  // Empty array, no DB query
}

// Console log only:
export async function POST(req) {
  console.log(await req.json());
  return Response.json({ ok: true });
}
```

### Wiring Red Flags
```typescript
// Fetch exists but response ignored:
fetch('/api/messages')  // No await, no .then

// Query exists but result not returned:
await prisma.message.findMany()
return Response.json({ ok: true })  // Returns static, not query

// Handler only prevents default:
onSubmit={(e) => e.preventDefault()}

// State exists but not rendered:
const [messages, setMessages] = useState([])
return <div>No messages</div>  // Always shows static
```

---

## VERIFICATION.md Format

```markdown
---
phase: {N}
verified: {timestamp}
status: {passed | gaps_found | human_needed}
score: {N}/{M} must-haves verified
is_re_verification: {true | false}
gaps: [...]  # If gaps_found
---

# Phase {N} Verification

## Must-Haves

### Truths
| Truth | Status | Evidence |
|-------|--------|----------|
| {truth 1} | ‚úì VERIFIED | {how verified} |
| {truth 2} | ‚úó FAILED | {what's missing} |

### Artifacts
| Path | Exists | Substantive | Wired |
|------|--------|-------------|-------|
| src/components/Chat.tsx | ‚úì | ‚úì | ‚úó |

### Key Links
| From | To | Via | Status |
|------|-----|-----|--------|
| Chat.tsx | api/chat | fetch | ‚úó NOT_WIRED |

## Anti-Patterns Found
- üõë {blocker}
- ‚ö†Ô∏è {warning}

## Human Verification Needed
### 1. Visual Review
**Test:** Open http://localhost:3000/chat
**Expected:** Message list renders with real data
**Why human:** Visual layout verification

## Gaps (if any)
{Structured gap analysis for planner}

## Verdict
{Status explanation}
```

---

## Success Criteria

- [ ] Previous VERIFICATION.md checked
- [ ] Must-haves established (from frontmatter or derived)
- [ ] All truths verified with status and evidence
- [ ] All artifacts checked at 3 levels (exists, substantive, wired)
- [ ] All key links verified
- [ ] Anti-patterns scanned and categorized
- [ ] Human verification items identified
- [ ] Overall status determined
- [ ] Gaps structured in YAML (if gaps_found)
- [ ] VERIFICATION.md created
- [ ] Results returned to orchestrator
</file>

<file path=".agent/workflows/add-phase.md">
---
description: Add a new phase to the end of the roadmap
argument-hint: "<phase-name>"
---

# /add-phase Workflow

<objective>
Add a new phase to the end of the current roadmap.
</objective>

<process>

## 1. Validate Roadmap Exists

```powershell
if (-not (Test-Path ".gsd/ROADMAP.md")) {
    Write-Error "ROADMAP.md required. Run /new-milestone first."
}
```

---

## 2. Determine Next Phase Number

```powershell
# Count existing phases
$phases = Select-String -Path ".gsd/ROADMAP.md" -Pattern "### Phase \d+"
$nextPhase = $phases.Count + 1
```

---

## 3. Gather Phase Information

Ask for:
- **Name** ‚Äî Phase title
- **Objective** ‚Äî What this phase achieves
- **Depends on** ‚Äî Previous phases (usually N-1)

---

## 4. Add to ROADMAP.md

Append:
```markdown
---

### Phase {N}: {name}
**Status**: ‚¨ú Not Started
**Objective**: {objective}
**Depends on**: Phase {N-1}

**Tasks**:
- [ ] TBD (run /plan {N} to create)

**Verification**:
- TBD
```

---

## 5. Update STATE.md

Note phase added.

---

## 6. Commit

```powershell
git add .gsd/ROADMAP.md .gsd/STATE.md
git commit -m "docs: add phase {N} - {name}"
```

---

## 7. Offer Next Steps

```
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
 GSD ‚ñ∫ PHASE ADDED ‚úì
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

Phase {N}: {name}

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

‚ñ∂ NEXT

/plan {N} ‚Äî Create execution plans for this phase

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
```

</process>
</file>

<file path=".agent/workflows/add-todo.md">
---
description: Capture a todo item for later
argument-hint: "<description> [--priority high|medium|low]"
---

# /add-todo Workflow

<objective>
Quickly capture an idea, task, or issue without interrupting current work flow.
</objective>

<context>
**Item:** $ARGUMENTS (the todo description)

**Flags:**
- `--priority high|medium|low` ‚Äî Set priority (default: medium)

**Output:**
- `.gsd/TODO.md` ‚Äî Accumulated todo items
</context>

<process>

## 1. Parse Arguments

Extract:
- Todo description
- Priority (default: medium)

---

## 2. Ensure TODO.md Exists

```powershell
if (-not (Test-Path ".gsd/TODO.md")) {
    # Create with header
}
```

---

## 3. Add Todo Item

Append to `.gsd/TODO.md`:

```markdown
- [ ] {description} `{priority}` ‚Äî {date}
```

---

## 4. Confirm

```
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
 GSD ‚ñ∫ TODO ADDED ‚úì
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

{description}
Priority: {priority}

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

/check-todos ‚Äî see all pending items

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
```

</process>
</file>

<file path=".agent/workflows/audit-milestone.md">
---
description: Audit a milestone for quality and completeness
argument-hint: "[milestone-name]"
---

# /audit-milestone Workflow

<objective>
Review a completed (or in-progress) milestone for quality, completeness, and lessons learned.
</objective>

<process>

## 1. Load Milestone Context

If milestone name provided, load from archive:
```powershell
Get-Content ".gsd/milestones/{name}-SUMMARY.md"
```

If no name, audit current milestone from ROADMAP.md.

---

## 2. Check Must-Haves Verification

For each must-have in the milestone:
- Was it verified with empirical evidence?
- Is the evidence still valid?
- Any regressions since completion?

---

## 3. Review Technical Debt

Check TODO.md and DECISIONS.md for:
- Deferred items during this milestone
- Technical debt acknowledged
- Items that should be addressed

---

## 4. Analyze Phase Quality

For each phase:
- Review VERIFICATION.md
- Check for gap closures (were there many?)
- Note recurring issues

---

## 5. Generate Audit Report

```markdown
# Milestone Audit: {name}

**Audited:** {date}

## Summary
| Metric | Value |
|--------|-------|
| Phases | {N} |
| Gap closures | {M} |
| Technical debt items | {K} |

## Must-Haves Status
| Requirement | Verified | Evidence |
|-------------|----------|----------|
| {req 1} | ‚úÖ | {link} |
| {req 2} | ‚úÖ | {link} |

## Concerns
- {concern 1}
- {concern 2}

## Recommendations
1. {recommendation 1}
2. {recommendation 2}

## Technical Debt to Address
- [ ] {item 1}
- [ ] {item 2}
```

---

## 6. Offer Actions

```
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
 GSD ‚ñ∫ AUDIT COMPLETE
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

Milestone: {name}
Health: {GOOD | CONCERNS | NEEDS ATTENTION}

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

‚ñ∂ ACTIONS

/plan-milestone-gaps ‚Äî Create plans to address gaps
/add-todo ‚Äî Capture debt items for later

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
```

</process>
</file>

<file path=".agent/workflows/check-todos.md">
---
description: List all pending todo items
argument-hint: "[--all] [--priority high|medium|low]"
---

# /check-todos Workflow

<objective>
Display pending todo items, optionally filtered by priority or status.
</objective>

<context>
**Flags:**
- `--all` ‚Äî Show completed items too
- `--priority high|medium|low` ‚Äî Filter by priority

**Input:**
- `.gsd/TODO.md` ‚Äî Todo items
</context>

<process>

## 1. Load TODO.md

```powershell
if (-not (Test-Path ".gsd/TODO.md")) {
    Write-Output "No todos found. Use /add-todo to create one."
    exit
}

Get-Content ".gsd/TODO.md"
```

---

## 2. Parse and Filter

Count items by status:
- `- [ ]` = pending
- `- [x]` = complete

Filter by priority if flag provided.

---

## 3. Display

```
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
 GSD ‚ñ∫ TODOS
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

PENDING ({N} items)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
üî¥ {high priority item}
üü° {medium priority item}
üü¢ {low priority item}

{If --all flag:}
COMPLETED ({M} items)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚úÖ {completed item}

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

/add-todo <item> ‚Äî add new item

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
```

</process>

<priority_indicators>
| Priority | Indicator |
|----------|-----------|
| high | üî¥ |
| medium | üü° |
| low | üü¢ |
| done | ‚úÖ |
</priority_indicators>
</file>

<file path=".agent/workflows/complete-milestone.md">
---
description: Mark current milestone as complete and archive
---

# /complete-milestone Workflow

<objective>
Finalize the current milestone, archive documentation, and prepare for next milestone.
</objective>

<process>

## 1. Verify All Phases Complete

**PowerShell:**
```powershell
# Check ROADMAP.md for incomplete phases
Select-String -Path ".gsd/ROADMAP.md" -Pattern "Status.*Not Started|Status.*In Progress"
```

**Bash:**
```bash
# Check ROADMAP.md for incomplete phases
grep -E "Status.*Not Started|Status.*In Progress" ".gsd/ROADMAP.md"
```

**If incomplete phases found:**
```
‚ö†Ô∏è Cannot complete milestone ‚Äî {N} phases incomplete

Run /progress to see status.
```

---

## 2. Run Final Verification

Verify all must-haves from ROADMAP.md:
- Run verification commands
- Capture evidence
- Create VERIFICATION.md if not exists

---

## 3. Generate Milestone Summary

Create `.gsd/milestones/{name}-SUMMARY.md`:

```markdown
# Milestone: {name}

## Completed: {date}

## Deliverables
- ‚úÖ {must-have 1}
- ‚úÖ {must-have 2}

## Phases Completed
1. Phase 1: {name} ‚Äî {date}
2. Phase 2: {name} ‚Äî {date}
...

## Metrics
- Total commits: {N}
- Files changed: {M}
- Duration: {days}

## Lessons Learned
{Auto-extract from DECISIONS.md and JOURNAL.md}
```

---

## 4. Archive Current State

**PowerShell:**
```powershell
# Create milestone archive
New-Item -ItemType Directory -Force ".gsd/milestones/{name}"

# Move phase-specific files
Move-Item ".gsd/phases/*" ".gsd/milestones/{name}/"
```

**Bash:**
```bash
# Create milestone archive
mkdir -p ".gsd/milestones/{name}"

# Move phase-specific files
mv .gsd/phases/* ".gsd/milestones/{name}/"
```

---

## 5. Reset for Next Milestone

Clear ROADMAP.md phases section (keep header).
Update STATE.md to show milestone complete.

---

## 6. Commit and Tag

```bash
git add -A
git commit -m "docs: complete milestone {name}"
git tag -a "{name}" -m "Milestone {name} complete"
```

---

## 7. Celebrate

```
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
 GSD ‚ñ∫ MILESTONE COMPLETE üéâ
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

{name}

Phases: {N} completed
Tag: {name}

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

‚ñ∂ NEXT

/new-milestone ‚Äî Start next milestone
/audit-milestone {name} ‚Äî Review this milestone

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
```

</process>
</file>

<file path=".agent/workflows/debug.md">
---
description: Systematic debugging with persistent state
argument-hint: "[description of issue]"
---

# /debug Workflow

<role>
You are a GSD debugger orchestrator. You diagnose and fix issues systematically, leveraging fresh context to see what polluted contexts miss.
</role>

<objective>
Systematically diagnose an issue using hypothesis-driven debugging, with persistent state to prevent circular attempts.
</objective>

<context>
**Issue:** $ARGUMENTS (description of the problem to debug)

**Skill reference:** `.agent/skills/debugger/SKILL.md`
</context>

<process>

## 1. Initialize Debug Session

Check for existing debug state:
**PowerShell:**
```powershell
Test-Path ".gsd/DEBUG.md"
```

**Bash:**
```bash
test -f ".gsd/DEBUG.md"
```

If exists, load previous attempts. If not, create new session.

Display banner:
```
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
 GSD ‚ñ∫ DEBUG SESSION
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

Issue: {description}
```

---

## 2. Document Symptom

Create/update `.gsd/DEBUG.md`:

```markdown
# Debug Session: {Issue ID}

## Symptom
{Exact description of the problem}

**When:** {When does it occur?}
**Expected:** {What should happen?}
**Actual:** {What actually happens?}
```

---

## 3. Gather Evidence

Collect data BEFORE forming hypotheses:

**PowerShell:**
```powershell
# Get error details
{relevant commands to capture error info}

# Check logs
Get-Content logs/error.log -Tail 50

# Check environment
{relevant environment checks}
```

**Bash:**
```bash
# Get error details
{relevant commands to capture error info}

# Check logs
tail -50 logs/error.log

# Check environment
{relevant environment checks}
```

Document evidence in DEBUG.md.

---

## 4. Form Hypotheses

Based on evidence, list possible causes:

```markdown
## Hypotheses

| # | Hypothesis | Likelihood | Status |
|---|------------|------------|--------|
| 1 | {cause 1} | 80% | UNTESTED |
| 2 | {cause 2} | 15% | UNTESTED |
| 3 | {cause 3} | 5% | UNTESTED |
```

---

## 5. Test Hypotheses

Test highest likelihood first:

```markdown
## Attempts

### Attempt 1
**Testing:** H1 ‚Äî {hypothesis}
**Action:** {what you did to test}
**Result:** {outcome}
**Conclusion:** {CONFIRMED | ELIMINATED | INCONCLUSIVE}
```

---

## 6. Apply Fix (If Root Cause Found)

When root cause confirmed:

1. Implement fix
2. Run original failing scenario
3. Verify PASSES
4. Check for regressions

Update DEBUG.md:
```markdown
## Resolution

**Root Cause:** {what was actually wrong}
**Fix:** {what was changed}
**Verified:** {how fix was verified}
**Regression Check:** {what else was tested}
```

---

## 7. Handle 3-Strike Rule

If 3 attempts fail on SAME approach:

```
‚ö†Ô∏è 3 FAILURES ON SAME APPROACH

Action: STOP and reassess

Options:
1. Try fundamentally DIFFERENT approach
2. /pause for fresh session context
3. Ask user for additional information
```

Update DEBUG.md and recommend next steps.

---

## 8. Commit Resolution

If fixed:
```bash
git add -A
git commit -m "fix: {brief description of fix}"
```

Update STATE.md with resolution.

</process>

<offer_next>

**If Resolved:**
```
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
 GSD ‚ñ∫ BUG FIXED ‚úì
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

Root cause: {what was wrong}
Fix: {what was done}

Committed: {hash}

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
```

**If Stuck After 3 Attempts:**
```
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
 GSD ‚ñ∫ DEBUG PAUSED ‚è∏
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

3 attempts exhausted on current approach.
State saved to .gsd/DEBUG.md

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

Options:
‚Ä¢ /debug {issue} ‚Äî try different approach
‚Ä¢ /pause ‚Äî save state for fresh session
‚Ä¢ Provide more context about the issue

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
```

</offer_next>

<related>
## Related

### Workflows
| Command | Relationship |
|---------|--------------|
| `/pause` | Use after 3 failed attempts |
| `/resume` | Start fresh with documented state |
| `/verify` | Re-verify after fixing issues |

### Skills
| Skill | Purpose |
|-------|---------|
| `debugger` | Detailed debugging methodology |
| `context-health-monitor` | 3-strike rule |
</related>
</file>

<file path=".agent/workflows/discuss-phase.md">
---
description: Discuss a phase before planning (clarify scope and approach)
argument-hint: "<phase-number>"
---

# /discuss-phase Workflow

<objective>
Interactive discussion about a phase to clarify scope, approach, and concerns before creating plans.
</objective>

<context>
Run BEFORE `/plan` when:
- Phase scope is unclear
- Multiple implementation approaches exist
- Trade-offs need user input
- Dependencies are complex
</context>

<process>

## 1. Load Phase Context

Read from ROADMAP.md:
- Phase objective
- Dependencies
- Current status

---

## 2. Analyze Requirements

From phase objective, extract:
- What needs to be built
- What constraints exist
- What decisions need to be made

---

## 3. Present Discussion Points

```
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
 GSD ‚ñ∫ DISCUSS PHASE {N}
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

Phase: {name}
Objective: {objective}

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

TOPICS TO DISCUSS

1. SCOPE CLARIFICATION
   - {question about scope}
   - {question about boundaries}

2. IMPLEMENTATION APPROACH
   Option A: {approach}
   Option B: {approach}
   Which do you prefer and why?

3. DEPENDENCIES
   - Requires: {what from previous phases}
   - Missing: {any gaps in earlier work}

4. CONCERNS
   - {potential issue}
   - {risk to flag}

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
```

---

## 4. Gather User Input

Listen for:
- Scope decisions
- Approach preferences
- Constraints not in spec
- Priority clarifications

---

## 5. Document Decisions

Update `.gsd/DECISIONS.md`:

```markdown
## Phase {N} Decisions

**Date:** {date}

### Scope
- {decision about scope}

### Approach
- Chose: {approach}
- Reason: {rationale}

### Constraints
- {constraint identified}
```

---

## 6. Offer Next Steps

```
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

‚úì Discussion documented in DECISIONS.md

‚ñ∂ NEXT

/plan {N} ‚Äî Create execution plans with this context
/research-phase {N} ‚Äî Deep dive on technical options

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
```

</process>
</file>

<file path=".agent/workflows/execute.md">
---
description: The Engineer ‚Äî Execute a specific phase with focused context
argument-hint: "<phase-number> [--gaps-only]"
---

# /execute Workflow

<role>
You are a GSD executor orchestrator. You manage wave-based parallel execution of phase plans.

**Core responsibilities:**
- Validate phase exists and has plans
- Discover and group plans by execution wave
- Spawn focused execution for each plan
- Verify phase goal after all plans complete
- Update roadmap and state on completion
</role>

<objective>
Execute all plans in a phase using wave-based parallel execution.

Orchestrator stays lean: discover plans, analyze dependencies, group into waves, execute sequentially within waves, verify against phase goal.

**Context budget:** ~15% orchestrator, fresh context per plan execution.
</objective>

<context>
**Phase:** $ARGUMENTS (required - phase number to execute)

**Flags:**
- `--gaps-only` ‚Äî Execute only gap closure plans (created by `/verify` when issues found)

**Required files:**
- `.gsd/ROADMAP.md` ‚Äî Phase definitions
- `.gsd/STATE.md` ‚Äî Current position
- `.gsd/phases/{phase}/` ‚Äî Phase directory with PLAN.md files
</context>

<process>

## 1. Validate Environment

**PowerShell:**
```powershell
Test-Path ".gsd/ROADMAP.md"
Test-Path ".gsd/STATE.md"
```

**Bash:**
```bash
test -f ".gsd/ROADMAP.md"
test -f ".gsd/STATE.md"
```

**If not found:** Error ‚Äî user should run `/plan` first.

---

## 2. Validate Phase Exists

**PowerShell:**
```powershell
# Check phase exists in roadmap
Select-String -Path ".gsd/ROADMAP.md" -Pattern "Phase $PHASE:"
```

**Bash:**
```bash
# Check phase exists in roadmap
grep "Phase $PHASE:" ".gsd/ROADMAP.md"
```

**If not found:** Error with available phases from ROADMAP.md.

---

## 3. Ensure Phase Directory Exists

**PowerShell:**
```powershell
$PHASE_DIR = ".gsd/phases/$PHASE"
if (-not (Test-Path $PHASE_DIR)) {
    New-Item -ItemType Directory -Path $PHASE_DIR
}
```

**Bash:**
```bash
PHASE_DIR=".gsd/phases/$PHASE"
mkdir -p "$PHASE_DIR"
```

---

## 4. Discover Plans

**PowerShell:**
```powershell
Get-ChildItem "$PHASE_DIR/*-PLAN.md"
```

**Bash:**
```bash
ls "$PHASE_DIR"/*-PLAN.md 2>/dev/null
```

**Check for existing summaries** (completed plans):

**PowerShell:**
```powershell
Get-ChildItem "$PHASE_DIR/*-SUMMARY.md"
```

**Bash:**
```bash
ls "$PHASE_DIR"/*-SUMMARY.md 2>/dev/null
```

**Build list of incomplete plans** (PLAN without matching SUMMARY).

**If `--gaps-only`:** Filter to only plans with `gap_closure: true` in frontmatter.

**If no incomplete plans found:** Phase already complete, skip to step 8.

---

## 5. Group Plans by Wave

Read `wave` field from each plan's frontmatter:

```yaml
---
phase: 1
plan: 2
wave: 1
---
```

**Group plans by wave number.** Lower waves execute first.

Display wave structure:
```
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
 GSD ‚ñ∫ EXECUTING PHASE {N}
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

Wave 1: {plan-1}, {plan-2}
Wave 2: {plan-3}

{X} plans across {Y} waves
```

---

## 6. Execute Waves

For each wave in order:

### 6a. Execute Plans in Wave
For each plan in the current wave:

1. **Load plan context** ‚Äî Read only the PLAN.md file
2. **Execute tasks** ‚Äî Follow `<task>` blocks in order
3. **Verify each task** ‚Äî Run `<verify>` commands
4. **Commit per task:**
   ```bash
   git add -A
   git commit -m "feat(phase-{N}): {task-name}"
   ```
5. **Create SUMMARY.md** ‚Äî Document what was done

### 6b. Verify Wave Complete
Check all plans in wave have SUMMARY.md files.

### 6c. Proceed to Next Wave
Only after current wave fully completes.

---

## 7. Verify Phase Goal

After all waves complete:

1. **Read phase goal** from ROADMAP.md
2. **Check must-haves** against actual codebase (not SUMMARY claims)
3. **Run verification commands** specified in phase

**Create VERIFICATION.md:**
```markdown
## Phase {N} Verification

### Must-Haves
- [x] Must-have 1 ‚Äî VERIFIED (evidence: ...)
- [ ] Must-have 2 ‚Äî FAILED (reason: ...)

### Verdict: PASS / FAIL
```

**Route by verdict:**
- `PASS` ‚Üí Continue to step 8
- `FAIL` ‚Üí Create gap closure plans, offer `/execute {N} --gaps-only`

---

## 8. Update Roadmap and State

**Update ROADMAP.md:**
```markdown
### Phase {N}: {Name}
**Status**: ‚úÖ Complete
```

**Update STATE.md:**
```markdown
## Current Position
- **Phase**: {N} (completed)
- **Task**: All tasks complete
- **Status**: Verified

## Last Session Summary
Phase {N} executed successfully. {X} plans, {Y} tasks completed.

## Next Steps
1. Proceed to Phase {N+1}
```

---

## 9. Commit Phase Completion

```bash
git add .gsd/ROADMAP.md .gsd/STATE.md
git commit -m "docs(phase-{N}): complete {phase-name}"
```

---

## 10. Offer Next Steps

</process>

<offer_next>
Output based on status:

**Route A: Phase complete, more phases remain**

```
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
 GSD ‚ñ∫ PHASE {N} COMPLETE ‚úì
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

{X} plans executed
Goal verified ‚úì

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

‚ñ∂ Next Up
Phase {N+1}: {Name}

/plan {N+1}  ‚Äî create execution plans
/execute {N+1} ‚Äî execute directly (if plans exist)

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
```

**Route B: All phases complete**

```
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
 GSD ‚ñ∫ MILESTONE COMPLETE üéâ
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

All phases completed and verified.

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
```

**Route C: Gaps found**

```
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
 GSD ‚ñ∫ PHASE {N} GAPS FOUND ‚ö†
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

{X}/{Y} must-haves verified
Gap closure plans created.

/execute {N} --gaps-only ‚Äî execute fix plans

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
```
</offer_next>

<context_hygiene>
**After 3 failed debugging attempts:**
1. Stop current approach
2. Document to `.gsd/STATE.md` what was tried
3. Recommend `/pause` for fresh session
</context_hygiene>

<related>
## Related

### Workflows
| Command | Relationship |
|---------|--------------|
| `/plan` | Creates PLAN.md files that /execute runs |
| `/verify` | Validates work after /execute completes |
| `/debug` | Use when tasks fail verification |
| `/pause` | Use after 3 debugging failures |

### Skills
| Skill | Purpose |
|-------|---------|
| `executor` | Detailed execution protocol |
| `context-health-monitor` | 3-strike rule enforcement |
| `empirical-validation` | Verification requirements |
</related>
</file>

<file path=".agent/workflows/help.md">
---
description: Show all available GSD commands
---

# /help Workflow

<objective>
Display all available GSD commands with descriptions and usage hints.
</objective>

<process>

**First, read and display the version:**

**PowerShell:**
```powershell
$version = Get-Content "VERSION" -ErrorAction SilentlyContinue
if (-not $version) { $version = "unknown" }
```

**Bash:**
```bash
version=$(cat VERSION 2>/dev/null || echo "unknown")
```

**Then display help with version in header:**

```
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
 GSD ‚ñ∫ HELP (v{version})
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

CORE WORKFLOW
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
/map              Analyze codebase ‚Üí ARCHITECTURE.md
/plan [N]         Create PLAN.md files for phase N
/execute [N]      Wave-based execution with atomic commits
/verify [N]       Must-haves validation with proof
/debug [desc]     Systematic debugging (3-strike rule)

PROJECT SETUP
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
/new-project      Deep questioning ‚Üí SPEC.md
/new-milestone    Create milestone with phases
/complete-milestone   Archive completed milestone
/audit-milestone  Review milestone quality

PHASE MANAGEMENT
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
/add-phase        Add phase to end of roadmap
/insert-phase     Insert phase (renumbers subsequent)
/remove-phase     Remove phase (with safety checks)
/discuss-phase    Clarify scope before planning
/research-phase   Deep technical research
/list-phase-assumptions   Surface planning assumptions
/plan-milestone-gaps      Create gap closure plans

NAVIGATION & STATE
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
/progress         Show current position in roadmap
/pause            Save state for session handoff
/resume           Restore from last session
/add-todo         Quick capture idea
/check-todos      List pending items

UTILITIES
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
/help             Show this help

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

QUICK START
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
1. /new-project      ‚Üí Initialize with deep questioning
2. /plan 1           ‚Üí Create Phase 1 plans
3. /execute 1        ‚Üí Implement Phase 1
4. /verify 1         ‚Üí Confirm it works
5. Repeat

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

CORE RULES
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
üîí Planning Lock     No code until SPEC.md is FINALIZED
üíæ State Persistence Update STATE.md after every task
üßπ Context Hygiene   3 failures ‚Üí state dump ‚Üí fresh session
‚úÖ Empirical Valid.  Proof required, no "it should work"

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

üìö Docs: GSD-STYLE.md, .gsd/examples/

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
```

</process>
</file>

<file path=".agent/workflows/insert-phase.md">
---
description: Insert a phase between existing phases (renumbers subsequent)
argument-hint: "<position> <phase-name>"
---

# /insert-phase Workflow

<objective>
Insert a new phase at a specific position, renumbering all subsequent phases.
</objective>

<process>

## 1. Parse Arguments

Extract:
- **Position** ‚Äî Where to insert (e.g., 2 inserts before current Phase 2)
- **Name** ‚Äî Phase title

---

## 2. Validate Position

**PowerShell:**
```powershell
$totalPhases = (Select-String -Path ".gsd/ROADMAP.md" -Pattern "### Phase \d+").Count
if ($position -lt 1 -or $position -gt $totalPhases + 1) {
    Write-Error "Invalid position. Valid: 1-$($totalPhases + 1)"
}
```

**Bash:**
```bash
total_phases=$(grep -c "### Phase [0-9]" ".gsd/ROADMAP.md")
if [ "$position" -lt 1 ] || [ "$position" -gt $((total_phases + 1)) ]; then
    echo "Error: Invalid position. Valid: 1-$((total_phases + 1))" >&2
fi
```

---

## 3. Gather Phase Information

Ask for:
- **Objective** ‚Äî What this phase achieves
- **Dependencies** ‚Äî What it needs from earlier phases

---

## 4. Renumber Existing Phases

For phases >= position, increment phase number by 1.

**Also update:**
- Phase directory names (`.gsd/phases/{N}/`)
- References in PLAN.md files
- Dependencies in ROADMAP.md

---

## 5. Insert New Phase

Add at position with correct numbering.

---

## 6. Update STATE.md

If currently in a phase >= position, update position reference.

---

## 7. Commit

```bash
git add -A
git commit -m "docs: insert phase {N} - {name} (renumbered {M} phases)"
```

---

## 8. Display Result

```
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
 GSD ‚ñ∫ PHASE INSERTED ‚úì
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

Inserted: Phase {N}: {name}
Renumbered: Phases {N+1} through {M}

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

‚ñ∂ NEXT

/plan {N} ‚Äî Create plans for new phase
/progress ‚Äî See updated roadmap

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
```

</process>

<warning>
Phase insertion can be disruptive. Consider:
- In-progress phases may have commits referencing old numbers
- Existing plans reference phase numbers
- Use sparingly and early in milestone lifecycle
</warning>
</file>

<file path=".agent/workflows/list-phase-assumptions.md">
---
description: List assumptions made during phase planning
argument-hint: "<phase-number>"
---

# /list-phase-assumptions Workflow

<objective>
Surface and document assumptions made during phase planning that should be validated.
</objective>

<process>

## 1. Load Phase Plans

```powershell
Get-ChildItem ".gsd/phases/{N}/*-PLAN.md"
```

---

## 2. Extract Assumptions

Scan plans for:
- Technology choices without justification
- Implied dependencies
- Expected behaviors not verified
- Time estimates
- Scope boundaries

---

## 3. Categorize Assumptions

| Category | Risk Level |
|----------|------------|
| Technical | API exists, library works, syntax correct |
| Integration | Services compatible, auth works |
| Scope | Feature boundaries, what's excluded |
| Performance | Will handle load, fast enough |
| Timeline | Estimates accurate |

---

## 4. Display Assumptions

```
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
 GSD ‚ñ∫ PHASE {N} ASSUMPTIONS
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

TECHNICAL
üü° {assumption 1} ‚Äî Validate before execution
üü¢ {assumption 2} ‚Äî Low risk

INTEGRATION
üî¥ {assumption 3} ‚Äî High risk, verify first

SCOPE
üü° {assumption 4} ‚Äî Confirm with user

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

‚ñ∂ ACTIONS

‚Ä¢ Validate high-risk assumptions before /execute
‚Ä¢ Add verified assumptions to RESEARCH.md
‚Ä¢ Flag for user review if scope-related

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
```

---

## 5. Offer Validation

Ask if user wants to:
- Validate specific assumptions now
- Add to TODO.md for later
- Accept and proceed

</process>
</file>

<file path=".agent/workflows/map.md">
---
description: The Architect ‚Äî Analyze codebase and update ARCHITECTURE.md and STACK.md
---

# /map Workflow

<role>
You are a GSD codebase mapper. You analyze existing codebases to understand structure, patterns, and technical debt.

**Core responsibilities:**
- Scan project structure and identify components
- Analyze dependencies and versions
- Map data flow and integration points
- Identify technical debt and patterns
- Document findings for planning context
</role>

<objective>
Analyze the existing codebase and produce documentation that enables informed planning.

This workflow should be run BEFORE `/plan` on brownfield projects to give the planner full context.
</objective>

<context>
**No arguments required.** Operates on current project directory.

**Outputs:**
- `.gsd/ARCHITECTURE.md` ‚Äî System design documentation
- `.gsd/STACK.md` ‚Äî Technology inventory
</context>

<process>

## 1. Validate Project

Check this is a valid project:

**PowerShell:**
```powershell
# Look for common project indicators
$indicators = @(
    "package.json", "requirements.txt", "Cargo.toml", 
    "go.mod", "pom.xml", "*.csproj", "Gemfile"
)
```

**Bash:**
```bash
# Look for common project indicators
indicators=("package.json" "requirements.txt" "Cargo.toml" 
    "go.mod" "pom.xml" "*.csproj" "Gemfile")
```

Display banner:
```
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
 GSD ‚ñ∫ MAPPING CODEBASE
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
```

---

## 2. Analyze Project Structure

### 2a. Directory Analysis

**PowerShell:**
```powershell
Get-ChildItem -Recurse -Directory | 
    Where-Object { $_.Name -notmatch "node_modules|\.git|__pycache__|dist|build" }
```

**Bash:**
```bash
find . -type d -not -path '*/node_modules/*' -not -path '*/.git/*' \
    -not -path '*/__pycache__/*' -not -path '*/dist/*' -not -path '*/build/*'
```

Identify:
- Source directories (`src/`, `lib/`, `app/`)
- Test directories (`tests/`, `__tests__/`, `spec/`)
- Configuration locations
- Asset directories

### 2b. Entry Points

Find main files:
**PowerShell:**
```powershell
# Example for Node.js
Get-Content "package.json" | ConvertFrom-Json | Select-Object -ExpandProperty main
```

**Bash:**
```bash
# Example for Node.js (requires jq)
cat package.json | jq -r '.main'
```

### 2c. Component Detection

Scan for common patterns:
- React components (`*.tsx`, `*.jsx`)
- API routes (`routes/`, `api/`)
- Database models (`models/`, `entities/`)
- Services (`services/`, `lib/`)
- Utilities (`utils/`, `helpers/`)

---

## 3. Analyze Dependencies

### 3a. Production Dependencies

**PowerShell:**
```powershell
# Node.js example
Get-Content "package.json" | ConvertFrom-Json | 
    Select-Object -ExpandProperty dependencies
```

**Bash:**
```bash
# Node.js example (requires jq)
cat package.json | jq '.dependencies'
```

For each dependency, note:
- Name and version
- Purpose (infer from name/usage)
- Is it actively used?

### 3b. Development Dependencies

Same for devDependencies, noting:
- Build tools
- Test frameworks
- Linters/formatters

### 3c. Outdated Packages

```bash
npm outdated
# or
pip list --outdated
```

---

## 4. Map Data Flow

### 4a. External Integrations

Search for:
**PowerShell:**
```powershell
# API calls
Select-String -Path "src/**/*" -Pattern "fetch\(|axios\.|http\."

# Database connections
Select-String -Path "**/*" -Pattern "DATABASE_URL|mongodb|postgres|mysql"

# Third-party services
Select-String -Path "**/*" -Pattern "stripe|sendgrid|twilio|aws-sdk"
```

**Bash:**
```bash
# API calls
grep -rE 'fetch\(|axios\.|http\.' src/

# Database connections
grep -rE 'DATABASE_URL|mongodb|postgres|mysql' .

# Third-party services
grep -rE 'stripe|sendgrid|twilio|aws-sdk' .
```

### 4b. Internal Flow

Trace how data moves:
- Entry point ‚Üí Business logic ‚Üí Data layer ‚Üí Output
- Identify shared state (context, stores, singletons)

---

## 5. Identify Technical Debt

### 5a. Code Smells

Search for indicators:
**PowerShell:**
```powershell
# TODOs and FIXMEs
Select-String -Path "src/**/*" -Pattern "TODO|FIXME|HACK|XXX"

# Deprecated markers
Select-String -Path "**/*" -Pattern "@deprecated|DEPRECATED"
```

**Bash:**
```bash
# TODOs and FIXMEs
grep -rE 'TODO|FIXME|HACK|XXX' src/

# Deprecated markers
grep -rE '@deprecated|DEPRECATED' .
```

### 5b. Pattern Inconsistencies

Note where patterns differ:
- Naming conventions
- File organization
- Error handling approaches

### 5c. Missing Elements

Identify gaps:
- No tests for critical paths
- Missing error boundaries
- No input validation
- No logging/monitoring

---

## 6. Write ARCHITECTURE.md

```markdown
# Architecture

> Auto-generated by /map on {date}

## Overview

{High-level description of what this system does}

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              [Entry Point]              ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ         [Business Logic Layer]          ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ            [Data Layer]                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## Components

### {Component 1}
- **Purpose:** {what it does}
- **Location:** `{path}`
- **Dependencies:** {what it imports}

### {Component 2}
...

## Data Flow

1. {Step 1}
2. {Step 2}
3. {Step 3}

## Integration Points

| Service | Type | Purpose |
|---------|------|---------|
| {name} | API | {purpose} |

## Technical Debt

- [ ] {Debt item 1}
- [ ] {Debt item 2}

## Conventions

**Naming:** {patterns observed}
**Structure:** {organization patterns}
**Testing:** {test patterns}
```

---

## 7. Write STACK.md

```markdown
# Technology Stack

> Auto-generated by /map on {date}

## Runtime

| Technology | Version | Purpose |
|------------|---------|---------|
| {runtime} | {version} | Core runtime |

## Dependencies

### Production
| Package | Version | Purpose |
|---------|---------|---------|
| {pkg} | {ver} | {purpose} |

### Development
| Package | Version | Purpose |
|---------|---------|---------|
| {pkg} | {ver} | {purpose} |

## Infrastructure

| Service | Provider | Purpose |
|---------|----------|---------|
| {service} | {provider} | {purpose} |

## Configuration

| Variable | Purpose | Location |
|----------|---------|----------|
| {var} | {purpose} | {file} |

## Outdated Packages

| Package | Current | Latest | Risk |
|---------|---------|--------|------|
| {pkg} | {cur} | {new} | {risk} |
```

---

## 8. Update State

Update `.gsd/STATE.md`:
```markdown
## Last Session Summary
Codebase mapping complete.
- {N} components identified
- {M} dependencies analyzed
- {K} technical debt items found
```

---

## 9. Commit Documentation

```bash
git add .gsd/ARCHITECTURE.md .gsd/STACK.md .gsd/STATE.md
git commit -m "docs: map existing codebase"
```

---

## 10. Offer Next Steps

</process>

<offer_next>

```
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
 GSD ‚ñ∫ CODEBASE MAPPED ‚úì
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

Components: {N}
Dependencies: {M} production, {K} dev
Technical debt: {J} items

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

‚ñ∂ Next Up

/plan ‚Äî create execution plans with full context

Files updated:
‚Ä¢ .gsd/ARCHITECTURE.md
‚Ä¢ .gsd/STACK.md

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
```

</offer_next>

<related>
## Related

### Workflows
| Command | Relationship |
|---------|--------------|
| `/plan` | Use ARCHITECTURE.md from /map for planning context |

### Skills
| Skill | Purpose |
|-------|---------|
| `codebase-mapper` | Detailed mapping methodology |
</related>
</file>

<file path=".agent/workflows/new-milestone.md">
---
description: Create a new milestone with phases
argument-hint: "<milestone-name>"
---

# /new-milestone Workflow

<objective>
Define a new milestone with goal, phases, and success criteria.
</objective>

<process>

## 1. Validate SPEC Exists

**PowerShell:**
```powershell
if (-not (Test-Path ".gsd/SPEC.md")) {
    Write-Error "SPEC.md required. Run /new-project first."
}
```

**Bash:**
```bash
if [ ! -f ".gsd/SPEC.md" ]; then
    echo "Error: SPEC.md required. Run /new-project first." >&2
fi
```

---

## 2. Gather Milestone Information

Ask for:
- **Name** ‚Äî Milestone identifier (e.g., "v1.0", "MVP", "Beta")
- **Goal** ‚Äî What does this milestone achieve?
- **Must-haves** ‚Äî Non-negotiable deliverables
- **Nice-to-haves** ‚Äî Optional if time permits

---

## 3. Generate Phase Breakdown

Based on goal and must-haves, suggest phases:

```markdown
## Suggested Phases

Phase 1: {Foundation/Setup}
Phase 2: {Core Feature A}
Phase 3: {Core Feature B}
Phase 4: {Integration/Polish}
Phase 5: {Verification/Launch}
```

Ask user to confirm or modify.

---

## 4. Update ROADMAP.md

```markdown
# ROADMAP.md

> **Current Milestone**: {name}
> **Goal**: {goal}

## Must-Haves
- [ ] {must-have 1}
- [ ] {must-have 2}

## Phases

### Phase 1: {name}
**Status**: ‚¨ú Not Started
**Objective**: {description}

### Phase 2: {name}
**Status**: ‚¨ú Not Started
**Objective**: {description}

...
```

---

## 5. Update STATE.md

```markdown
## Current Position
- **Milestone**: {name}
- **Phase**: Not started
- **Status**: Milestone planned
```

---

## 6. Commit

```bash
git add .gsd/ROADMAP.md .gsd/STATE.md
git commit -m "docs: create milestone {name}"
```

---

## 7. Offer Next Steps

```
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
 GSD ‚ñ∫ MILESTONE CREATED ‚úì
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

Milestone: {name}
Phases: {N}

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

‚ñ∂ NEXT

/plan 1 ‚Äî Create Phase 1 execution plans

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
```

</process>
</file>

<file path=".agent/workflows/new-project.md">
---
description: Initialize a new project with deep context gathering
---

# /new-project Workflow

<objective>
Initialize a new project through unified flow: questioning ‚Üí research (optional) ‚Üí requirements ‚Üí roadmap.

This is the most leveraged moment in any project. Deep questioning here means better plans, better execution, better outcomes. One command takes you from idea to ready-for-planning.

**Creates:**
- `.gsd/SPEC.md` ‚Äî project specification
- `.gsd/ROADMAP.md` ‚Äî phase structure
- `.gsd/STATE.md` ‚Äî project memory
- `.gsd/ARCHITECTURE.md` ‚Äî system design (if brownfield)
- All other .gsd/ documentation files

**After this command:** Run `/plan 1` to start execution.
</objective>

<process>

## Phase 1: Setup
**MANDATORY FIRST STEP ‚Äî Execute these checks before ANY user interaction:**

1. **Abort if project exists:**

   **PowerShell:**
   ```powershell
   if (Test-Path ".gsd/SPEC.md") {
       Write-Error "Project already initialized. Use /progress"
       exit 1
   }
   ```

   **Bash:**
   ```bash
   if [ -f ".gsd/SPEC.md" ]; then
       echo "Error: Project already initialized. Use /progress" >&2
       exit 1
   fi
   ```

2. **Initialize git repo** (if not exists):

   **PowerShell:**
   ```powershell
   if (-not (Test-Path ".git")) {
       git init
       Write-Output "Initialized new git repo"
   }
   ```

   **Bash:**
   ```bash
   if [ ! -d ".git" ]; then
       git init
       echo "Initialized new git repo"
   fi
   ```

3. **Detect existing code (brownfield detection):**

   **PowerShell:**
   ```powershell
   $codeFiles = Get-ChildItem -Recurse -Include "*.ts","*.js","*.py","*.go","*.rs" | 
       Where-Object { $_.FullName -notmatch "node_modules|\.git" } | 
       Select-Object -First 20
   
   $hasPackage = Test-Path "package.json" -or Test-Path "requirements.txt" -or Test-Path "Cargo.toml"
   $hasArchitecture = Test-Path ".gsd/ARCHITECTURE.md"
   ```

   **Bash:**
   ```bash
   code_files=$(find . -type f \( -name "*.ts" -o -name "*.js" -o -name "*.py" -o -name "*.go" -o -name "*.rs" \) \
       -not -path '*/node_modules/*' -not -path '*/.git/*' | head -20)
   
   has_package=$(test -f "package.json" -o -f "requirements.txt" -o -f "Cargo.toml" && echo true || echo false)
   has_architecture=$(test -f ".gsd/ARCHITECTURE.md" && echo true || echo false)
   ```

---

## Phase 2: Brownfield Offer
**If existing code detected and ARCHITECTURE.md doesn't exist:**

```
‚ö†Ô∏è EXISTING CODE DETECTED

Found {N} source files in this directory.

Options:
A) Map codebase first ‚Äî Run /map to understand existing architecture (Recommended)
B) Skip mapping ‚Äî Proceed with project initialization

Which do you prefer?
```

**If "Map codebase first":**
```
Run `/map` first, then return to `/new-project`
```
Exit command.

**If "Skip mapping":** Continue to Phase 3.
**If no existing code detected OR codebase already mapped:** Continue to Phase 3.

---

## Phase 3: Deep Questioning

Display banner:
```
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
 GSD ‚ñ∫ QUESTIONING
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
```

**Open the conversation:**

Ask: "What do you want to build?"

Wait for response. This gives context for intelligent follow-ups.

**Follow the thread:**

Based on their answer, ask follow-up questions that dig deeper:
- What excited them about this idea
- What problem sparked this
- What they mean by vague terms
- What it would actually look like
- What's already decided

**Questioning techniques:**
- Challenge vagueness: "When you say 'fast', what does that mean specifically?"
- Make abstract concrete: "Give me an example of how a user would..."
- Surface assumptions: "You're assuming users will... Is that validated?"
- Find edges: "What's explicitly NOT in scope?"
- Reveal motivation: "Why does this matter now?"

**Context checklist (gather mentally, not as interrogation):**
- [ ] Vision ‚Äî What does success look like?
- [ ] Users ‚Äî Who is this for?
- [ ] Problem ‚Äî What pain does it solve?
- [ ] Scope ‚Äî What's in, what's out?
- [ ] Constraints ‚Äî Technical, timeline, budget?
- [ ] Prior art ‚Äî What exists already?

**Decision gate:**

When you could write a clear SPEC.md:
```
Ready to create SPEC.md?

A) Create SPEC.md ‚Äî Let's move forward
B) Keep exploring ‚Äî I want to share more
```

If "Keep exploring" ‚Äî ask what they want to add, or identify gaps and probe naturally.

Loop until "Create SPEC.md" selected.

---

## Phase 4: Write SPEC.md

Create `.gsd/SPEC.md`:

```markdown
# SPEC.md ‚Äî Project Specification

> **Status**: `FINALIZED`

## Vision
{Distilled from questioning ‚Äî one paragraph max}

## Goals
1. {Primary goal}
2. {Secondary goal}
3. {Tertiary goal}

## Non-Goals (Out of Scope)
- {Explicitly excluded}
- {Not in this version}

## Users
{Who will use this and how}

## Constraints
- {Technical constraints}
- {Timeline constraints}
- {Other limitations}

## Success Criteria
- [ ] {Measurable outcome 1}
- [ ] {Measurable outcome 2}
```

---

## Phase 5: Research Decision

If project involves unfamiliar technology or architectural decisions:

```
üìö RESEARCH CHECK

This project involves {area where research might help}.

Would you like to:
A) Do research first ‚Äî Investigate options before committing
B) Skip research ‚Äî I know what I want, let's plan

```

**If research selected:**
- Create `.gsd/RESEARCH.md` with findings
- Document technology choices and rationale
- Return to continue

---

## Phase 6: Define Requirements

Generate requirements from SPEC.md:

```markdown
# REQUIREMENTS.md

## Format
| ID | Requirement | Source | Status |
|----|-------------|--------|--------|
| REQ-01 | {requirement} | SPEC goal 1 | Pending |
| REQ-02 | {requirement} | SPEC goal 2 | Pending |
```

**Rules:**
- Each requirement is testable
- Each maps to a SPEC goal
- Status starts as "Pending"

**If simple project:** Skip formal requirements, SPEC.md is sufficient.

---

## Phase 7: Create Roadmap

Create `.gsd/ROADMAP.md`:

```markdown
# ROADMAP.md

> **Current Phase**: Not started
> **Milestone**: v1.0

## Must-Haves (from SPEC)
- [ ] {must-have 1}
- [ ] {must-have 2}

## Phases

### Phase 1: {Foundation}
**Status**: ‚¨ú Not Started
**Objective**: {what this delivers}
**Requirements**: REQ-01, REQ-02

### Phase 2: {Core Feature}
**Status**: ‚¨ú Not Started
**Objective**: {what this delivers}
**Requirements**: REQ-03

### Phase 3: {Integration}
**Status**: ‚¨ú Not Started
**Objective**: {what this delivers}

### Phase 4: {Polish/Launch}
**Status**: ‚¨ú Not Started
**Objective**: {final touches}
```

**Phase creation rules:**
- 3-5 phases per milestone
- Each phase has clear deliverable
- Dependencies flow forward

---

## Phase 8: Initialize Remaining Files

Create with templates:
- `.gsd/STATE.md` ‚Äî Empty state
- `.gsd/DECISIONS.md` ‚Äî Empty ADR log
- `.gsd/JOURNAL.md` ‚Äî Empty journal
- `.gsd/TODO.md` ‚Äî Empty todo list

Create directories:
- `.gsd/phases/`
- `.gsd/templates/`

---

## Phase 9: Initial Commit

```bash
git add .gsd/
git commit -m "chore: initialize GSD project

- SPEC.md with vision and goals
- ROADMAP.md with {N} phases
- Project documentation structure"
```

---

## Phase 10: Done

```
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
 GSD ‚ñ∫ PROJECT INITIALIZED ‚úì
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

Project: {name}
Phases: {N}

Files created:
‚Ä¢ .gsd/SPEC.md (FINALIZED)
‚Ä¢ .gsd/ROADMAP.md ({N} phases)
‚Ä¢ .gsd/STATE.md
‚Ä¢ .gsd/DECISIONS.md
‚Ä¢ .gsd/JOURNAL.md

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

‚ñ∂ NEXT

/discuss-phase 1 ‚Äî Clarify scope (optional but recommended)
/plan 1 ‚Äî Create Phase 1 execution plans

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

üí° The questioning phase is the highest-leverage moment.
   Time invested here pays dividends throughout execution.

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
```

</process>

<questioning_philosophy>
## Why Deep Questioning Matters

The original GSD emphasizes that `/new-project` is the most leveraged moment. 
Every minute spent understanding what to build saves hours of building the wrong thing.

**Signs questioning is done:**
- You could explain the project to a stranger
- You know what's NOT being built (scope edges)
- Success criteria are measurable
- You're excited to start planning

**Signs more questioning needed:**
- Vague terms remain unexplained
- You don't know who the user is
- Success is defined as "it works"
- Scope keeps expanding during discussion
</questioning_philosophy>
</file>

<file path=".agent/workflows/pause.md">
---
description: Context hygiene ‚Äî dump state for clean session handoff
---

# /pause Workflow

<objective>
Safely pause work with complete state preservation for session handoff.
</objective>

<when_to_use>
- Ending a work session
- Context getting heavy (many failed attempts)
- Switching to a different task
- Before taking a break
- After 3+ debugging failures (Context Hygiene rule)
</when_to_use>

<process>

## 1. Capture Current State

Update `.gsd/STATE.md`:

```markdown
## Current Position
- **Phase**: {current phase number and name}
- **Task**: {specific task in progress, if any}
- **Status**: Paused at {timestamp}

## Last Session Summary
{What was accomplished this session}

## In-Progress Work
{Any uncommitted changes or partial work}
- Files modified: {list}
- Tests status: {passing/failing/not run}

## Blockers
{What was preventing progress, if anything}

## Context Dump
{Critical context that would be lost}:

### Decisions Made
- {Decision 1}: {rationale}
- {Decision 2}: {rationale}

### Approaches Tried
- {Approach 1}: {outcome}
- {Approach 2}: {outcome}

### Current Hypothesis
{Best guess at solution/issue}

### Files of Interest
- `{file1}`: {what's relevant}
- `{file2}`: {what's relevant}

## Next Steps
1. {Specific first action for next session}
2. {Second priority}
3. {Third priority}
```

---

## 2. Add Journal Entry

Create entry in `.gsd/JOURNAL.md`:

```markdown
## Session: {YYYY-MM-DD HH:MM}

### Objective
{What this session was trying to accomplish}

### Accomplished
- {Item 1}
- {Item 2}

### Verification
- [x] {What was verified}
- [ ] {What still needs verification}

### Paused Because
{Reason for pausing}

### Handoff Notes
{Critical info for resuming}
```

---

## 3. Commit State

```bash
git add .gsd/STATE.md .gsd/JOURNAL.md
git commit -m "docs: pause session - {brief reason}"
```

---

## 4. Display Handoff

```
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
 GSD ‚ñ∫ SESSION PAUSED ‚è∏
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

State saved to:
‚Ä¢ .gsd/STATE.md
‚Ä¢ .gsd/JOURNAL.md

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

To resume later:

/resume

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

üí° Fresh context = fresh perspective
   The struggles end here. Next session starts clean.

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
```

</process>

<context_hygiene>
If pausing due to debugging failures:

1. Be explicit about what failed
2. Document exact error messages
3. List files that were touched
4. State your hypothesis clearly
5. Suggest what to try next (different approach)

A fresh context often immediately sees solutions that a polluted context missed.
</context_hygiene>
</file>

<file path=".agent/workflows/plan-milestone-gaps.md">
---
description: Create plans to address gaps found in milestone audit
---

# /plan-milestone-gaps Workflow

<objective>
Create targeted plans to address gaps, technical debt, and issues identified during milestone audit.
</objective>

<process>

## 1. Load Gap Information

Read from:
- Latest AUDIT.md or VERIFICATION.md
- TODO.md for deferred items
- DECISIONS.md for acknowledged debt

---

## 2. Categorize Gaps

| Category | Priority | Action |
|----------|----------|--------|
| Must-have failures | üî¥ High | Create fix phase |
| Technical debt | üü° Medium | Add to roadmap |
| Nice-to-have misses | üü¢ Low | Add to backlog |

---

## 3. Create Gap Closure Phase

Add new phase to ROADMAP.md:

```markdown
### Phase {N}: Gap Closure
**Status**: ‚¨ú Not Started
**Objective**: Address gaps from milestone audit

**Gaps to Close:**
- [ ] {gap 1}
- [ ] {gap 2}
```

---

## 4. Create PLAN.md for Each Gap

```markdown
---
phase: {N}
plan: fix-{gap-id}
wave: 1
gap_closure: true
---

# Fix: {Gap Description}

## Problem
{What the audit found}

## Root Cause
{Why it exists}

## Tasks

<task type="auto">
  <name>Fix {issue}</name>
  <files>{files}</files>
  <action>{fix instructions}</action>
  <verify>{original verification that failed}</verify>
  <done>{criteria}</done>
</task>
```

---

## 5. Update STATE.md

```markdown
## Gap Closure Mode
Addressing {N} gaps from milestone audit.
```

---

## 6. Commit Plans

```powershell
git add .gsd/
git commit -m "docs: create gap closure plans"
```

---

## 7. Offer Execution

```
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
 GSD ‚ñ∫ GAP CLOSURE PLANS CREATED ‚úì
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

Gaps identified: {N}
Plans created: {M}

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

‚ñ∂ NEXT

/execute {N} --gaps-only ‚Äî Execute gap closure plans

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
```

</process>
</file>

<file path=".agent/workflows/plan.md">
---
description: The Strategist ‚Äî Decompose requirements into executable phases in ROADMAP.md
argument-hint: "[phase] [--research] [--skip-research] [--gaps]"
---

# /plan Workflow

<role>
You are a GSD planner orchestrator. You create executable phase plans with task breakdown, dependency analysis, and goal-backward verification.

**Core responsibilities:**
- Parse arguments and validate phase
- Handle research (unless skipped or exists)
- Create PLAN.md files with XML task structure
- Verify plans with checker logic
- Iterate until plans pass (max 3 iterations)
</role>

<objective>
Create executable phase prompts (PLAN.md files) for a roadmap phase with integrated research and verification.

**Default flow:** Research (if needed) ‚Üí Plan ‚Üí Verify ‚Üí Done

**Why subagents:** Research and planning burn context fast. Verification uses fresh context. User sees the flow between agents in main context.
</objective>

<context>
**Phase number:** $ARGUMENTS (optional ‚Äî auto-detects next unplanned phase if not provided)

**Flags:**
- `--research` ‚Äî Force re-research even if RESEARCH.md exists
- `--skip-research` ‚Äî Skip research entirely, go straight to planning
- `--gaps` ‚Äî Gap closure mode (reads VERIFICATION.md, skips research)

**Required files:**
- `.gsd/SPEC.md` ‚Äî Must be FINALIZED (Planning Lock)
- `.gsd/ROADMAP.md` ‚Äî Must have phases defined
</context>

<philosophy>

## Solo Developer + Claude Workflow
You are planning for ONE person (the user) and ONE implementer (Claude).
- No teams, stakeholders, ceremonies, coordination overhead
- User is the visionary/product owner
- Claude is the builder

## Plans Are Prompts
PLAN.md is NOT a document that gets transformed into a prompt.
PLAN.md IS the prompt. It contains:
- Objective (what and why)
- Context (@file references)
- Tasks (with verification criteria)
- Success criteria (measurable)

## Quality Degradation Curve

| Context Usage | Quality | State |
|---------------|---------|-------|
| 0-30% | PEAK | Thorough, comprehensive |
| 30-50% | GOOD | Confident, solid work |
| 50-70% | DEGRADING | Efficiency mode begins |
| 70%+ | POOR | Rushed, minimal |

**The rule:** Plans should complete within ~50% context. More plans, smaller scope.

## Aggressive Atomicity
Each plan: **2-3 tasks max**. No exceptions.

</philosophy>

<discovery_levels>

## Discovery Protocol

Discovery is MANDATORY unless you can prove current context exists.

**Level 0 ‚Äî Skip** (pure internal work)
- ALL work follows established codebase patterns
- No new external dependencies
- Pure internal refactoring or feature extension

**Level 1 ‚Äî Quick Verification** (2-5 min)
- Single known library, confirming syntax/version
- Low-risk decision (easily changed later)
- Action: Quick web search, no RESEARCH.md needed

**Level 2 ‚Äî Standard Research** (15-30 min)
- Choosing between 2-3 options
- New external integration (API, service)
- Medium-risk decision
- Action: Create RESEARCH.md with findings

**Level 3 ‚Äî Deep Dive** (1+ hour)
- Architectural decision with long-term impact
- Novel problem without clear patterns
- High-risk, hard to change later
- Action: Full research with RESEARCH.md

</discovery_levels>

<process>

## 1. Validate Environment (Planning Lock)

**PowerShell:**
```powershell
# Check SPEC.md exists and is finalized
$spec = Get-Content ".gsd/SPEC.md" -Raw
if ($spec -notmatch "FINALIZED") {
    Write-Error "SPEC.md must be FINALIZED before planning"
    exit
}
```

**Bash:**
```bash
# Check SPEC.md exists and is finalized
if ! grep -q "FINALIZED" ".gsd/SPEC.md"; then
    echo "Error: SPEC.md must be FINALIZED before planning" >&2
    exit 1
fi
```

**If not finalized:** Error ‚Äî user must complete SPEC.md first.

---

## 2. Parse and Normalize Arguments

Extract from $ARGUMENTS:
- Phase number (integer)
- `--research` flag
- `--skip-research` flag
- `--gaps` flag

**If no phase number:** Detect next unplanned phase from ROADMAP.md.

---

## 3. Validate Phase

**PowerShell:**
```powershell
Select-String -Path ".gsd/ROADMAP.md" -Pattern "Phase $PHASE:"
```

**Bash:**
```bash
grep "Phase $PHASE:" ".gsd/ROADMAP.md"
```

**If not found:** Error with available phases.
**If found:** Extract phase name and description.

---

## 4. Ensure Phase Directory

**PowerShell:**
```powershell
$PHASE_DIR = ".gsd/phases/$PHASE"
if (-not (Test-Path $PHASE_DIR)) {
    New-Item -ItemType Directory -Path $PHASE_DIR
}
```

**Bash:**
```bash
PHASE_DIR=".gsd/phases/$PHASE"
mkdir -p "$PHASE_DIR"
```

---

## 5. Handle Research

**If `--gaps` flag:** Skip research (gap closure uses VERIFICATION.md).

**If `--skip-research` flag:** Skip to step 6.

**Check for existing research:**
**PowerShell:**
```powershell
Test-Path "$PHASE_DIR/RESEARCH.md"
```

**Bash:**
```bash
test -f "$PHASE_DIR/RESEARCH.md"
```

**If RESEARCH.md exists AND `--research` flag NOT set:**
- Display: `Using existing research: $PHASE_DIR/RESEARCH.md`
- Skip to step 6

**If research needed:**

Display banner:
```
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
 GSD ‚ñ∫ RESEARCHING PHASE {N}
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
```

Perform research based on discovery level (see `<discovery_levels>`).

Create `$PHASE_DIR/RESEARCH.md` with findings.

---

## 6. Create Plans

Display banner:
```
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
 GSD ‚ñ∫ PLANNING PHASE {N}
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
```

### 6a. Gather Context
Load:
- `.gsd/SPEC.md` ‚Äî Requirements
- `.gsd/ROADMAP.md` ‚Äî Phase description
- `$PHASE_DIR/RESEARCH.md` ‚Äî If exists
- `.gsd/ARCHITECTURE.md` ‚Äî If exists

### 6b. Decompose into Tasks
For the phase goal:
1. Identify all deliverables
2. Break into atomic tasks (2-3 per plan)
3. Determine dependencies between tasks
4. Assign execution waves

### 6c. Write PLAN.md Files

Create `$PHASE_DIR/{N}-PLAN.md`:

```markdown
---
phase: {N}
plan: 1
wave: 1
---

# Plan {N}.1: {Plan Name}

## Objective
{What this plan delivers and why}

## Context
- .gsd/SPEC.md
- .gsd/ARCHITECTURE.md
- {relevant source files}

## Tasks

<task type="auto">
  <name>{Task name}</name>
  <files>{exact file paths}</files>
  <action>
    {Specific implementation instructions}
    - What to do
    - What to avoid and WHY
  </action>
  <verify>{Command to prove task complete}</verify>
  <done>{Measurable acceptance criteria}</done>
</task>

<task type="auto">
  ...
</task>

## Success Criteria
- [ ] {Measurable outcome 1}
- [ ] {Measurable outcome 2}
```

---

## 7. Verify Plans (Checker Logic)

For each plan, verify:
- [ ] All files specified exist or will be created
- [ ] Actions are specific (no "implement X")
- [ ] Verify commands are executable
- [ ] Done criteria are measurable
- [ ] Context references exist

**If issues found:** Fix and re-verify (max 3 iterations).

---

## 8. Update State

Update `.gsd/STATE.md`:
```markdown
## Current Position
- **Phase**: {N}
- **Task**: Planning complete
- **Status**: Ready for execution

## Next Steps
1. /execute {N}
```

---

## 9. Commit Plans

```bash
git add .gsd/phases/$PHASE/
git add .gsd/STATE.md
git commit -m "docs(phase-$PHASE): create execution plans"
```

---

## 10. Offer Next Steps

</process>

<offer_next>

```
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
 GSD ‚ñ∫ PHASE {N} PLANNED ‚úì
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

{X} plans created across {Y} waves

Plans:
‚Ä¢ {N}.1: {Name} (wave 1)
‚Ä¢ {N}.2: {Name} (wave 1)
‚Ä¢ {N}.3: {Name} (wave 2)

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

‚ñ∂ Next Up

/execute {N} ‚Äî run all plans

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
```

</offer_next>

<task_types>

| Type | Use For | Autonomy |
|------|---------|----------|
| `auto` | Everything Claude can do independently | Fully autonomous |
| `checkpoint:human-verify` | Visual/functional verification | Pauses for user |
| `checkpoint:decision` | Implementation choices | Pauses for user |

**Automation-first rule:** If Claude CAN do it, Claude MUST do it. Checkpoints are for verification AFTER automation.

</task_types>

<related>
## Related

### Workflows
| Command | Relationship |
|---------|--------------|
| `/map` | Run before /plan to get codebase context |
| `/execute` | Runs PLAN.md files created by /plan |
| `/verify` | Validates executed plans |

### Skills
| Skill | Purpose |
|-------|---------|
| `planner` | Detailed planning methodology |
| `plan-checker` | Validates plans before execution |
</related>
</file>

<file path=".agent/workflows/progress.md">
---
description: Show current position in roadmap and next steps
---

# /progress Workflow

<objective>
Quick status check ‚Äî where are we and what's next?
</objective>

<process>

## 1. Load Current State

Read:
- `.gsd/STATE.md` ‚Äî Current position
- `.gsd/ROADMAP.md` ‚Äî Phase statuses

---

## 2. Calculate Progress

Count phases:
- Total phases
- Completed phases (‚úÖ)
- In progress (üîÑ)
- Blocked (‚è∏Ô∏è)
- Not started (‚¨ú)

---

## 3. Display Status

```
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
 GSD ‚ñ∫ PROGRESS
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

Project: {project name from SPEC.md}
Milestone: {milestone from ROADMAP.md}

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

PHASES

‚úÖ Phase 1: {Name}
‚úÖ Phase 2: {Name}
üîÑ Phase 3: {Name} ‚Üê CURRENT
‚¨ú Phase 4: {Name}
‚¨ú Phase 5: {Name}

Progress: {completed}/{total} ({percentage}%)

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

CURRENT TASK

{Current task from STATE.md, or "None"}

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

BLOCKERS

{Blockers from STATE.md, or "None"}

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

‚ñ∂ NEXT UP

{Recommended next action based on state}

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
```

---

## 4. Suggest Action

Based on status, recommend:

| State | Recommendation |
|-------|----------------|
| Phase in progress | `/execute {N}` to continue |
| Phase done, not verified | `/verify {N}` |
| Verification failed | `/execute {N} --gaps-only` |
| All phases complete | Celebrate! üéâ |
| No phases started | `/plan 1` to begin |
| SPEC not finalized | Complete SPEC.md first |

</process>
</file>

<file path=".agent/workflows/remove-phase.md">
---
description: Remove a phase from the roadmap (with safety checks)
argument-hint: "<phase-number>"
---

# /remove-phase Workflow

<objective>
Remove a phase from the roadmap, with safety checks for in-progress or completed work.
</objective>

<process>

## 1. Validate Phase Exists

**PowerShell:**
```powershell
$phase = Select-String -Path ".gsd/ROADMAP.md" -Pattern "### Phase $N:"
if (-not $phase) {
    Write-Error "Phase $N not found in ROADMAP.md"
}
```

**Bash:**
```bash
if ! grep -q "### Phase $N:" ".gsd/ROADMAP.md"; then
    echo "Error: Phase $N not found in ROADMAP.md" >&2
fi
```

---

## 2. Check Phase Status

**PowerShell:**
```powershell
$status = Select-String -Path ".gsd/ROADMAP.md" -Pattern "Phase $N:.*\n.*Status: (.*)"
```

**Bash:**
```bash
status=$(grep -A1 "Phase $N:" ".gsd/ROADMAP.md" | grep "Status:" | cut -d: -f2)
```

**Safety checks:**

| Status | Action |
|--------|--------|
| ‚¨ú Not Started | Safe to remove |
| üîÑ In Progress | Warn and confirm |
| ‚úÖ Complete | Error ‚Äî archive instead |

---

## 3. Check for Dependencies

Are other phases depending on this one?

**PowerShell:**
```powershell
Select-String -Path ".gsd/ROADMAP.md" -Pattern "Depends on.*Phase $N"
```

**Bash:**
```bash
grep "Depends on.*Phase $N" ".gsd/ROADMAP.md"
```

**If dependencies exist:**
```
‚ö†Ô∏è Phase {M} depends on Phase {N}

Cannot remove. Consider:
1. Update dependent phases first
2. Use /insert-phase to restructure
```

---

## 4. Confirm Removal

```
‚ö†Ô∏è CONFIRM REMOVAL

Phase {N}: {name}
Status: {status}

This will:
- Remove phase from ROADMAP.md
- Delete .gsd/phases/{N}/ if exists
- Renumber subsequent phases

Type "REMOVE" to confirm:
```

---

## 5. Remove Phase

1. Delete from ROADMAP.md
2. Remove `.gsd/phases/{N}/` directory
3. Renumber subsequent phases (N+1 becomes N, etc.)
4. Update dependencies

---

## 6. Update STATE.md

If currently in removed phase, set to previous phase or "Planning".

---

## 7. Commit

```bash
git add -A
git commit -m "docs: remove phase {N} - {name}"
```

---

## 8. Display Result

```
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
 GSD ‚ñ∫ PHASE REMOVED ‚úì
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

Removed: Phase {N}: {name}
Renumbered: {M} phases

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

/progress ‚Äî See updated roadmap

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
```

</process>
</file>

<file path=".agent/workflows/research-phase.md">
---
description: Deep technical research for a phase
argument-hint: "<phase-number> [--level 1|2|3]"
---

# /research-phase Workflow

<objective>
Conduct technical research to inform planning decisions for a phase.
</objective>

<discovery_levels>
## Discovery Levels

| Level | Time | Use When |
|-------|------|----------|
| 0 | 0 min | Already know, just doing it |
| 1 | 2-5 min | Single library, confirming syntax |
| 2 | 15-30 min | Choosing between options, new integration |
| 3 | 1+ hour | Architectural decision, novel problem |

**Default:** Level 2 unless specified.
</discovery_levels>

<process>

## 1. Load Phase Context

Read:
- Phase objective from ROADMAP.md
- Relevant ARCHITECTURE.md sections
- STACK.md for current technologies

---

## 2. Identify Research Questions

What needs to be understood before planning?

```markdown
## Research Questions

1. {Technical question 1}
2. {Technical question 2}
3. {Integration question}
```

---

## 3. Conduct Research

Based on discovery level:

**Level 1:** Quick verification
- Check official docs
- Confirm API/syntax

**Level 2:** Comparison research
- Compare 2-3 options
- Evaluate trade-offs
- Make recommendation

**Level 3:** Deep dive
- Prototype if needed
- Research edge cases
- Document unknowns

---

## 4. Generate RESEARCH.md

Create `.gsd/phases/{N}/RESEARCH.md`:

```markdown
---
phase: {N}
level: {1|2|3}
researched_at: {date}
---

# Phase {N} Research

## Questions Investigated
1. {question}
2. {question}

## Findings

### {Topic 1}
{What was learned}

**Sources:**
- {URL}

**Recommendation:** {what to do}

### {Topic 2}
...

## Decisions Made
| Decision | Choice | Rationale |
|----------|--------|-----------|
| {decision} | {choice} | {why} |

## Patterns to Follow
- {pattern 1}
- {pattern 2}

## Anti-Patterns to Avoid
- {anti-pattern}: {why}

## Dependencies Identified
| Package | Version | Purpose |
|---------|---------|---------|
| {pkg} | {ver} | {why} |

## Risks
- {risk}: {mitigation}

## Ready for Planning
- [x] Questions answered
- [x] Approach selected
- [x] Dependencies identified
```

---

## 5. Commit Research

```powershell
git add .gsd/phases/{N}/RESEARCH.md
git commit -m "docs(phase-{N}): research complete"
```

---

## 6. Offer Next Steps

```
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
 GSD ‚ñ∫ RESEARCH COMPLETE ‚úì
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

Phase {N}: {name}
Level: {level}

Key findings:
‚Ä¢ {finding 1}
‚Ä¢ {finding 2}

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

‚ñ∂ NEXT

/plan {N} ‚Äî Create plans informed by research

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
```

</process>
</file>

<file path=".agent/workflows/resume.md">
---
description: Restore context from previous session
---

# /resume Workflow

<objective>
Start a new session with full context from where we left off.
</objective>

<process>

## 1. Load Saved State

Read `.gsd/STATE.md` completely.

---

## 2. Display Context

```
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
 GSD ‚ñ∫ RESUMING SESSION
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

LAST POSITION
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
Phase: {phase from STATE.md}
Task: {task from STATE.md}
Status: {status when paused}

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

CONTEXT FROM LAST SESSION
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
{Context dump content from STATE.md}

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

BLOCKERS
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
{Blockers from STATE.md, or "None"}

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

NEXT STEPS (from last session)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
1. {First priority}
2. {Second priority}
3. {Third priority}

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
```

---

## 3. Load Recent Journal

Show last entry from `.gsd/JOURNAL.md`:
- What was accomplished
- Handoff notes
- Any issues encountered

---

## 4. Check for Conflicts

```bash
# Check for uncommitted changes
git status --porcelain
```

**If changes found:**
```
‚ö†Ô∏è UNCOMMITTED CHANGES DETECTED

{list of modified files}

These may be from the previous session.
Review before proceeding.
```

---

## 5. Update State

Mark session as active in `.gsd/STATE.md`:
```markdown
**Status**: Active (resumed {timestamp})
```

---

## 6. Suggest Action

```
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

‚ñ∂ READY TO CONTINUE

Suggested action based on state:

{One of:}
‚Ä¢ /execute {N} ‚Äî Continue phase execution
‚Ä¢ /verify {N} ‚Äî Verify completed phase
‚Ä¢ /plan {N} ‚Äî Create plans for phase
‚Ä¢ /progress ‚Äî See full roadmap status

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

üí° Fresh session = fresh perspective

You have all the context you need.
The previous struggles are documented.
Time to solve this with fresh eyes.

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
```

</process>

<fresh_context_advantage>
A resumed session has advantages:

1. **No accumulated confusion** ‚Äî You see the problem clearly
2. **Documented failures** ‚Äî You know what NOT to try
3. **Hypothesis preserved** ‚Äî Pick up where logic left off
4. **Full context budget** ‚Äî 200k tokens of fresh capacity

Often the first thing a fresh context sees is the obvious solution that a tired context missed.
</fresh_context_advantage>
</file>

<file path=".agent/workflows/update.md">
---
description: Update GSD to the latest version from GitHub
---

# /update Workflow

<objective>
Update GSD for Antigravity to the latest version from GitHub.
</objective>

<process>

## 1. Check Current Version

**PowerShell:**
```powershell
if (Test-Path "CHANGELOG.md") {
    $version = Select-String -Path "CHANGELOG.md" -Pattern "## \[(\d+\.\d+\.\d+)\]" | 
        Select-Object -First 1
    Write-Output "Current version: $($version.Matches.Groups[1].Value)"
}
```

**Bash:**
```bash
if [ -f "CHANGELOG.md" ]; then
    version=$(grep -oP '## \[\K[0-9]+\.[0-9]+\.[0-9]+' CHANGELOG.md | head -1)
    echo "Current version: $version"
fi
```

---

## 2. Fetch Latest from GitHub

```bash
# Clone latest to temp directory
git clone --depth 1 https://github.com/toonight/get-shit-done-for-antigravity.git .gsd-update-temp
```

---

## 3. Compare Versions

**PowerShell:**
```powershell
$remoteVersion = Select-String -Path ".gsd-update-temp/CHANGELOG.md" -Pattern "## \[(\d+\.\d+\.\d+)\]" | 
    Select-Object -First 1

Write-Output "Remote version: $($remoteVersion.Matches.Groups[1].Value)"
```

**Bash:**
```bash
remote_version=$(grep -oP '## \[\K[0-9]+\.[0-9]+\.[0-9]+' .gsd-update-temp/CHANGELOG.md | head -1)
echo "Remote version: $remote_version"
```

**If same version:**
```
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
 GSD ‚ñ∫ ALREADY UP TO DATE ‚úì
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

Version: {version}

No updates available.

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
```
Exit after cleanup.

---

## 4. Show Changes

```
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
 GSD ‚ñ∫ UPDATE AVAILABLE
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

Current: {current-version}
Latest:  {remote-version}

Changes:
{Extract from CHANGELOG.md}

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

Update now?
A) Yes ‚Äî Apply updates
B) No ‚Äî Cancel

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
```

---

## 5. Apply Updates

**If user confirms:**

**PowerShell:**
```powershell
# Backup current
Copy-Item -Recurse ".agent" ".agent.backup"
Copy-Item -Recurse ".gsd/templates" ".gsd/templates.backup"

# Update workflows and skills (preserve user's .gsd docs)
Copy-Item -Recurse -Force ".gsd-update-temp/.agent/*" ".agent/"

# Update templates only
Copy-Item -Recurse -Force ".gsd-update-temp/.gsd/templates/*" ".gsd/templates/"

# Update root files
Copy-Item -Force ".gsd-update-temp/GSD-STYLE.md" "./"
Copy-Item -Force ".gsd-update-temp/CHANGELOG.md" "./"
```

**Bash:**
```bash
# Backup current
cp -r .agent .agent.backup
cp -r .gsd/templates .gsd/templates.backup

# Update workflows and skills (preserve user's .gsd docs)
cp -r .gsd-update-temp/.agent/* .agent/

# Update templates only
cp -r .gsd-update-temp/.gsd/templates/* .gsd/templates/

# Update root files
cp .gsd-update-temp/GSD-STYLE.md ./
cp .gsd-update-temp/CHANGELOG.md ./
```

---

## 6. Cleanup

**PowerShell:**
```powershell
Remove-Item -Recurse -Force ".gsd-update-temp"
Remove-Item -Recurse -Force ".agent.backup"
Remove-Item -Recurse -Force ".gsd/templates.backup"
```

**Bash:**
```bash
rm -rf .gsd-update-temp
rm -rf .agent.backup
rm -rf .gsd/templates.backup
```

---

## 7. Confirm

```
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
 GSD ‚ñ∫ UPDATED ‚úì
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

Updated to version {remote-version}

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

/whats-new ‚Äî See what changed

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
```

</process>

<preserved_files>
These user files are NEVER overwritten:
- .gsd/SPEC.md
- .gsd/ROADMAP.md
- .gsd/STATE.md
- .gsd/ARCHITECTURE.md
- .gsd/STACK.md
- .gsd/DECISIONS.md
- .gsd/JOURNAL.md
- .gsd/TODO.md
- .gsd/phases/*
- .gemini/GEMINI.md
</preserved_files>
</file>

<file path=".agent/workflows/verify.md">
---
description: The Auditor ‚Äî Validate work against spec with empirical evidence
argument-hint: "<phase-number>"
---

# /verify Workflow

<role>
You are a GSD verifier. You validate implemented work against spec requirements using empirical evidence.

**Core principle:** No "trust me, it works." Every verification produces proof.

**Core responsibilities:**
- Extract testable deliverables from phase
- Walk through each requirement
- Collect empirical evidence (commands, screenshots)
- Create verification report
- Generate fix plans if issues found
</role>

<objective>
Confirm that implemented work meets spec requirements with documented proof.

The verifier checks the CODEBASE, not SUMMARY claims.
</objective>

<context>
**Phase:** $ARGUMENTS (required ‚Äî phase number to verify)

**Required files:**
- `.gsd/SPEC.md` ‚Äî Original requirements
- `.gsd/ROADMAP.md` ‚Äî Phase definition with must-haves
- `.gsd/phases/{phase}/*-SUMMARY.md` ‚Äî What was implemented
</context>

<process>

## 1. Load Verification Context

Read:
- Phase definition from `.gsd/ROADMAP.md`
- Original requirements from `.gsd/SPEC.md`
- All SUMMARY.md files from `.gsd/phases/{phase}/`

---

## 2. Extract Must-Haves

From the phase definition, identify **must-haves** ‚Äî requirements that MUST be true for the phase to be complete.

```markdown
### Must-Haves for Phase {N}
1. {Requirement 1} ‚Äî How to verify
2. {Requirement 2} ‚Äî How to verify
3. {Requirement 3} ‚Äî How to verify
```

---

## 3. Verify Each Must-Have

For each must-have:

### 3a. Determine Verification Method

| Type | Method | Evidence |
|------|--------|----------|
| API/Backend | Run curl or test command | Command output |
| UI | Use browser tool | Screenshot |
| Build | Run build command | Success output |
| Tests | Run test suite | Test results |
| File exists | Check filesystem | File listing |
| Code behavior | Run specific scenario | Output |

### 3b. Execute Verification

Run the verification command/action.

// turbo
```bash
# Example: Run tests
npm test
```

### 3c. Record Evidence

For each must-have, record:
- **Status:** PASS / FAIL
- **Evidence:** Command output, screenshot path, etc.
- **Notes:** Any observations

---

## 4. Create Verification Report

Write `.gsd/phases/{phase}/VERIFICATION.md`:

```markdown
---
phase: {N}
verified_at: {timestamp}
verdict: PASS | FAIL | PARTIAL
---

# Phase {N} Verification Report

## Summary
{X}/{Y} must-haves verified

## Must-Haves

### ‚úÖ {Must-have 1}
**Status:** PASS
**Evidence:** 
```
{command output or description}
```

### ‚ùå {Must-have 2}
**Status:** FAIL
**Reason:** {why it failed}
**Expected:** {what should happen}
**Actual:** {what happened}

## Verdict
{PASS | FAIL | PARTIAL}

## Gap Closure Required
{If FAIL, list what needs to be fixed}
```

---

## 5. Handle Results

### If PASS (all must-haves verified):

Update `.gsd/STATE.md`:
```markdown
## Current Position
- **Phase**: {N} (verified)
- **Status**: ‚úÖ Complete and verified
```

Output:
```
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
 GSD ‚ñ∫ PHASE {N} VERIFIED ‚úì
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

{X}/{X} must-haves verified

All requirements satisfied.

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

‚ñ∂ Next Up

/execute {N+1} ‚Äî proceed to next phase

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
```

### If FAIL (some must-haves failed):

**Create gap closure plans:**

For each failed must-have, create a fix plan in `.gsd/phases/{phase}/`:

```markdown
---
phase: {N}
plan: fix-{issue}
wave: 1
gap_closure: true
---

# Fix Plan: {Issue Name}

## Problem
{What failed and why}

## Tasks

<task type="auto">
  <name>Fix {issue}</name>
  <files>{files to modify}</files>
  <action>{specific fix instructions}</action>
  <verify>{how to verify the fix}</verify>
  <done>{acceptance criteria}</done>
</task>
```

Output:
```
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
 GSD ‚ñ∫ PHASE {N} GAPS FOUND ‚ö†
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

{X}/{Y} must-haves verified
{Z} issues require fixes

Gap closure plans created.

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

‚ñ∂ Next Up

/execute {N} --gaps-only ‚Äî run fix plans

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
```

---

## 6. Commit Verification

```bash
git add .gsd/phases/{phase}/VERIFICATION.md
git commit -m "docs(phase-{N}): verification report"
```

</process>

<evidence_requirements>

## Forbidden Phrases

Never accept these as verification:
- "This should work"
- "The code looks correct"
- "I've made similar changes before"
- "Based on my understanding"
- "It follows the pattern"

## Required Evidence

| Claim | Required Proof |
|-------|----------------|
| "Tests pass" | Actual test output |
| "API works" | Curl command + response |
| "UI renders" | Screenshot |
| "Build succeeds" | Build output |
| "File created" | `ls` or `dir` output |

</evidence_requirements>

<related>
## Related

### Workflows
| Command | Relationship |
|---------|--------------|
| `/execute` | Run before /verify to implement work |
| `/execute --gaps-only` | Fix issues found by /verify |
| `/debug` | Diagnose verification failures |

### Skills
| Skill | Purpose |
|-------|---------|
| `verifier` | Detailed verification methodology |
| `empirical-validation` | Evidence requirements |
</related>
</file>

<file path=".agent/workflows/web-search.md">
---
description: Search the web for information to inform decisions
argument-hint: "<query> [--domain <site>]"
---

# /web-search Workflow

<objective>
Search the web to gather information for technical decisions, API documentation, library comparisons, or any research need.
</objective>

<when_to_use>
- Evaluating libraries or frameworks
- Finding API documentation
- Checking current best practices
- Researching error messages
- Comparing implementation approaches
- Getting up-to-date information on tools/services
</when_to_use>

<process>

## 1. Formulate Query

Parse the user's request into a focused search query.

**Good queries:**
- Specific: "Next.js 14 app router authentication best practices"
- Targeted: "Prisma vs Drizzle ORM comparison 2024"
- Actionable: "how to fix CORS error Express.js"

**Bad queries:**
- Too broad: "how to code"
- Too vague: "best database"

---

## 2. Execute Search

Use the `search_web` tool with:
- Query: The formulated search query
- Domain (optional): Prioritize specific site (e.g., `docs.python.org`)

---

## 3. Analyze Results

From the search results:
1. **Extract key information** relevant to the user's need
2. **Note sources** for citations
3. **Identify patterns** across multiple results
4. **Flag contradictions** or outdated information

---

## 4. Summarize Findings

Present findings clearly:

```
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
 GSD ‚ñ∫ WEB SEARCH RESULTS
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

Query: {query}

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

KEY FINDINGS
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚Ä¢ {finding 1}
‚Ä¢ {finding 2}
‚Ä¢ {finding 3}

RECOMMENDATION
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
{actionable recommendation based on findings}

SOURCES
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚Ä¢ {source 1}
‚Ä¢ {source 2}

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
```

---

## 5. Offer Next Steps

Based on findings:
- Suggest follow-up searches if needed
- Recommend adding to RESEARCH.md for project context
- Offer to implement based on findings

</process>

<integration>
## Integration with GSD

**During /research-phase:**
Use `/web-search` to gather information for RESEARCH.md.

**During /plan:**
Use `/web-search` when discovery level 1-3 indicates research needed.

**During /debug:**
Use `/web-search` to find solutions to error messages.
</integration>

<related>
## Related

### Workflows
| Command | Relationship |
|---------|--------------|
| `/research-phase` | Uses web-search for phase research |
| `/plan` | May trigger web-search for discovery |
| `/debug` | Search for error solutions |

</related>
</file>

<file path=".agent/workflows/whats-new.md">
---
description: Show recent GSD changes and new features
---

# /whats-new Workflow

<objective>
Display recent changes, new features, and improvements to GSD for Antigravity.
</objective>

<process>

## 1. Read CHANGELOG.md

```bash
# Read the latest version section from CHANGELOG.md
head -50 CHANGELOG.md
```

## 2. Display Recent Changes

Display the latest version(s) from CHANGELOG.md:

```
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
 GSD ‚ñ∫ WHAT'S NEW
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

VERSION 1.2.0 ‚Äî 2026-01-17
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üåç CROSS-PLATFORM SUPPORT

‚Ä¢ All 16 workflow files now have Bash equivalents
‚Ä¢ README with dual-syntax Getting Started
‚Ä¢ /web-search workflow for research

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

VERSION 1.1.0 ‚Äî 2026-01-17
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üìö TEMPLATE PARITY & EXAMPLES

‚Ä¢ 14 new templates (DEBUG.md, UAT.md, etc.)
‚Ä¢ Examples directory with walkthroughs
‚Ä¢ /add-todo and /check-todos workflows
‚Ä¢ Cross-references between workflows

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

VERSION 1.0.0 ‚Äî 2026-01-17
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üéâ INITIAL RELEASE

Full port of GSD methodology to Google Antigravity.
‚Ä¢ 24 workflows, 8 skills, 14 templates
‚Ä¢ 4 core rules: Planning Lock, State Persistence,
  Context Hygiene, Empirical Validation

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

üìö Full changelog: CHANGELOG.md

‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
```

</process>

<related>
## Related

### Workflows
| Command | Relationship |
|---------|--------------|
| `/update` | Update GSD to latest version |
| `/help` | List all commands |

</related>
</file>

<file path=".gemini/GEMINI.md">
# GSD Methodology ‚Äî Mission Control Rules

> **Get Shit Done**: A spec-driven, context-engineered development methodology.
> 
> These rules enforce disciplined, high-quality autonomous development.

---

## Core Principles

1. **Plan Before You Build** ‚Äî No code without specification
2. **State Is Sacred** ‚Äî Every action updates persistent memory
3. **Context Is Limited** ‚Äî Prevent degradation through hygiene
4. **Verify Empirically** ‚Äî No "trust me, it works"

---

## Rule 1: The Planning Lock üîí

**BEFORE writing any implementation code, you MUST verify:**

```
‚úì .gsd/SPEC.md exists AND contains "Status: FINALIZED"
‚úì .gsd/ROADMAP.md exists AND has at least one defined phase
```

**If either condition fails:**
- STOP immediately
- Inform the user that planning must be completed first
- Offer to help finalize the SPEC or create the ROADMAP
- DO NOT write any implementation code

**Exceptions:**
- Documentation updates (README, comments)
- Configuration files for tooling
- Test scaffolding (but not implementation)

---

## Rule 2: State Persistence üíæ

**AFTER every successful task completion, you MUST:**

1. **Update `.gsd/STATE.md`** with:
   - Current position (phase, task, status)
   - What was just accomplished
   - Next steps

2. **Update `.gsd/JOURNAL.md`** with session entry if:
   - Significant milestone reached
   - Session is ending
   - Major decision was made

**This is non-negotiable.** State persistence ensures context continuity across sessions.

---

## Rule 3: Context Hygiene üßπ

**IF debugging exceeds 3 consecutive failed attempts:**

1. **STOP** the current approach
2. **Summarize** to `.gsd/STATE.md`:
   - What was tried
   - What failed
   - Current hypothesis
3. **Document** the blocker in `.gsd/DECISIONS.md`
4. **Recommend** the user start a fresh session with this context

**Rationale:** Extended debugging in a polluted context leads to:
- Circular reasoning
- Missed obvious solutions  
- Hallucinated fixes

A fresh context with documented state often immediately sees the solution.

---

## Rule 4: Empirical Validation ‚úÖ

**Every change MUST be verified before marking complete:**

| Change Type | Verification Method |
|-------------|---------------------|
| UI changes | Browser screenshot confirming visual state |
| API changes | Terminal command showing correct response |
| Build changes | Successful build/test command output |
| Config changes | Verification command proving effect |

**Never mark a phase "Done" based on:**
- "The code looks correct"
- "This should work"
- "I've made similar changes before"

**Always mark a phase "Done" based on:**
- Empirical evidence captured and documented
- Verification criteria from ROADMAP.md satisfied

---

## Workflow Integration

These rules integrate with the GSD workflows:

| Workflow | Rules Enforced |
|----------|----------------|
| `/map` | Updates ARCHITECTURE.md, STACK.md |
| `/plan` | Enforces Planning Lock, creates ROADMAP |
| `/execute` | Enforces State Persistence after each task |
| `/verify` | Enforces Empirical Validation |
| `/pause` | Triggers Context Hygiene state dump |
| `/resume` | Loads state from STATE.md |

---

## Quick Reference

```
Before coding    ‚Üí Check SPEC.md is FINALIZED
After each task  ‚Üí Update STATE.md
After 3 failures ‚Üí State dump + fresh session
Before "Done"    ‚Üí Empirical proof captured
```

---

*GSD Methodology adapted for Google Antigravity*
*Source: https://github.com/glittercowboy/get-shit-done*
</file>

<file path=".gsd/examples/cross-platform.md">
# Cross-Platform Commands Reference

> PowerShell ‚Üî Bash equivalents for GSD workflows

## Common Operations

| Operation | PowerShell | Bash |
|-----------|------------|------|
| **Test file exists** | `Test-Path "file.md"` | `test -f "file.md"` |
| **Test directory exists** | `Test-Path "dir" -PathType Container` | `test -d "dir"` |
| **Create directory** | `New-Item -ItemType Directory -Path "dir"` | `mkdir -p "dir"` |
| **List files** | `Get-ChildItem "*.md"` | `ls *.md` |
| **List recursively** | `Get-ChildItem -Recurse` | `find . -type f` |
| **Read file** | `Get-Content "file.md"` | `cat "file.md"` |
| **Search in files** | `Select-String -Path "**/*" -Pattern "TODO"` | `grep -r "TODO" .` |
| **Count lines** | `(Get-Content file).Count` | `wc -l < file` |
| **Copy files** | `Copy-Item -Recurse src dest` | `cp -r src dest` |
| **Delete files** | `Remove-Item -Recurse -Force dir` | `rm -rf dir` |

## Git Operations (Same on Both)

```bash
git add -A
git commit -m "message"
git push
git status --short
```

## Workflow-Specific Examples

### /map ‚Äî Analyze Codebase

**PowerShell:**
```powershell
Get-ChildItem -Recurse -Directory | 
    Where-Object { $_.Name -notmatch "node_modules|\.git" }
```

**Bash:**
```bash
find . -type d ! -path "*/node_modules/*" ! -path "*/.git/*"
```

---

### /plan ‚Äî Check SPEC Status

**PowerShell:**
```powershell
$spec = Get-Content ".gsd/SPEC.md" -Raw
if ($spec -match "FINALIZED") { "Ready" }
```

**Bash:**
```bash
if grep -q "FINALIZED" .gsd/SPEC.md; then echo "Ready"; fi
```

---

### /execute ‚Äî Discover Plans

**PowerShell:**
```powershell
Get-ChildItem ".gsd/phases/1/*-PLAN.md"
```

**Bash:**
```bash
ls .gsd/phases/1/*-PLAN.md 2>/dev/null
```

---

### /verify ‚Äî Search TODOs

**PowerShell:**
```powershell
Select-String -Path "src/**/*" -Pattern "TODO|FIXME"
```

**Bash:**
```bash
grep -rn "TODO\|FIXME" src/
```

---

## Environment Detection

Add this to workflows for cross-platform commands:

```markdown
**Note:** Commands shown are PowerShell. For Bash equivalents, see `.gsd/examples/cross-platform.md`
```

---

*Reference for Linux/Mac users*
</file>

<file path=".gsd/examples/quick-reference.md">
# GSD Quick Reference Card

## Workflow Lifecycle

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  /map   ‚îÇ ‚Üí  ‚îÇ  /plan  ‚îÇ ‚Üí  ‚îÇ /execute ‚îÇ ‚Üí  ‚îÇ /verify ‚îÇ
‚îÇ         ‚îÇ    ‚îÇ         ‚îÇ    ‚îÇ          ‚îÇ    ‚îÇ         ‚îÇ
‚îÇ Analyze ‚îÇ    ‚îÇ Create  ‚îÇ    ‚îÇ   Run    ‚îÇ    ‚îÇ  Check  ‚îÇ
‚îÇcodebase ‚îÇ    ‚îÇ phases  ‚îÇ    ‚îÇ  tasks   ‚îÇ    ‚îÇ  work   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                   ‚Üë              ‚îÇ
                                   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                   (if gaps found)
```

## All Commands

| Command | Args | Purpose |
|---------|------|---------|
| `/map` | - | Analyze codebase ‚Üí ARCHITECTURE.md |
| `/plan` | `[phase]` | Create PLAN.md files for phase |
| `/execute` | `phase [--gaps-only]` | Run plans with wave execution |
| `/verify` | `phase` | Validate with empirical proof |
| `/debug` | `description` | Systematic debugging |
| `/progress` | - | Show current position |
| `/pause` | - | Save state, end session |
| `/resume` | - | Load state, start session |
| `/add-todo` | `item [--priority]` | Quick capture |
| `/check-todos` | `[--all]` | List pending items |

## Core Rules

| Rule | Enforcement |
|------|-------------|
| üîí Planning Lock | No code until SPEC finalized |
| üíæ State Persistence | Update STATE.md after tasks |
| üßπ Context Hygiene | 3 failures ‚Üí fresh session |
| ‚úÖ Empirical Validation | Proof required for "done" |

## Key Files

| File | Purpose | Updated By |
|------|---------|------------|
| SPEC.md | Vision (finalize first!) | User |
| ROADMAP.md | Phase definitions | /plan |
| STATE.md | Session memory | All |
| ARCHITECTURE.md | System design | /map |
| TODO.md | Quick capture | /add-todo |

## XML Task Structure

```xml
<task type="auto">
  <name>Clear name</name>
  <files>exact/path.ts</files>
  <action>Specific instructions</action>
  <verify>Executable command</verify>
  <done>Measurable criteria</done>
</task>
```

## Priority Indicators

| Priority | Icon |
|----------|------|
| High | üî¥ |
| Medium | üü° |
| Low | üü¢ |

---

*Print this for quick reference!*
</file>

<file path=".gsd/examples/workflow-example.md">
# GSD Workflow Example

> A complete walkthrough of using GSD from start to finish.

## Scenario: Building a Simple Todo API

### Step 1: Define the Spec

First, fill out `.gsd/SPEC.md`:

```markdown
# SPEC.md

> **Status**: `FINALIZED`

## Vision
A simple RESTful API for managing todo items.

## Goals
1. CRUD operations for todos
2. Persistence to SQLite
3. Input validation

## Success Criteria
- [ ] POST /todos creates a todo
- [ ] GET /todos returns list
- [ ] DELETE /todos/:id removes item
```

---

### Step 2: Map the Codebase (if existing)

```
/map
```

This creates:
- `.gsd/ARCHITECTURE.md` ‚Äî Current structure
- `.gsd/STACK.md` ‚Äî Technologies in use

---

### Step 3: Plan the Phases

```
/plan 1
```

GSD analyzes the SPEC and creates `.gsd/phases/1/` with PLAN.md files:

```markdown
# Plan 1.1: Database Setup

## Objective
Create SQLite database with todos table.

## Tasks

<task type="auto">
  <name>Initialize SQLite database</name>
  <files>src/db.ts</files>
  <action>
    Create SQLite connection using better-sqlite3.
    Create todos table with: id, title, completed, created_at.
  </action>
  <verify>node -e "require('./src/db')" exits without error</verify>
  <done>Database file exists, table created</done>
</task>
```

---

### Step 4: Execute the Phase

```
/execute 1
```

GSD:
1. Loads Plan 1.1
2. Executes tasks in order
3. Runs verify commands
4. Creates atomic commits
5. Creates SUMMARY.md
6. Proceeds to Plan 1.2
7. Verifies phase goal

---

### Step 5: Verify the Work

```
/verify 1
```

GSD:
1. Extracts must-haves from phase
2. Runs verification commands
3. Captures evidence
4. Creates VERIFICATION.md
5. Reports pass/fail

---

### Step 6: Continue or Debug

**If verified:**
```
/plan 2      ‚Üí Plan next phase
/execute 2   ‚Üí Execute next phase
```

**If issues found:**
```
/execute 1 --gaps-only   ‚Üí Run fix plans
/debug "API returns 500" ‚Üí Debug the issue
```

---

## Quick Commands Reference

| Command | When to Use |
|---------|-------------|
| `/map` | Analyze existing codebase |
| `/plan [N]` | Create plans for phase N |
| `/execute [N]` | Run all plans in phase N |
| `/verify [N]` | Confirm phase N works |
| `/debug [issue]` | Fix a problem |
| `/progress` | See current status |
| `/pause` | End session, save state |
| `/resume` | Start new session |
| `/add-todo` | Capture quick idea |
| `/check-todos` | See pending items |

---

*This example demonstrates the GSD methodology flow.*
</file>

<file path=".gsd/phases/1/1.1-init.md">
---
phase: 1
plan: 1
wave: 1
depends_on: []
files_modified:
  - package.json
  - .env.local
  - components.json
  - app/layout.tsx
  - app/page.tsx
autonomous: true
user_setup:
  - service: supabase
    why: "Backend database and authentication"
    env_vars:
      - name: NEXT_PUBLIC_SUPABASE_URL
        source: "Supabase Dashboard -> Project Settings -> API"
      - name: NEXT_PUBLIC_SUPABASE_ANON_KEY
        source: "Supabase Dashboard -> Project Settings -> API"

must_haves:
  truths:
    - "Next.js dev server runs without errors"
    - "Shadcn UI is configured"
    - "Supabase client libraries are installed"
  artifacts:
    - "package.json exists"
    - ".env.local exists"
---

# Plan 1.1: Project Initialization

<objective>
Initialize the Next.js 14 application with TypeScript, Tailwind CSS, and Shadcn UI. Configure Supabase environment variables and install client libraries.

Purpose: specific instructions to ensure a clean, modern foundation.
Output: specific instructions to verified running localhost server.
</objective>

<context>
Load for context:
- .gsd/SPEC.md
</context>

<tasks>

<task type="auto">
  <name>Initialize Next.js App</name>
  <files>package.json, tsconfig.json, next.config.mjs</files>
  <action>
    Run `npx create-next-app@latest . --typescript --tailwind --eslint --app --src-dir --import-alias "@/*" --use-npm --no-git`.
    (Note: --no-git because repo already initialized).
    If it complains about non-empty directory, use a temporary name then move contents.
  </action>
  <verify>npm run dev -- --help</verify>
  <done>Next.js project structure created in root</done>
</task>

<task type="auto">
  <name>Install Dependencies & Shadcn</name>
  <files>components.json, package.json</files>
  <action>
    1. Initialize Shadcn: `npx shadcn-ui@latest init` (Defaults: Slate, CSS Variables, etc).
    2. Install Supabase: `npm install @supabase/supabase-js @supabase/ssr`.
    3. Install basics: `npm install lucide-react`.
  </action>
  <verify>npm list @supabase/supabase-js</verify>
  <done>Dependencies installed</done>
</task>

<task type="auto">
  <name>Configure Environment</name>
  <files>.env.local</files>
  <action>
    Create `.env.local` with placeholders for `NEXT_PUBLIC_SUPABASE_URL` and `NEXT_PUBLIC_SUPABASE_ANON_KEY`.
    Notify user to populate them.
  </action>
  <verify>ls .env.local</verify>
  <done>.env.local exists</done>
</task>

</tasks>

<verification>
After all tasks, verify:
- [ ] npm run dev starts successfully
- [ ] localhost:3000 loads the default next.js page
</verification>
</file>

<file path=".gsd/phases/1/1.2-schema.md">
---
phase: 1
plan: 2
wave: 2
depends_on: [1]
files_modified:
  - supabase/schema.sql
  - types/supabase.ts
autonomous: true
user_setup:
  - service: supabase
    why: "Apply database schema"
    dashboard_config:
      - task: "Run SQL Query"
        location: "Supabase Dashboard -> SQL Editor -> New Query -> Paste schema.sql content -> Run"

must_haves:
  truths:
    - "Detailed multi-tenancy schema is defined"
    - "RLS policies enforce isolation"
  artifacts:
    - "supabase/schema.sql exists"
    - "types/supabase.ts exists"
---

# Plan 1.2: Database Schema & Types

<objective>
Define the Supabase Database schema for multi-tenancy (Organizations, Chatbots, Users). Create SQL migration file and TypeScript definitions.

Purpose: specific instructions to ensure data isolation.
Output: specific instructions to SQL file and Type definitions.
</objective>

<context>
Load for context:
- .gsd/SPEC.md
- .gsd/REQUIREMENTS.md
</context>

<tasks>

<task type="auto">
  <name>Create Schema SQL</name>
  <files>supabase/schema.sql</files>
  <action>
    Create a SQL file defining:
    1. `organizations` table (id, name, created_at).
    2. `profiles` table (id references auth.users, org_id references organizations).
    3. `chatbots` table (id, org_id, name, config jsonb).
    4. RLS Policies:
       - Users can only read/update their own profile.
       - Users can only read/write chatbots belonging to their `org_id`.
  </action>
  <verify>cat supabase/schema.sql</verify>
  <done>SQL file contains tables and RLS policies</done>
</task>

<task type="auto">
  <name>Generate Types</name>
  <files>types/supabase.ts</files>
  <action>
    Create a TypeScript file exporting `Database` interface matching the SQL schema manually (since we might not have CLI access).
    Include tables: profiles, organizations, chatbots.
  </action>
  <verify>cat types/supabase.ts</verify>
  <done>Types correctly mapped to schema</done>
</task>

</tasks>

<verification>
After all tasks, verify:
- [ ] Schema handles multi-tenancy (org_id linkage)
- [ ] Types match the schema
</verification>
</file>

<file path=".gsd/phases/1/1.3-auth.md">
---
phase: 1
plan: 3
wave: 3
depends_on: [1, 2]
files_modified:
  - utils/supabase/server.ts
  - utils/supabase/client.ts
  - utils/supabase/middleware.ts
  - app/login/page.tsx
  - app/auth/callback/route.ts
  - app/(auth)/signup/page.tsx
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can sign up"
    - "User can log in"
    - "Session persists"
  artifacts:
    - "Supabase Auth Helpers created"
    - "Login Page created"
  key_links:
    - "Auth middleware protects routes"
---

# Plan 1.3: Auth Implementation

<objective>
Implement Supabase Authentication using SSR helpers. Create Login/Signup pages and Middleware for session management.

Purpose: specific instructions to enable user access.
Output: specific instructions to working auth flow.
</objective>

<context>
Load for context:
- .gsd/SPEC.md
- types/supabase.ts
</context>

<tasks>

<task type="auto">
  <name>Setup Auth Helpers (SSR)</name>
  <files>utils/supabase/server.ts, utils/supabase/client.ts, utils/supabase/middleware.ts</files>
  <action>
    Implement `createClient` for server (cookies), client (browser), and middleware (session refresh).
    Follow Supabase Next.js App Router guide exactly.
  </action>
  <verify>ls utils/supabase/</verify>
  <done>3 helper files created</done>
</task>

<task type="auto">
  <name>Create Auth Architecture</name>
  <files>app/auth/callback/route.ts, app/middleware.ts</files>
  <action>
    1. Create callback route to exchange code for session.
    2. Update root `middleware.ts` to use `updateSession`.
  </action>
  <verify>ls app/auth/callback/route.ts</verify>
  <done>Auth infrastructure ready</done>
</task>

<task type="auto">
  <name>Create Login/Signup Pages</name>
  <files>app/login/page.tsx, app/signup/page.tsx</files>
  <action>
    Create simple Shadcn forms for Login and Signup.
    Login Action: `signInWithPassword`.
    Signup Action: `signUp` (email/pass).
    Redirect to `/dashboard` on success.
  </action>
  <verify>ls app/login/page.tsx</verify>
  <done>UI for auth exists</done>
</task>

</tasks>

<verification>
After all tasks, verify:
- [ ] Build succeeds (`npm run build`)
- [ ] Auth helpers import correctly
</verification>
</file>

<file path=".gsd/phases/1/1.4-dashboard.md">
---
phase: 1
plan: 4
wave: 4
depends_on: [3]
files_modified:
  - app/dashboard/layout.tsx
  - app/dashboard/page.tsx
  - components/dashboard-nav.tsx
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Dashboard is protected (redirects to login if unauth)"
    - "Dashboard shows sidebar navigation"
  artifacts:
    - "app/dashboard/layout.tsx exists"
  key_links:
    - "Middleware protects /dashboard"
---

# Plan 1.4: Dashboard Foundation

<objective>
Create the private Dashboard layout with sidebar navigation and an empty home state.

Purpose: specific instructions to provide user workspace.
Output: specific instructions to working dashboard structure.
</objective>

<context>
Load for context:
- .gsd/SPEC.md
</context>

<tasks>

<task type="auto">
  <name>Create Dashboard Shell</name>
  <files>app/dashboard/layout.tsx, components/dashboard-nav.tsx</files>
  <action>
    Create a Sidebar layout using Shadcn components (Sheet for mobile, generic div for desktop).
    Links: [Overview, Chatbots, Settings].
    Add UserNav component for Logout.
  </action>
  <verify>ls app/dashboard/layout.tsx</verify>
  <done>Responsive shell created</done>
</task>

<task type="auto">
  <name>Create Dashboard Home</name>
  <files>app/dashboard/page.tsx</files>
  <action>
    Create a simple "Welcome" page.
    Fetch user info from server component to prove auth works.
    Display "You are logged in as {email}".
  </action>
  <verify>ls app/dashboard/page.tsx</verify>
  <done>Verified auth content display</done>
</task>

</tasks>

<verification>
After all tasks, verify:
- [ ] Dashboard route is accessible
- [ ] Layout wraps page content
</verification>
</file>

<file path=".gsd/phases/2/2.1-gemini.md">
---
phase: 2
plan: 1
wave: 1
depends_on: []
files_modified:
  - lib/ai/gemini.ts
  - .env.local
autonomous: true
user_setup:
  - service: google_gemini
    why: "LLM and RAG capabilities"
    env_vars:
      - name: GOOGLE_API_KEY
        source: "Google AI Studio -> Get API Key"

must_haves:
  truths:
    - "Can upload file to Gemini File API"
    - "Can query Gemini using File Search"
  artifacts:
    - "lib/ai/gemini.ts exists"
---

# Plan 2.1: Gemini RAG Integration

<objective>
Implement the core Gemini service wrapper in `lib/ai/gemini.ts`.
Functionality: Upload files to Gemini Files API, and Generate Content using `models.gemini-1.5-flash` with retrieval tools.

Purpose: specific instructions to enable AI answers from docs.
Output: specific instructions to working Gemini wrapper.
</objective>

<context>
Load for context:
- .gsd/SPEC.md
- [Gemini File Search Docs](https://ai.google.dev/gemini-api/docs/file-search)
</context>

<tasks>

<task type="auto">
  <name>Install Google AI SDK</name>
  <files>package.json</files>
  <action>
    Install `@google/generative-ai` and `@google/generative-ai/files`.
  </action>
  <verify>npm list @google/generative-ai</verify>
  <done>SDKs installed</done>
</task>

<task type="auto">
  <name>Create Gemini Service</name>
  <files>lib/ai/gemini.ts</files>
  <action>
    Create `GeminiService` class/functions:
    1. `uploadFile(file: File, mimeType: string)`: Uploads to Gemini Files API.
    2. `deleteFile(name: string)`: Cleanup.
    3. `generateAnswer(query: string, fileUris: string[])`: Uses `generativeModel` with `tools: [{ fileSearch: {} }]`.
    
    Handle API Key linkage from process.env.GOOGLE_API_KEY.
  </action>
  <verify>ls lib/ai/gemini.ts</verify>
  <done>Service wrapper implemented</done>
</task>

</tasks>

<verification>
After all tasks, verify:
- [ ] Logic compiles
- [ ] Environment variable placeholder exists
</verification>
</file>

<file path=".gsd/phases/2/2.2-firecrawl.md">
---
phase: 2
plan: 2
wave: 1
depends_on: []
files_modified:
  - lib/ai/firecrawl.ts
  - .env.local
autonomous: true
user_setup:
  - service: firecrawl
    why: "Web crawling to Markdown"
    env_vars:
      - name: FIRECRAWL_API_KEY
        source: "Firecrawl.dev Dashboard"

must_haves:
  truths:
    - "Can crawl URL and get Markdown"
  artifacts:
    - "lib/ai/firecrawl.ts exists"
---

# Plan 2.2: Firecrawl Integration

<objective>
Implement the Firecrawl service wrapper in `lib/ai/firecrawl.ts`.
Functionality: Crawl a website URL and return clean Markdown content for ingestion.

Purpose: specific instructions to turn websites into RAG documents.
Output: specific instructions to working Firecrawl wrapper.
</objective>

<context>
Load for context:
- .gsd/SPEC.md
</context>

<tasks>

<task type="auto">
  <name>Create Firecrawl Service</name>
  <files>lib/ai/firecrawl.ts</files>
  <action>
    Implement `crawlWebsite(url: string)`:
    - POST to `https://api.firecrawl.dev/v0/crawl`
    - Poll for status / get result.
    - Return list of `{ url, markdown }`.
    
    Use `fetch` directly (no SDK needed unless preferred).
  </action>
  <verify>ls lib/ai/firecrawl.ts</verify>
  <done>Service wrapper implemented</done>
</task>

</tasks>

<verification>
After all tasks, verify:
- [ ] Logic compiles
- [ ] Environment variable placeholder exists
</verification>
</file>

<file path=".gsd/phases/2/2.3-ingestion.md">
---
phase: 2
plan: 3
wave: 2
depends_on: [1, 2]
files_modified:
  - app/api/knowledge/upload/route.ts
  - app/api/knowledge/crawl/route.ts
  - types/supabase.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "API endpoints receive files/URLs"
    - "Data flows to Gemini/Firecrawl"
    - "Metadata stored in Supabase"
  artifacts:
    - "app/api/knowledge/upload/route.ts exists"
    - "app/api/knowledge/crawl/route.ts exists"
---

# Plan 2.3: Ingestion API

<objective>
Create Next.js API Routes to handle knowledge ingestion.
1. `/api/knowledge/upload`: Accepts FormData (PDF/TXT), uploads to Gemini, stores metadata in `knowledge_base_sources` (need to create this table first!).
2. `/api/knowledge/crawl`: Accepts URL, triggers Firecrawl, uploads results to Gemini, stores metadata.

**Note**: We missed `knowledge_base_sources` in Phase 1 Schema. Will add it here.

Purpose: specific instructions to glue Frontend to AI Services.
Output: specific instructions to working API endpoints.
</objective>

<context>
Load for context:
- .gsd/SPEC.md
- lib/ai/gemini.ts
- lib/ai/firecrawl.ts
</context>

<tasks>

<task type="auto">
  <name>Update Schema for Sources</name>
  <files>supabase/migrations/0001_sources.sql, types/supabase.ts</files>
  <action>
    Create new SQL migration:
    - `knowledge_base_sources` table: id, chatbot_id, type (file/url), content_uri (gemini uri), source_url (original name/url), status.
    - RLS policies.
    - Update TypeScript definitions.
  </action>
  <verify>ls supabase/migrations</verify>
  <done>Schema updated for API usage</done>
</task>

<task type="auto">
  <name>Create Upload Endpoint</name>
  <files>app/api/knowledge/upload/route.ts</files>
  <action>
    POST endpoint:
    - Check Auth.
    - Parse FormData -> File.
    - Call `GeminiService.uploadFile`.
    - Insert row into `knowledge_base_sources`.
    - Return success.
  </action>
  <verify>ls app/api/knowledge/upload/route.ts</verify>
  <done>Upload API ready</done>
</task>

<task type="auto">
  <name>Create Crawl Endpoint</name>
  <files>app/api/knowledge/crawl/route.ts</files>
  <action>
    POST endpoint:
    - Check Auth.
    - Parse JSON -> URL.
    - Call `FirecrawlService.crawlWebsite`.
    - Loop results: Save as temp files -> Upload to Gemini -> Clean temp.
    - Insert rows into `knowledge_base_sources`.
    - Return success.
  </action>
  <verify>ls app/api/knowledge/crawl/route.ts</verify>
  <done>Crawl API ready</done>
</task>

</tasks>

<verification>
After all tasks, verify:
- [ ] SQL migration applied manually
- [ ] APIs build
</verification>
</file>

<file path=".gsd/phases/2/2.4-ui.md">
---
phase: 2
plan: 4
wave: 2
depends_on: [3]
files_modified:
  - app/dashboard/chatbots/[id]/page.tsx
  - components/knowledge-upload.tsx
  - components/knowledge-list.tsx
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can upload files via UI"
    - "User can enter URL to crawl"
    - "User sees list of sources"
  artifacts:
    - "Knowledge management UI components"
---

# Plan 2.4: Knowledge Base UI

<objective>
Create the Knowledge Base management interface within the Chatbot details page.
Users should be able to upload files and input URLs.

Purpose: specific instructions to user interaction.
Output: specific instructions to UI components.
</objective>

<context>
Load for context:
- .gsd/SPEC.md
</context>

<tasks>

<task type="auto">
  <name>Create Knowledge Components</name>
  <files>components/knowledge-upload.tsx, components/knowledge-list.tsx</files>
  <action>
    1. `KnowledgeUpload`: Tabs for "File Upload" (Input type=file) and "Website" (Input type=url). Calls APIs.
    2. `KnowledgeList`: Fetches `knowledge_base_sources` and displays table (Name, Type, Status).
  </action>
  <verify>ls components/knowledge-upload.tsx</verify>
  <done>Components created</done>
</task>

<task type="auto">
  <name>Create Chatbot Details Page</name>
  <files>app/dashboard/chatbots/[id]/page.tsx</files>
  <action>
    Page layout:
    - Header: Chatbot Name.
    - Section: Knowledge Base (Embed Upload & List components).
    - Fetch chatbot details and sources server-side.
  </action>
  <verify>ls app/dashboard/chatbots/[id]/page.tsx</verify>
  <done>Page assembled</done>
</task>

</tasks>

<verification>
After all tasks, verify:
- [ ] Components render
- [ ] Interactions trigger API calls
</verification>
</file>

<file path=".gsd/phases/3/3.1-api.md">
---
phase: 3
plan: 1
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/0002_chat.sql
  - types/supabase.ts
  - app/api/chat/route.ts
  - lib/ai/rag.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "New tables: conversations, messages"
    - "API returns RAG answer"
    - "API stores history"
  artifacts:
    - "app/api/chat/route.ts exists"
---

# Plan 3.1: Chat API & Architecture

<objective>
Implement the backend architecture for chatting.
1. Database Schema: `conversations` (session) and `messages` (history).
2. RAG Logic: `retrieveContext` + `generateResponse`.
3. API Endpoint: `POST /api/chat`.

Purpose: specific instructions to enable conversation.
Output: specific instructions to working Chat API.
</objective>

<context>
Load for context:
- .gsd/SPEC.md
- lib/ai/gemini.ts
</context>

<tasks>

<task type="auto">
  <name>Update Schema for Chat</name>
  <files>supabase/migrations/0002_chat.sql, types/supabase.ts</files>
  <action>
    Create new SQL migration:
    - `conversations`: id, chatbot_id, visitor_id (optional), created_at.
    - `messages`: id, conversation_id, role (user/assistant), content, created_at.
    - RLS policies (public insert allowed for public chat?). 
      - **CRITICAL**: Messages RLS must allow 'anon' to insert if they own the conversation (maybe via cookie/session ID matching?). 
      - Simplified approach: secure with Service Role in API for now, or use signed tokens.
      - Let's stick to Server Side API handling all DB Interaction, so RLS can stays strict (Users view own bots' messages).
    
    Update TypeScript definitions.
  </action>
  <verify>ls supabase/migrations</verify>
  <done>Schema updated</done>
</task>

<task type="auto">
  <name>Create RAG Logic</name>
  <files>lib/ai/rag.ts</files>
  <action>
    Implement `RAGService`:
    - `chat(chatbotId, query, history)`:
      1. Fetch chatbot config (system prompt).
      2. Fetch relevant sources (Gemini File Search handles this implicitly via Tools, do we need manual filtering?).
         - Gemini File Search works best attached to a specific Model configuration.
         - *Problem*: Gemini File Search requires uploading files *to the API* but we did that.
         - Do we need to pass *which* files to search? Yes, `tool usage` needs context.
         - *Strategy*: Retreive all `content_uri`s for the chatbot from `knowledge_base_sources`.
      3. Call `GeminiService.generateAnswer` with specific File URIs.
      4. return answer.
  </action>
  <verify>ls lib/ai/rag.ts</verify>
  <done>RAG Logic implemented</done>
</task>

<task type="auto">
  <name>Create Chat Endpoint</name>
  <files>app/api/chat/route.ts</files>
  <action>
    POST endpoint:
    - Body: { chatbotId, message, conversationId (optional) }
    - If no conversationId, create one.
    - Store User Message.
    - Call `RAGService.chat`.
    - Store Assistant Message.
    - Return { conversationId, message }.
    
    *Security*: Validate `chatbotId` exists.
  </action>
  <verify>ls app/api/chat/route.ts</verify>
  <done>Chat API ready</done>
</task>

</tasks>

<verification>
After all tasks, verify:
- [ ] SQL migration applied manually
- [ ] API responds to curl
</verification>
</file>

<file path=".gsd/phases/3/3.2-ui.md">
---
phase: 3
plan: 2
wave: 1
depends_on: [1]
files_modified:
  - app/embed/[chatbotId]/page.tsx
  - components/chat-interface.tsx
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Public URL /embed/[id] renders chat UI"
    - "Chat UI talks to /api/chat"
  artifacts:
    - "components/chat-interface.tsx exists"
---

# Plan 3.2: Embeddable Interface

<objective>
Create the public Chat UI that will be embedded inside an IFrame.
Location: `app/embed/[chatbotId]/page.tsx`.

Purpose: specific instructions to visual interface.
Output: specific instructions to working Chat UI.
</objective>

<context>
Load for context:
- .gsd/SPEC.md
</context>

<tasks>

<task type="auto">
  <name>Create Chat Component</name>
  <files>components/chat-interface.tsx</files>
  <action>
    Client Component using AI SDK `useChat` or internal state.
    - `messages` state.
    - Scroll to bottom.
    - Input area.
    - Styling (clean, maybe themable via props later).
    - Calls `/api/chat`.
  </action>
  <verify>ls components/chat-interface.tsx</verify>
  <done>Chat component created</done>
</task>

<task type="auto">
  <name>Create Embed Page</name>
  <files>app/embed/[chatbotId]/page.tsx</files>
  <action>
    Public page (not behind Dashboard layout, no Auth).
    - Renders `ChatInterface`.
    - `layout.tsx` for embed might need to be clean (no sidebar).
  </action>
  <verify>ls app/embed/[chatbotId]/page.tsx</verify>
  <done>Embed page created</done>
</task>

</tasks>

<verification>
After all tasks, verify:
- [ ] Page renders locally without login
</verification>
</file>

<file path=".gsd/phases/3/3.3-widget.md">
---
phase: 3
plan: 3
wave: 2
depends_on: [2]
files_modified:
  - public/widget.js
  - app/dashboard/chatbots/[id]/page.tsx
  - components/deployment-code.tsx
autonomous: true
user_setup: []

must_haves:
  truths:
    - "widget.js creates IFrame pointing to /embed"
    - "Dashboard shows copy-paste code"
  artifacts:
    - "public/widget.js exists"
---

# Plan 3.3: Widget Deployment

<objective>
1. Create `public/widget.js`: The "loader" script users put on their site.
2. Update Dashboard: Show the installation code.

Purpose: specific instructions to distribution.
Output: specific instructions to working widget script.
</objective>

<context>
Load for context:
- .gsd/SPEC.md
</context>

<tasks>

<task type="auto">
  <name>Create Widget Script</name>
  <files>public/widget.js</files>
  <action>
    Vanilla JS script:
    - Reads `data-chatbot-id` from script tag.
    - Creates a fixed position button (Launcher).
    - Creates an IFrame pointing to `{HOST}/embed/{chatbotId}`.
    - Toggles visibility on click.
  </action>
  <verify>ls public/widget.js</verify>
  <done>Widget script created</done>
</task>

<task type="auto">
  <name>Add Deployment Tab</name>
  <files>app/dashboard/chatbots/[id]/page.tsx, components/deployment-code.tsx</files>
  <action>
    Add a 3rd tab to Chatbot Details: "Deployment".
    Show code snippet:
    `<script src="https://.../widget.js" data-chatbot-id="..."></script>`
  </action>
  <verify>ls components/deployment-code.tsx</verify>
  <done>Deployment instructions added</done>
</task>

</tasks>

<verification>
After all tasks, verify:
- [ ] Embed code is visible
- [ ] Script works on a test html page
</verification>
</file>

<file path=".gsd/phases/4/4.1-realtime.md">
---
phase: 4
plan: 1
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/0003_realtime.sql
  - types/supabase.ts
  - hooks/use-realtime-chat.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Schema: conversations status (ai, waiting, agent, closed)"
    - "Schema: assigned_to (profile_id)"
    - "Realtime replication enabled for messages"
  artifacts:
    - "supabase/migrations/0003_realtime.sql exists"
---

# Plan 4.1: Realtime Infrastructure & Schema

<objective>
Prepare the database and client hooks for realtime human-to-human chat.
1. Update Schema: Add Hand-off states.
2. Enable Realtime in Supabase.
3. Create React Hook to subscribe to messages.

Purpose: specific instructions to infrastructure.
Output: specific instructions to schema and hooks.
</objective>

<context>
Load for context:
- .gsd/SPEC.md
</context>

<tasks>

<task type="auto">
  <name>Schema Updates</name>
  <files>supabase/migrations/0003_realtime.sql, types/supabase.ts</files>
  <action>
    Create migration:
    - Alter `conversations`:
      - Add `status` enum ('ai', 'waiting', 'active', 'closed') default 'ai'.
      - Add `assigned_to` uuid references profiles(id).
      - Add `unread_count` (integer)? Or calculate dynamically.
    - Enable Realtime:
      - `alter publication supabase_realtime add table messages;`
      - `alter publication supabase_realtime add table conversations;`
    
    Update TypeScript types.
  </action>
  <verify>ls supabase/migrations/0003_realtime.sql</verify>
  <done>Schema migration ready</done>
</task>

<task type="auto">
  <name>Realtime Hook</name>
  <files>hooks/use-realtime-chat.ts</files>
  <action>
    Create custom hook `useRealtimeChat(conversationId)`:
    - Subscribes to `messages` where `conversation_id=ID`.
    - Returns `messages` array, `sendMessage` function.
    - Handles `INSERT` events to push new message to state.
  </action>
  <verify>ls hooks/use-realtime-chat.ts</verify>
  <done>Realtime hook created</done>
</task>

</tasks>

<verification>
After all tasks, verify:
- [ ] SQL migration applied
</verification>
</file>

<file path=".gsd/phases/4/4.2-inbox.md">
---
phase: 4
plan: 2
wave: 1
depends_on: [1]
files_modified:
  - app/dashboard/inbox/page.tsx
  - app/dashboard/inbox/[id]/page.tsx
  - components/inbox-list.tsx
  - components/agent-chat-window.tsx
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Agent can see waiting conversations"
    - "Agent can join/claim a conversation"
    - "Agent can message visitor"
  artifacts:
    - "app/dashboard/inbox/page.tsx exists"
---

# Plan 4.2: Agent Inbox

<objective>
Create the Dashboard UI for agents to manage conversations.
1. Inbox List: View all chats needing attention.
2. Chat Window: Realtime chat interface for the agent.

Purpose: specific instructions to agent UI.
Output: specific instructions to working Inbox.
</objective>

<context>
Load for context:
- .gsd/SPEC.md
</context>

<tasks>

<task type="auto">
  <name>Inbox List Page</name>
  <files>app/dashboard/inbox/page.tsx, components/inbox-list.tsx</files>
  <action>
    - `InboxList`: Server Component (initial fetch) + Client (realtime subscription to 'conversations').
    - Filter by status='waiting' or 'active'.
    - Show visitor ID, last message time, status.
    - "Claim" button -> updates status to 'active' and assigned_to to Me.
  </action>
  <verify>ls app/dashboard/inbox/page.tsx</verify>
  <done>Inbox page created</done>
</task>

<task type="auto">
  <name>Agent Chat Window</name>
  <files>app/dashboard/inbox/[id]/page.tsx, components/agent-chat-window.tsx</files>
  <action>
    - `AgentChatWindow`: Uses `useRealtimeChat`.
    - Input area sends message as role='assistant'.
    - "Close Chat" button -> status='closed'.
    - "Release" button -> status='waiting'.
  </action>
  <verify>ls app/dashboard/inbox/[id]/page.tsx</verify>
  <done>Chat window created</done>
</task>

</tasks>

<verification>
After all tasks, verify:
- [ ] Agent can see chats
- [ ] Agent can reply
</verification>
</file>

<file path=".gsd/phases/4/4.3-handoff.md">
---
phase: 4
plan: 3
wave: 2
depends_on: [1]
files_modified:
  - app/api/chat/route.ts
  - components/chat-interface.tsx
  - app/embed/[chatbotId]/page.tsx
autonomous: true
user_setup: []

must_haves:
  truths:
    - "API respects handoff state (no AI reply if active)"
    - "Widget shows Agent status"
    - "User can request agent"
  artifacts:
    - "app/api/chat/route.ts modified"
---

# Plan 4.3: Handoff Logic Integration

<objective>
Connect the dots:
1. Widget allows asking for human.
2. API stops RAG when human is assigned.
3. Widget supports Realtime updates (visitor side).

Purpose: specific instructions to system logic.
Output: specific instructions to complete handoff flow.
</objective>

<context>
Load for context:
- .gsd/SPEC.md
</context>

<tasks>

<task type="auto">
  <name>Update Chat API</name>
  <files>app/api/chat/route.ts</files>
  <action>
    Modify POST /api/chat:
    - Fetch conversation.
    - IF status is 'active' or 'waiting':
      - Store user message.
      - DO NOT call RAG.
      - Return { message: null } (or status indicator).
    - ELSE (status='ai'):
      - Call RAG.
      - Return answer.
  </action>
  <verify>grep "status" app/api/chat/route.ts</verify>
  <done>API logic updated</done>
</task>

<task type="auto">
  <name>Update Widget for Realtime</name>
  <files>components/chat-interface.tsx</files>
  <action>
    - Integrate `useRealtimeChat` (or similar subscription) into the Widget.
    - Currently Widget uses `fetch`. It needs to ALSO subscribe to `messages` to receive Agent replies.
    - Logic:
      - On load: Fetch history + Subscribe to `messages`.
      - On send: Optimistic update + Fetch POST.
      - On receive (Realtime): Add to list (if ID not present).
    - Add "Request Agent" button in header. calls API/Action to set status='waiting'.
  </action>
  <verify>grep "subscribe" components/chat-interface.tsx</verify>
  <done>Widget is realtime aware</done>
</task>

</tasks>

<verification>
After all tasks, verify:
- [ ] User sends message in 'active' mode -> No AI reply
- [ ] Agent sends message -> User sees it instantly
</verification>
</file>

<file path=".gsd/phases/5/5.1-stripe.md">
---
phase: 5
plan: 1
wave: 1
depends_on: []
files_modified:
  - app/api/stripe/webhook/route.ts
  - app/api/stripe/checkout/route.ts
  - lib/stripe.ts
  - supabase/migrations/0004_stripe.sql
  - types/supabase.ts
  - middleware.ts
autonomous: true
user_setup:
  - "Add STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET, NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY to .env.local"
  - "Create Products in Stripe Dashboard (Free, Pro)"

must_haves:
  truths:
    - "Schema: organization has subscription_status, stripe_customer_id"
    - "Schema: organization has usage limits (messages_count, max_messages)"
    - "Webhook handles checkout.session.completed"
    - "Webhook handles invoice.payment_succeeded"
    - "API blocks chat if limit exceeded"
  artifacts:
    - "supabase/migrations/0004_stripe.sql exists"
---

# Plan 5.1: Stripe Integration & Usage Limits

<objective>
Implement monetization system.
1. Database: Track subscription status and usage.
2. Stripe: Checkout flow and Webhooks.
3. Enforcement: Block actions if limits exceeded.

Purpose: specific instructions to billing infrastructure.
Output: specific instructions to payment flow.
</objective>

<context>
Load for context:
- .gsd/SPEC.md
</context>

<tasks>

<task type="auto">
  <name>Schema Updates for Billing</name>
  <files>supabase/migrations/0004_stripe.sql, types/supabase.ts</files>
  <action>
    Create migration:
    - Create `products` table (id, name, description, active, metadata).
    - Create `prices` table (id, product_id, unit_amount, currency, type, interval).
    - Alter `organizations`:
      - Add `stripe_customer_id` (text).
      - Add `subscription_status` (text) default 'active' (or 'free').
      - Add `plan_id` (text).
      - Add `messages_count` (int) default 0.
      - Add `last_reset` (timestamp) default now().
    
    Update TypeScript types.
  </action>
  <verify>ls supabase/migrations/0004_stripe.sql</verify>
  <done>Billing schema ready</done>
</task>

<task type="auto">
  <name>Stripe Lib & Checkout</name>
  <files>lib/stripe.ts, app/api/stripe/checkout/route.ts</files>
  <action>
    - `lib/stripe.ts`: Initialize Stripe client.
    - `POST /api/stripe/checkout`:
      - Takes `priceId`.
      - Creates Checkout Session (mode: subscription).
      - Returns URL.
  </action>
  <verify>ls app/api/stripe/checkout/route.ts</verify>
  <done>Checkout route created</done>
</task>

<task type="auto">
  <name>Stripe Webhook</name>
  <files>app/api/stripe/webhook/route.ts</files>
  <action>
    - Handle `product.created/updated`: Upsert `products`.
    - Handle `price.created/updated`: Upsert `prices`.
    - Handle `checkout.session.completed`:
      - Update `organizations`: set `stripe_customer_id`, `subscription_status`, `plan_id`.
    - Handle `customer.subscription.deleted`:
      - Set status to 'canceled'.
  </action>
  <verify>ls app/api/stripe/webhook/route.ts</verify>
  <done>Webhook handler created</done>
</task>

<task type="auto">
  <name>Admin Product Management</name>
  <files>app/admin/products/page.tsx, components/admin/product-form.tsx, app/actions/stripe-products.ts</files>
  <action>
    - **Security**: Allow ONLY `ThomasPerdana@gmail.com`.
    - Create `app/admin/products/page.tsx`:
      - Server-side check: `if (user.email !== 'ThomasPerdana@gmail.com') return notFound()`.
      - List products from `products` table.
      - "Create New Product" button.
    - Create `app/actions/stripe-products.ts`:
      - Verify user email again in server actions.
      - `createProduct(data)`: Calls `stripe.products.create` and `stripe.prices.create`.
      - `updateProduct(id, data)`: Calls `stripe.products.update`.
      - `deleteProduct(id)`: Calls `stripe.products.update(active: false)` (Archive).
  </action>
  <verify>ls app/admin/products/page.tsx</verify>
  <done>Admin Product CRUD ready</done>
</task>

<task type="auto">
  <name>Enforce Limits</name>
  <files>app/api/chat/route.ts</files>
  <action>
    - In `POST /api/chat`:
      - Fetch org for the chatbot.
      - Check `messages_count` vs Limit (based on `plan_id` -> lookup `products` metadata or hardcoded logic).
      - If limit exceeded, return 403 "Limit Reached".
      - Else, increment `messages_count`.
  </action>
  <verify>grep "messages_count" app/api/chat/route.ts</verify>
  <done>Limits enforced</done>
</task>

</tasks>

<verification>
After all tasks, verify:
- [ ] Schema applied
- [ ] Checkout redirects to Stripe
- [ ] Webhook updates DB
- [ ] Chat increments count
</verification>
</file>

<file path=".gsd/phases/5/5.2-ui.md">
---
phase: 5
plan: 2
wave: 1
depends_on: [1]
files_modified:
  - app/dashboard/settings/page.tsx
  - components/subscription-card.tsx
  - app/api/stripe/portal/route.ts
  - app/dashboard/layout.tsx
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can view current plan and usage"
    - "User can upgrade to Pro"
    - "User can manage existing subscription (Portal)"
  artifacts:
    - "components/subscription-card.tsx exists"
---

# Plan 5.2: Subscription UI

<objective>
Allow users to Subscribe and Manage Subscriptions from the Dashboard.
1. Backend: Portal Route.
2. UI: Subscription Settings Page (or Card).
3. Integration: Connect buttons to Checkout and Portal routes.

Purpose: specific instructions to frontend billing.
Output: specific instructions to user-facing subscription management.
</objective>

<context>
Load for context:
- .gsd/SPEC.md
- app/api/stripe/checkout/route.ts
</context>

<tasks>

<task type="auto">
  <name>Stripe Customer Portal</name>
  <files>app/api/stripe/portal/route.ts</files>
  <action>
    - `POST /api/stripe/portal`:
    - Get user/org.
    - `stripe.billingPortal.sessions.create({ customer: org.stripe_customer_id })`.
    - Return URL.
  </action>
  <verify>ls app/api/stripe/portal/route.ts</verify>
  <done>Portal route created</done>
</task>

<task type="auto">
  <name>Subscription Component</name>
  <files>components/subscription-card.tsx</files>
  <action>
    - `SubscriptionCard({ org })`:
      - Display Plan: {org.subscription_status}
      - Display Usage: {org.messages_count} / {limit}
      - Actions:
        - If Free:
          - "Upgrade to Pro" button -> calls `/api/stripe/checkout` with Pro Price ID (hardcoded or prop).
        - If Active:
          - "Manage Subscription" button -> calls `/api/stripe/portal`.
  </action>
  <verify>ls components/subscription-card.tsx</verify>
  <done>Subscription Card component created</done>
</task>

<task type="auto">
  <name>Settings Page Update</name>
  <files>app/dashboard/settings/page.tsx</files>
  <action>
    - Add `SubscriptionCard` to the Settings page (create if not exists).
    - Fetch org data server-side and pass to card.
    - Note: Need a Price ID for "Pro". We'll define a constant or env var `NEXT_PUBLIC_PRO_PRICE_ID`.
  </action>
  <verify>ls app/dashboard/settings/page.tsx</verify>
  <done>Settings page updated</done>
</task>

</tasks>

<verification>
After all tasks, verify:
- [ ] Upgrade button redirects to Stripe Checkout
- [ ] Manage button redirects to Stripe Portal
- [ ] Usage bars show correct data
</verification>
</file>

<file path=".gsd/templates/architecture.md">
# Architecture

> Auto-generated by /map on <!-- date -->

## Overview

{Brief description of the system and its purpose.}

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                          USER                                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                         ‚îÇ
                         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                     COMPONENT A                               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                         ‚îÇ
                         ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                     COMPONENT B                               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## Components

### Component A
- **Purpose:** {What this component does}
- **Location:** `{path/to/component}`
- **Files:** {count} files
- **Pattern:** {architectural pattern used}

| File | Purpose | Priority |
|------|---------|----------|
| file1 | {purpose} | {high/medium/low} |
| file2 | {purpose} | {high/medium/low} |

### Component B
- **Purpose:** {What this component does}
- **Location:** `{path/to/component}`

## Data Flow

1. **User initiates action** (e.g., {example})
2. **Component A processes** {what happens}
3. **Component B receives** {what happens}
4. **Result returned** to user

## Technical Debt

- [ ] {Identified debt item 1}
- [ ] {Identified debt item 2}
- [ ] {Identified debt item 3}

## Conventions

**Naming:**
- {Convention 1}
- {Convention 2}

**Structure:**
- {Convention 1}
- {Convention 2}

---

*Last updated: <!-- date -->*
</file>

<file path=".gsd/templates/context.md">
# Context Template

Template for `.gsd/phases/{N}/CONTEXT.md` ‚Äî user's vision for a phase.

---

## File Template

```markdown
---
phase: {N}
name: {phase-name}
created: [ISO timestamp]
---

# Phase {N} Context

## Vision

{How the user imagines this phase working ‚Äî in their words}

## What's Essential

Non-negotiable aspects:

- {Essential 1}
- {Essential 2}
- {Essential 3}

## What's Flexible

Open to different implementations:

- {Flexible 1}
- {Flexible 2}

## What's Out of Scope

Explicitly NOT part of this phase:

- {Out of scope 1}
- {Out of scope 2}

## User Expectations

### Look and Feel
{How it should appear/behave}

### Performance
{Speed/responsiveness expectations}

### Integration
{How it fits with existing work}

## Examples / Inspiration

{Any examples the user referenced}

## Questions Answered

Clarifications from /discuss-phase:

| Question | Answer |
|----------|--------|
| {question} | {answer} |

## Constraints

Technical or business constraints:

- {Constraint 1}
- {Constraint 2}
```

---

## When to Create

Created by `/discuss-phase` to capture user's vision before planning.

## How to Use

- Planner reads CONTEXT.md to understand intent
- Executor honors the vision during implementation
- Verifier checks against user expectations

## Guidelines

- Capture user's words, not AI interpretation
- Focus on WHAT, not HOW
- Keep it short ‚Äî vision, not specification
</file>

<file path=".gsd/templates/DEBUG.md">
# Debug Template

Template for `.gsd/debug/[slug].md` ‚Äî active debug session tracking.

---

## File Template

```markdown
---
status: gathering | investigating | fixing | verifying | resolved
trigger: "[verbatim user input]"
created: [ISO timestamp]
updated: [ISO timestamp]
---

## Current Focus
<!-- OVERWRITE on each update - always reflects NOW -->

hypothesis: [current theory being tested]
test: [how testing it]
expecting: [what result means if true/false]
next_action: [immediate next step]

## Symptoms
<!-- Written during gathering, then immutable -->

expected: [what should happen]
actual: [what actually happens]
errors: [error messages if any]
reproduction: [how to trigger]
started: [when it broke / always broken]

## Eliminated
<!-- APPEND only - prevents re-investigating after context reset -->

- hypothesis: [theory that was wrong]
  evidence: [what disproved it]
  timestamp: [when eliminated]

## Evidence
<!-- APPEND only - facts discovered during investigation -->

- timestamp: [when found]
  checked: [what was examined]
  found: [what was observed]
  implication: [what this means]

## Resolution
<!-- OVERWRITE as understanding evolves -->

root_cause: [empty until found]
fix: [empty until applied]
verification: [empty until verified]
files_changed: []
```

---

## Section Rules

**Frontmatter (status, trigger, timestamps):**
- `status`: OVERWRITE - reflects current phase
- `trigger`: IMMUTABLE - verbatim user input, never changes
- `created`: IMMUTABLE - set once
- `updated`: OVERWRITE - update on every change

**Current Focus:**
- OVERWRITE entirely on each update
- Always reflects what AI is doing RIGHT NOW
- If AI reads this after session reset, it knows exactly where to resume
- Fields: hypothesis, test, expecting, next_action

**Symptoms:**
- Written during initial gathering phase
- IMMUTABLE after gathering complete
- Reference point for what we're trying to fix

**Eliminated:**
- APPEND only - never remove entries
- Prevents re-investigating dead ends after context reset
- Critical for efficiency across session boundaries

**Evidence:**
- APPEND only - never remove entries
- Facts discovered during investigation
- Builds the case for root cause

**Resolution:**
- OVERWRITE as understanding evolves
- Final state shows confirmed root cause and verified fix

---

## Lifecycle

**Creation:** When /debug is called
- Create file with trigger from user input
- Set status to "gathering"
- next_action = "gather symptoms"

**During investigation:**
- OVERWRITE Current Focus with each hypothesis
- APPEND to Evidence with each finding
- APPEND to Eliminated when hypothesis disproved

**On resolution:**
- status ‚Üí "resolved"
- Move file to .gsd/debug/resolved/

---

## Resume Behavior

When AI reads this file after session reset:

1. Parse frontmatter ‚Üí know status
2. Read Current Focus ‚Üí know exactly what was happening
3. Read Eliminated ‚Üí know what NOT to retry
4. Read Evidence ‚Üí know what's been learned
5. Continue from next_action

The file IS the debugging brain.
</file>

<file path=".gsd/templates/decisions.md">
# DECISIONS.md ‚Äî Architecture Decision Records

> **Purpose**: Log significant technical decisions and their rationale.

## Template

```markdown
## [DECISION-XXX] Title

**Date**: YYYY-MM-DD
**Status**: Proposed | Accepted | Deprecated | Superseded

### Context
What is the issue we're facing?

### Decision
What have we decided to do?

### Rationale
Why did we make this decision?

### Consequences
What are the trade-offs?

### Alternatives Considered
What other options were evaluated?
```

---

## Decisions

<!-- Add new decisions below -->

---

*Last updated: <!-- date -->*
</file>

<file path=".gsd/templates/discovery.md">
# Discovery Template

Template for `.gsd/phases/{N}/DISCOVERY.md` ‚Äî shallow research for library/option decisions.

**Purpose:** Answer "which library/option should we use" questions during planning.

For deep ecosystem research, use `/research-phase` which produces RESEARCH.md.

---

## File Template

```markdown
---
phase: {N}
type: discovery
topic: [discovery-topic]
---

<discovery_objective>
Discover [topic] to inform [phase name] implementation.

Purpose: [What decision/implementation this enables]
Scope: [Boundaries]
Output: DISCOVERY.md with recommendation
</discovery_objective>

<discovery_scope>
<include>
- [Question to answer]
- [Area to investigate]
- [Specific comparison if needed]
</include>

<exclude>
- [Out of scope for this discovery]
- [Defer to implementation phase]
</exclude>
</discovery_scope>

<discovery_protocol>

**Source Priority:**
1. **Official Docs** ‚Äî Authoritative, current
2. **Web Search** ‚Äî For comparisons, trends (verify findings)
3. **GitHub** ‚Äî For real usage patterns

**Quality Checklist:**
- [ ] All claims have authoritative sources
- [ ] Negative claims verified with official docs
- [ ] Alternative approaches considered
- [ ] Recent updates checked for breaking changes

**Confidence Levels:**
- HIGH: Official docs confirm
- MEDIUM: Multiple sources confirm
- LOW: Single source or training knowledge only

</discovery_protocol>
```

---

## Output Structure

Create `.gsd/phases/{N}/DISCOVERY.md`:

```markdown
# [Topic] Discovery

## Summary
[2-3 paragraph executive summary]

## Primary Recommendation
[What to do and why ‚Äî specific and actionable]

## Alternatives Considered
[What else was evaluated and why not chosen]

## Key Findings

### [Category 1]
- [Finding with source URL]

### [Category 2]
- [Finding with relevance]

## Code Examples
[Relevant patterns if applicable]

## Metadata

<confidence level="high|medium|low">
[Why this confidence level]
</confidence>

<sources>
- [Primary sources used]
</sources>

<open_questions>
[What needs validation during implementation]
</open_questions>
```

---

## When to Use

**Use discovery when:**
- Technology choice unclear (library A vs B)
- Best practices needed for unfamiliar integration
- API/library investigation required

**Don't use when:**
- Established patterns (CRUD, auth with known library)
- Questions answerable from project context

**Use RESEARCH.md instead when:**
- Niche/complex domains (3D, games, audio)
- Need ecosystem knowledge, not just library choice
- "How do experts build this" questions
</file>

<file path=".gsd/templates/journal.md">
# JOURNAL.md ‚Äî Session Log

> **Purpose**: Chronicle of work sessions for context continuity.

---

## Sessions

## Session: YYYY-MM-DD HH:MM

### Objective
{What you set out to accomplish this session.}

### Accomplished
- ‚úÖ {Task 1 completed}
- ‚úÖ {Task 2 completed}
  - {Sub-detail if needed}
- ‚úÖ {Task 3 completed}

### Verification
- [x] {Verification check 1}
- [x] {Verification check 2}
- [ ] {Verification pending}

### Blockers Encountered
- {Blocker 1 and how it was resolved}
- {Blocker 2 ‚Äî still open}

### Handoff Notes
- {Important context for next session}
- {Files that need attention}
- {Decisions that need to be made}

---

## Session: YYYY-MM-DD HH:MM

### Objective
{Previous session objective.}

### Accomplished
- ‚úÖ {Completed items}

---

*Last updated: <!-- date -->*
</file>

<file path=".gsd/templates/milestone.md">
# Milestone Template

Template for `.gsd/milestones/{name}/MILESTONE.md` ‚Äî milestone definition and tracking.

---

## File Template

```markdown
---
name: {milestone-name}
version: {semantic version, e.g., v1.0}
status: planning | active | complete | archived
created: [ISO timestamp]
target_date: [optional target]
---

# Milestone: {name}

## Vision

{What this milestone achieves ‚Äî one paragraph}

## Must-Haves

Non-negotiable deliverables for this milestone:

- [ ] {Must-have 1}
- [ ] {Must-have 2}
- [ ] {Must-have 3}

## Nice-to-Haves

If time permits:

- [ ] {Nice-to-have 1}
- [ ] {Nice-to-have 2}

## Phases

| Phase | Name | Status | Objective |
|-------|------|--------|-----------|
| 1 | {name} | ‚¨ú Not Started | {objective} |
| 2 | {name} | ‚¨ú Not Started | {objective} |
| 3 | {name} | ‚¨ú Not Started | {objective} |

## Success Criteria

How we know milestone is complete:

- [ ] {Measurable criterion 1}
- [ ] {Measurable criterion 2}

## Architecture Decisions

Key technical decisions for this milestone:

| Decision | Choice | Rationale |
|----------|--------|-----------|
| {decision} | {choice} | {why} |

## Risks

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| {risk} | Low/Med/High | Low/Med/High | {action} |

## Progress Log

| Date | Event | Notes |
|------|-------|-------|
| {date} | Milestone started | ‚Äî |
```

---

## Lifecycle

1. **Creation:** `/new-milestone` creates this file
2. **Active:** Updated as phases complete
3. **Complete:** `/complete-milestone` moves to archive
4. **Archived:** Read-only reference

---

## Guidelines

- One active milestone at a time
- 3-5 phases per milestone
- Must-haves should be testable
- Success criteria should be measurable
</file>

<file path=".gsd/templates/phase-summary.md">
# Phase {N} Summary

> **Status**: Complete
> **Completed**: YYYY-MM-DD

## Objective
{What this phase set out to accomplish.}

## Deliverables

| Deliverable | Status | Notes |
|-------------|--------|-------|
| {Deliverable 1} | ‚úÖ | {Any relevant notes} |
| {Deliverable 2} | ‚úÖ | {Any relevant notes} |
| {Deliverable 3} | ‚úÖ | {Any relevant notes} |

## Tasks Completed

### Plan {N}.1: {Plan Name}
- [x] {Task 1}
- [x] {Task 2}

### Plan {N}.2: {Plan Name}
- [x] {Task 1}
- [x] {Task 2}

## Verification Results

| Check | Result | Evidence |
|-------|--------|----------|
| {Verification 1} | ‚úÖ Pass | {Command output / screenshot path} |
| {Verification 2} | ‚úÖ Pass | {Command output / screenshot path} |

## Commits

| Hash | Message |
|------|---------|
| `abc123` | feat(phase-N): {description} |
| `def456` | feat(phase-N): {description} |

## Lessons Learned
- {What went well}
- {What could be improved}
- {Unexpected discoveries}

## Next Steps
- {What the next phase should address}
- {Any deferred items}

---

*Completed: YYYY-MM-DD*
</file>

<file path=".gsd/templates/PLAN.md">
# PLAN.md Template

> Copy this template when creating execution plans.

```markdown
---
phase: {N}
plan: {M}
wave: {W}
gap_closure: false
---

# Plan {N}.{M}: {Descriptive Name}

## Objective
{One paragraph explaining what this plan delivers and why it matters}

## Context
Load these files for context:
- .gsd/SPEC.md
- .gsd/ARCHITECTURE.md
- {relevant source files}

## Tasks

<task type="auto">
  <name>{Clear, specific task name}</name>
  <files>
    {exact/file/path1.ext}
    {exact/file/path2.ext}
  </files>
  <action>
    {Specific implementation instructions}
    
    Steps:
    1. {Step 1}
    2. {Step 2}
    3. {Step 3}
    
    AVOID: {common mistake} because {reason}
    USE: {preferred approach} because {reason}
  </action>
  <verify>
    {Executable command or check}
    Example: npm test -- --testNamePattern="auth"
    Example: curl -X POST localhost:3000/api/login
  </verify>
  <done>
    {Measurable acceptance criteria}
    Example: Valid credentials ‚Üí 200 + Set-Cookie, invalid ‚Üí 401
  </done>
</task>

<task type="auto">
  <name>{Task 2 name}</name>
  <files>{files}</files>
  <action>{instructions}</action>
  <verify>{command}</verify>
  <done>{criteria}</done>
</task>

## Must-Haves
After all tasks complete, verify:
- [ ] {Must-have 1 ‚Äî derived from phase goal}
- [ ] {Must-have 2}

## Success Criteria
- [ ] All tasks verified passing
- [ ] Must-haves confirmed
- [ ] No regressions in tests
```

## Task Types

| Type | Use For | Behavior |
|------|---------|----------|
| `auto` | Everything Claude can do independently | Fully autonomous |
| `checkpoint:human-verify` | Visual/functional verification | Pauses for user |
| `checkpoint:decision` | Implementation choices | Pauses for user |

## Wave Assignment

| Wave | Use For |
|------|---------|
| 1 | Foundation (types, schemas, utilities) |
| 2 | Core implementations |
| 3 | Integration and validation |

Plans in the same wave can run in parallel.
Later waves depend on earlier waves.
</file>

<file path=".gsd/templates/project.md">
# Project Template

Template for `.gsd/SPEC.md` (or PROJECT.md) ‚Äî project specification.

---

## File Template

```markdown
---
status: DRAFT | FINALIZED
created: [ISO timestamp]
finalized: [ISO timestamp when status changed]
---

# SPEC.md ‚Äî Project Specification

## Vision

{One paragraph describing what this project is and why it matters}

---

## Goals

1. **{Primary Goal}**
   {Brief description}

2. **{Secondary Goal}**
   {Brief description}

3. **{Tertiary Goal}**
   {Brief description}

---

## Non-Goals (Out of Scope)

Explicitly NOT part of this project:

- {Non-goal 1}
- {Non-goal 2}
- {Non-goal 3}

---

## Users

**Primary User:** {Who}
- {How they'll use it}
- {What they need}

**Secondary User:** {Who} (if applicable)
- {How they'll use it}

---

## Constraints

### Technical
- {Technical constraint 1}
- {Technical constraint 2}

### Timeline
- {Timeline constraint}

### Other
- {Budget, resources, etc.}

---

## Success Criteria

How we know the project is successful:

- [ ] {Measurable outcome 1}
- [ ] {Measurable outcome 2}
- [ ] {Measurable outcome 3}

---

## Prior Art

Existing solutions or inspiration:

| Solution | Pros | Cons | Relevance |
|----------|------|------|-----------|
| {solution} | {pros} | {cons} | {how it relates} |

---

## Open Questions

Questions to resolve during planning:

- [ ] {Question 1}
- [ ] {Question 2}

---

## Decisions

Key decisions made during specification:

| Decision | Choice | Rationale | Date |
|----------|--------|-----------|------|
| {decision} | {choice} | {why} | {date} |
```

---

## Status Flow

1. **DRAFT** ‚Äî Being written, not ready for planning
2. **FINALIZED** ‚Äî Approved, planning can begin

**Planning Lock:** Cannot create plans until status is FINALIZED.

## Guidelines

- Keep vision to one paragraph
- Goals should be achievable in one milestone
- Non-goals are as important as goals
- Success criteria must be measurable
</file>

<file path=".gsd/templates/requirements.md">
# Requirements Template

Template for `.gsd/REQUIREMENTS.md` ‚Äî formal requirements tracking with traceability.

---

## File Template

```markdown
---
milestone: {name}
updated: [ISO timestamp]
---

# Requirements

## Overview

Requirements derived from SPEC.md for traceability and coverage tracking.

---

## Functional Requirements

| ID | Requirement | Source | Phase | Status |
|----|-------------|--------|-------|--------|
| REQ-01 | {requirement description} | SPEC Goal 1 | 1 | Pending |
| REQ-02 | {requirement description} | SPEC Goal 1 | 1 | Pending |
| REQ-03 | {requirement description} | SPEC Goal 2 | 2 | Pending |
| REQ-04 | {requirement description} | SPEC Goal 2 | 2 | Pending |
| REQ-05 | {requirement description} | SPEC Goal 3 | 3 | Pending |

---

## Non-Functional Requirements

| ID | Requirement | Category | Phase | Status |
|----|-------------|----------|-------|--------|
| NFR-01 | Response time < 200ms | Performance | 4 | Pending |
| NFR-02 | Mobile responsive | UX | All | Pending |
| NFR-03 | 99% uptime | Reliability | 4 | Pending |

---

## Constraints

| ID | Constraint | Source | Impact |
|----|------------|--------|--------|
| CON-01 | {constraint} | SPEC | {affected areas} |
| CON-02 | {constraint} | Technical | {affected areas} |

---

## Traceability Matrix

| Requirement | Plans | Tests | Status |
|-------------|-------|-------|--------|
| REQ-01 | 1.1, 1.2 | TC-01 | ‚Äî |
| REQ-02 | 1.2 | TC-02, TC-03 | ‚Äî |
| REQ-03 | 2.1 | TC-04 | ‚Äî |

---

## Status Definitions

| Status | Meaning |
|--------|---------|
| Pending | Not yet started |
| In Progress | Being implemented |
| Complete | Implemented and verified |
| Blocked | Cannot proceed |
| Deferred | Moved to later milestone |
```

---

## Guidelines

**Requirement IDs:**
- REQ-XX: Functional requirements
- NFR-XX: Non-functional requirements
- CON-XX: Constraints

**Good requirements are:**
- Testable
- Specific
- Traceable to SPEC goals

**Update when:**
- Phase completes (mark requirements satisfied)
- Scope changes (add/defer requirements)
- Verification passes (update status)
</file>

<file path=".gsd/templates/RESEARCH.md">
# RESEARCH.md Template

> Copy this template when documenting phase research.

```markdown
---
phase: {N}
researched_at: {YYYY-MM-DD}
discovery_level: 1 | 2 | 3
---

# Phase {N} Research

## Objective
{What question is this research answering?}

## Discovery Level
**Level {1|2|3}** ‚Äî {Quick verification | Standard research | Deep dive}

## Key Decisions

### Decision 1: {Topic}
**Question:** {What needed to be decided?}
**Options Considered:**
1. {Option A}: {pros/cons}
2. {Option B}: {pros/cons}
3. {Option C}: {pros/cons}

**Decision:** {Which option and why}
**Confidence:** {High | Medium | Low}

### Decision 2: {Topic}
...

## Findings

### {Topic 1}
{What was learned}

**Sources:**
- {URL or reference}
- {URL or reference}

### {Topic 2}
{What was learned}

## Patterns to Follow
- {Pattern 1}: {How to apply it}
- {Pattern 2}: {How to apply it}

## Anti-Patterns to Avoid
- {Anti-pattern 1}: {Why to avoid}
- {Anti-pattern 2}: {Why to avoid}

## Dependencies Identified
| Package | Version | Purpose |
|---------|---------|---------|
| {pkg} | {ver} | {why needed} |

## Risks
- **{Risk 1}:** {Impact and mitigation}
- **{Risk 2}:** {Impact and mitigation}

## Recommendations for Planning
1. {Recommendation 1}
2. {Recommendation 2}
```

## Discovery Levels

| Level | Time | Use When |
|-------|------|----------|
| 1 | 2-5 min | Single known library, confirming syntax |
| 2 | 15-30 min | Choosing between options, new integration |
| 3 | 1+ hour | Architectural decision, novel problem |
</file>

<file path=".gsd/templates/roadmap.md">
# Roadmap Template

Template for `.gsd/ROADMAP.md` ‚Äî phase structure and progress tracking.

---

## File Template

```markdown
---
milestone: {name}
version: {semantic version}
updated: [ISO timestamp]
---

# Roadmap

> **Current Phase:** {N} - {name}
> **Status:** {planning | executing | verifying}

## Must-Haves (from SPEC)

- [ ] {Must-have 1}
- [ ] {Must-have 2}
- [ ] {Must-have 3}

---

## Phases

### Phase 1: {Foundation}
**Status:** ‚¨ú Not Started | üîÑ In Progress | ‚úÖ Complete
**Objective:** {What this phase delivers}
**Requirements:** REQ-01, REQ-02

**Plans:**
- [ ] Plan 1.1: {name}
- [ ] Plan 1.2: {name}

---

### Phase 2: {Core Feature}
**Status:** ‚¨ú Not Started
**Objective:** {What this phase delivers}
**Depends on:** Phase 1

**Plans:**
- [ ] Plan 2.1: {name}
- [ ] Plan 2.2: {name}

---

### Phase 3: {Integration}
**Status:** ‚¨ú Not Started
**Objective:** {What this phase delivers}
**Depends on:** Phase 2

---

### Phase 4: {Polish/Launch}
**Status:** ‚¨ú Not Started
**Objective:** {Final touches and deployment}
**Depends on:** Phase 3

---

## Progress Summary

| Phase | Status | Plans | Complete |
|-------|--------|-------|----------|
| 1 | ‚¨ú | 0/2 | ‚Äî |
| 2 | ‚¨ú | 0/2 | ‚Äî |
| 3 | ‚¨ú | 0/1 | ‚Äî |
| 4 | ‚¨ú | 0/1 | ‚Äî |

---

## Timeline

| Phase | Started | Completed | Duration |
|-------|---------|-----------|----------|
| 1 | ‚Äî | ‚Äî | ‚Äî |
| 2 | ‚Äî | ‚Äî | ‚Äî |
| 3 | ‚Äî | ‚Äî | ‚Äî |
| 4 | ‚Äî | ‚Äî | ‚Äî |
```

---

## Status Icons

- ‚¨ú Not Started
- üîÑ In Progress
- ‚úÖ Complete
- ‚è∏Ô∏è Paused
- ‚ùå Blocked

## Guidelines

- 3-5 phases per milestone
- Each phase has clear deliverable
- Dependencies flow forward
- Update status as work progresses
</file>

<file path=".gsd/templates/spec.md">
# SPEC.md ‚Äî Project Specification

> **Status**: `DRAFT` | `FINALIZED`
>
> ‚ö†Ô∏è **Planning Lock**: No code may be written until this spec is marked `FINALIZED`.

## Vision
{One paragraph describing what this project is and why it exists.}

## Goals
1. **{Goal 1}** ‚Äî {Brief description}
2. **{Goal 2}** ‚Äî {Brief description}
3. **{Goal 3}** ‚Äî {Brief description}

## Non-Goals (Out of Scope)
- {What this project explicitly will NOT do}
- {Features that are intentionally excluded}
- {Scope boundaries}

## Constraints
- {Technical constraint 1}
- {Business constraint 1}
- {Timeline constraint 1}

## Success Criteria
- [ ] {Measurable outcome 1}
- [ ] {Measurable outcome 2}
- [ ] {Measurable outcome 3}
- [ ] {Measurable outcome 4}

## User Stories (Optional)

### As a {user type}
- I want to {action}
- So that {benefit}

### As a {user type}
- I want to {action}
- So that {benefit}

## Technical Requirements (Optional)

| Requirement | Priority | Notes |
|-------------|----------|-------|
| {Requirement 1} | Must-have | {Details} |
| {Requirement 2} | Should-have | {Details} |
| {Requirement 3} | Nice-to-have | {Details} |

---

*Last updated: <!-- date -->*
</file>

<file path=".gsd/templates/sprint.md">
# Sprint {N} ‚Äî {Sprint Name}

> **Duration**: YYYY-MM-DD to YYYY-MM-DD
> **Status**: In Progress | Complete

## Goal
{One sentence describing what this sprint aims to achieve.}

## Scope

### Included
- {Feature/task 1}
- {Feature/task 2}
- {Feature/task 3}

### Explicitly Excluded
- {Out of scope item 1}
- {Out of scope item 2}

## Tasks

| Task | Assignee | Status | Est. Hours |
|------|----------|--------|------------|
| {Task 1} | {who} | ‚¨ú Todo | {hours} |
| {Task 2} | {who} | üîÑ In Progress | {hours} |
| {Task 3} | {who} | ‚úÖ Done | {hours} |

## Daily Log

### Day 1 (YYYY-MM-DD)
- {What was accomplished}
- {Blockers encountered}

### Day 2 (YYYY-MM-DD)
- {What was accomplished}
- {Blockers encountered}

## Risks & Blockers

| Risk | Impact | Mitigation |
|------|--------|------------|
| {Risk 1} | {High/Med/Low} | {What can be done} |

## Retrospective (end of sprint)

### What Went Well
- {Positive outcome 1}

### What Could Improve
- {Area for improvement 1}

### Action Items
- [ ] {Action to take in next sprint}

---

*Last updated: <!-- date -->*
</file>

<file path=".gsd/templates/stack.md">
# Technology Stack

> Auto-generated by /map on <!-- date -->

## Runtime

| Technology | Version | Purpose |
|------------|---------|---------|
| {Language} | {version} | {purpose} |
| {Framework} | {version} | {purpose} |
| {Database} | {version} | {purpose} |

## Core Technologies

### {Category 1}
| Feature | System | Purpose |
|---------|--------|---------|
| {Feature} | {System/Location} | {Purpose} |

### {Category 2}
| Directory | Files | Purpose |
|-----------|-------|---------|
| `{path}` | {count} | {purpose} |

## Dependencies

### External Dependencies

| Package | Version | Purpose |
|---------|---------|---------|
| {package} | {version} | {purpose} |

### Internal Dependencies

| Component | Depends On | Purpose |
|-----------|------------|---------|
| {Component A} | {Component B} | {Why dependency exists} |

## Infrastructure

| Service | Provider | Purpose |
|---------|----------|---------|
| {Service} | {Provider} | {Purpose} |

**Repository:** {repository URL}

## Configuration

| Variable | Purpose | Location |
|----------|---------|----------|
| {VAR_NAME} | {What it controls} | {Where it's set} |

## File Size Inventory

| Category | Count | Total Lines (approx) |
|----------|-------|---------------------|
| {Category} | {count} | {lines} |
| **Total** | **{total}** | **{total_lines}** |

---

*Last updated: <!-- date -->*
</file>

<file path=".gsd/templates/state.md">
# State Template

Template for `.gsd/STATE.md` ‚Äî project memory across sessions.

---

## File Template

```markdown
---
updated: [ISO timestamp]
---

# Project State

## Current Position

**Milestone:** {name}
**Phase:** {N} - {name}
**Status:** {planning | executing | verifying | blocked}
**Plan:** {current plan if executing}

## Last Action

{What was just completed}

## Next Steps

1. {Immediate next action}
2. {Following action}
3. {Third action if known}

## Active Decisions

Decisions made that affect current work:

| Decision | Choice | Made | Affects |
|----------|--------|------|---------|
| {what} | {choice} | {date} | {phases/plans} |

## Blockers

{None if clear}

- [ ] {Blocker 1}: {resolution approach}
- [ ] {Blocker 2}: {resolution approach}

## Concerns

Things to watch but not blocking:

- {Concern 1}
- {Concern 2}

## Session Context

{Any context the next session needs to know}
```

---

## Update Rules

**Update STATE.md after:**
- Every completed task
- Every decision made
- Any blocker identified
- Session end/pause

**What to update:**
- `updated` timestamp
- Current Position
- Last Action
- Next Steps

**Keep it lean:**
- STATE.md is read frequently
- Only current context, not history
- History goes in JOURNAL.md

---

## Resume Protocol

When starting a new session:

1. Read STATE.md first
2. Understand current position
3. Check blockers/concerns
4. Continue from Next Steps

The STATE.md is the "save game" for the project.
</file>

<file path=".gsd/templates/SUMMARY.md">
# Summary Template

Template for `.gsd/phases/{N}/{plan}-SUMMARY.md` ‚Äî execution summary after plan completion.

---

## File Template

```markdown
---
phase: {N}
plan: {M}
completed_at: [ISO timestamp]
duration_minutes: {N}
status: complete | partial | failed
---

# Summary: {Plan Name}

## Results

- **Tasks:** {N}/{M} completed
- **Commits:** {N}
- **Verification:** {passed | failed}

---

## Tasks Completed

| Task | Description | Commit | Status |
|------|-------------|--------|--------|
| 1 | {task name} | {hash} | ‚úÖ Complete |
| 2 | {task name} | {hash} | ‚úÖ Complete |
| 3 | {task name} | ‚Äî | ‚ùå Blocked |

---

## Files Changed

| File | Change Type | Description |
|------|-------------|-------------|
| {path} | Created | {what it does} |
| {path} | Modified | {what changed} |
| {path} | Deleted | {why removed} |

---

## Deviations Applied

{If none: "None ‚Äî executed as planned."}

### Rule 1 ‚Äî Bug Fixes
- {description of bug fixed}

### Rule 2 ‚Äî Missing Critical
- {description of functionality added}

### Rule 3 ‚Äî Blocking Issues
- {description of blocker fixed}

---

## Verification

| Check | Status | Evidence |
|-------|--------|----------|
| {verification 1} | ‚úÖ Pass | {command/output} |
| {verification 2} | ‚úÖ Pass | {command/output} |

---

## Notes

{Any observations, concerns, or recommendations for future phases}

---

## Metadata

- **Started:** {timestamp}
- **Completed:** {timestamp}
- **Duration:** {N} minutes
- **Context Usage:** ~{N}%
```

---

## Guidelines

**Create SUMMARY.md:**
- After each plan completes
- Before moving to next plan
- Even if plan failed (document what happened)

**Include:**
- All commits with hashes
- All deviations (never hide these)
- Verification results with evidence

**Keep it factual:**
- No opinions
- Just what happened
- Evidence over claims
</file>

<file path=".gsd/templates/todo.md">
# TODO.md ‚Äî Pending Items

> Quick capture of ideas, tasks, and issues.
>
> Use `/add-todo` to add items, `/check-todos` to view.

## Format

```markdown
- [ ] Description `priority` ‚Äî YYYY-MM-DD
- [x] Completed item `priority` ‚Äî YYYY-MM-DD ‚úì YYYY-MM-DD
```

## Priority Levels

| Level | Use For |
|-------|---------|
| `high` üî¥ | Blocking issues, urgent fixes |
| `medium` üü° | Normal priority (default) |
| `low` üü¢ | Nice-to-have, future ideas |

---

## Items

<!-- Active todos below -->

- [ ] {Example todo item} `medium` ‚Äî YYYY-MM-DD

---

*Last updated: <!-- date -->*
</file>

<file path=".gsd/templates/UAT.md">
# UAT Template

Template for `.gsd/phases/{N}/UAT.md` ‚Äî User Acceptance Testing checklist.

**Purpose:** Structured manual testing protocol for human verification checkpoints.

---

## File Template

```markdown
---
phase: {N}
type: uat
created: [ISO timestamp]
status: pending | in_progress | passed | failed
---

# Phase {N} UAT

## Overview

**Phase:** {name}
**Goal:** {what this phase delivers}
**Tester:** User
**Date:** {date}

---

## Test Environment

**Setup Required:**
- [ ] Dev server running (`npm run dev`)
- [ ] Database seeded with test data
- [ ] Browser dev tools open for error monitoring

**Test Data:**
- User: test@example.com / password123
- Other relevant test accounts/data

---

## Test Cases

### TC-01: {Test Case Name}

**Scenario:** {What user is trying to do}

**Steps:**
1. {Step 1}
2. {Step 2}
3. {Step 3}

**Expected Result:**
- {What should happen}

**Actual Result:**
- [ ] PASS
- [ ] FAIL ‚Äî Issue: ___

---

### TC-02: {Test Case Name}

**Scenario:** {What user is trying to do}

**Steps:**
1. {Step 1}
2. {Step 2}

**Expected Result:**
- {What should happen}

**Actual Result:**
- [ ] PASS
- [ ] FAIL ‚Äî Issue: ___

---

## Edge Cases

### EC-01: {Edge Case Name}

**Test:** {What to try}
**Expected:** {Graceful handling}
**Result:** [ ] PASS  [ ] FAIL

---

## Error Scenarios

### ERR-01: {Error Scenario}

**Trigger:** {How to cause error}
**Expected Behavior:** {Error message, recovery}
**Result:** [ ] PASS  [ ] FAIL

---

## Visual Verification

### VIS-01: Layout

- [ ] Responsive on mobile (375px)
- [ ] Responsive on tablet (768px)
- [ ] Desktop layout correct (1024px+)
- [ ] No horizontal scroll
- [ ] All text readable

### VIS-02: Styling

- [ ] Colors match design system
- [ ] Fonts correct
- [ ] Spacing consistent
- [ ] Icons display correctly

---

## Summary

| Category | Pass | Fail | Total |
|----------|------|------|-------|
| Functional | | | |
| Edge Cases | | | |
| Errors | | | |
| Visual | | | |

**Overall Status:** [ ] APPROVED  [ ] NEEDS FIXES

**Issues Found:**
1. {Issue description}
2. {Issue description}

**Notes:**
{Any additional observations}
```

---

## Usage Guidelines

**When to create UAT:**
- After phase execution complete
- Before marking phase as verified
- For any `checkpoint:human-verify` tasks

**Who runs UAT:**
- User (always)
- AI cannot verify visual/UX elements

**After UAT:**
- If PASSED: Phase can be marked complete
- If FAILED: Create gap closure plans with `/plan-milestone-gaps`

---

## Test Case Guidelines

**Good test cases:**
- Specific, reproducible steps
- Clear expected results
- One scenario per test case

**Categories to cover:**
1. Happy path (main functionality)
2. Edge cases (boundary conditions)
3. Error handling (invalid input, failures)
4. Visual/UX (layout, responsiveness)
</file>

<file path=".gsd/templates/user-setup.md">
# User Setup Template

Template for user setup instructions when external services are needed.

---

## File Template

```markdown
---
phase: {N}
plan: {M}
type: user-setup
---

# User Setup Required

## Overview

This plan requires manual setup that the AI cannot perform.

**Time estimate:** {X minutes}
**Blocking:** Plan cannot proceed until complete

---

## Setup Steps

### 1. {Service Name}

**Why needed:** {Purpose in the project}

**Create account:**
- Go to: {URL}
- Sign up with: {recommendations}

**Get credentials:**
1. Navigate to: {dashboard location}
2. Find: {API keys section}
3. Create: {what to create}

**Add to project:**
```powershell
# Add to .env.local
{ENV_VAR}=your_key_here
```

**Verify:**
```powershell
# Test the connection
{verification command}
```

---

### 2. {Another Service}

**Why needed:** {Purpose}

**Steps:**
1. {Step 1}
2. {Step 2}
3. {Step 3}

**Environment variables:**
```
{VAR_1}=value
{VAR_2}=value
```

---

## Dashboard Configuration

Some things require manual dashboard setup:

| Service | Task | Location | Notes |
|---------|------|----------|-------|
| {service} | {task} | {where} | {notes} |

---

## Verification Checklist

Before continuing, verify:

- [ ] All environment variables set
- [ ] All accounts created
- [ ] All dashboard configurations complete
- [ ] Verification commands pass

---

## When Complete

Type "done" or "setup complete" to continue with execution.
```

---

## Guidelines

**Include only what AI cannot do:**
- Account creation (requires human identity)
- Secret retrieval (protected behind login)
- Dashboard configuration (no API available)
- Payment method setup
- 2FA enrollment

**Do NOT include:**
- npm install (AI can do)
- File creation (AI can do)
- Configuration file edits (AI can do)
- API calls (AI can do)

**Keep minimal** ‚Äî every manual step slows down execution.
</file>

<file path=".gsd/templates/VERIFICATION.md">
# VERIFICATION.md Template

> Copy this template when creating phase verification reports.

```markdown
---
phase: {N}
verified_at: {YYYY-MM-DD HH:MM}
verdict: PASS | FAIL | PARTIAL
pass_count: {X}
total_count: {Y}
---

# Phase {N} Verification Report

## Summary

**{X}/{Y}** must-haves verified
**Verdict:** {PASS | FAIL | PARTIAL}

## Must-Haves

### ‚úÖ 1. {Must-have description}
**Status:** PASS
**Method:** {How this was verified}
**Evidence:**
```
{Actual command output or screenshot reference}
```

### ‚ùå 2. {Must-have description}
**Status:** FAIL
**Method:** {How this was verified}
**Expected:** {What should happen}
**Actual:** {What actually happened}
**Evidence:**
```
{Actual command output}
```
**Gap:** {What needs to be fixed}

### ‚è≠Ô∏è 3. {Must-have description}
**Status:** SKIPPED
**Reason:** {Why this couldn't be verified}

## Gap Closure Required

{If verdict is FAIL or PARTIAL, list what needs fixing}

1. **{Gap 1}:** {Description of what's wrong and how to fix}
2. **{Gap 2}:** {Description}

## Next Steps

{Based on verdict}

- If PASS: Proceed to next phase
- If FAIL: Run `/execute {N} --gaps-only` after fixing
- If PARTIAL: Address gaps then re-verify
```

## Evidence Types

| Verification | Evidence Required |
|--------------|-------------------|
| API endpoint | curl command + response |
| UI behavior | Screenshot |
| Test suite | Test output |
| File exists | `ls` or `dir` output |
| Build passes | Build command output |
</file>

<file path=".gsd/DECISIONS.md">

</file>

<file path=".gsd/DESIGN.md">
# Design System

> **Source of Truth**: `.privy/ux_ui.html`

This document defines the visual design language for the application, based on the approved Glassmorphism template.

## Core Philosophy
- **Style**: Glassmorphism (Frosted glass)
- **Theme**: Deep Space / Ocean Blue
- **Vibe**: Modern, Premium, Clean
- **Font**: Inter (Google Fonts)

## Design Tokens

### Colors
**Backgrounds**:
- Deep Blue: `#020617`
- Complex Radial Gradients:
  ```css
  background-image: 
      radial-gradient(at 20% 30%, rgba(30, 144, 255, 0.4) 0, transparent 50%),
      radial-gradient(at 0% 0%, rgba(56, 189, 248, 0.4) 0, transparent 50%), 
      radial-gradient(at 100% 0%, rgba(30, 58, 138, 0.5) 0, transparent 50%), 
      radial-gradient(at 100% 100%, rgba(15, 23, 42, 1) 0, transparent 50%), 
      radial-gradient(at 0% 100%, rgba(30, 64, 175, 0.3) 0, transparent 50%),
      radial-gradient(at 50% 50%, #0f172a 0, transparent 60%);
  ```

**Glass Effect**:
- Border: `rgba(255, 255, 255, 0.1)`
- Surface: `rgba(255, 255, 255, 0.05)`
- Highlight: `rgba(255, 255, 255, 0.15)`

### Typography
- **Family**: Inter, sans-serif
- **Headings**: Bold, Tracking-tight, Drop-shadow
- **Body**: Text-blue-100/80

## Components

### 1. Glass Panel (Card)
Standard container for content.
```css
.glass-panel {
    background: rgba(255, 255, 255, 0.08);
    backdrop-filter: blur(12px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
    border-radius: 1.5rem; /* rounded-3xl */
}
```

### 2. Primary Button (Sign Up / Action)
Gradient background with interaction effects.
```css
.btn-signup {
    background: linear-gradient(to bottom, #3b82f6, #2563eb);
    border-top: 1px solid rgba(255,255,255,0.3);
    box-shadow: 0 4px 15px rgba(37, 99, 235, 0.2), inset 0 1px 2px rgba(255,255,255,0.1);
    color: white;
}
.btn-signup:hover {
    box-shadow: 0 6px 20px rgba(37, 99, 235, 0.4), inset 0 1px 2px rgba(255,255,255,0.2);
    transform: translateY(-1px);
}
```

### 3. Secondary Button (Login / Ghost)
Transparent with subtle border.
```css
.btn-login {
    background: transparent;
    border: 1px solid rgba(255, 255, 255, 0.3);
    color: white;
}
.btn-login:hover {
    background: rgba(255, 255, 255, 0.1);
}
```

### 4. Glass Inner (Nested Sections)
For distinguishing areas within a glass panel.
```css
.glass-inner {
    background: rgba(255, 255, 255, 0.05);
    border: 1px solid rgba(255, 255, 255, 0.05);
}
```

## Tailwind Configuration
Required `extend` in `tailwind.config.js`:
```js
theme: {
  extend: {
    fontFamily: {
      sans: ['Inter', 'sans-serif'],
    },
    colors: {
      glass: {
        border: 'rgba(255, 255, 255, 0.1)',
        surface: 'rgba(255, 255, 255, 0.05)',
        highlight: 'rgba(255, 255, 255, 0.15)',
      }
    }
  }
}
```

## Implementation Rules
1.  **Always** use `Inter` font.
2.  **Always** apply the deep blue gradient to the `body` or main wrapper.
3.  **Use** `glass-panel` for all main content containers.
4.  **Avoid** solid opaque backgrounds for containers; maintain transparency.
</file>

<file path=".gsd/JOURNAL.md">

</file>

<file path=".gsd/REQUIREMENTS.md">
# REQUIREMENTS.md

## Format
| ID | Requirement | Source | Status |
|----|-------------|--------|--------|
| REQ-01 | **User Auth**: Sign-up (Email/Social), Login, Password Reset, Multi-tenancy isolation (RLS). | PRD 4.1.1, 5 Security | Pending |
| REQ-02 | **Dashboard - Chatbot Mgmt**: Create/List chatbots, Configure (Appearance, Greeting, Prompt). | PRD 4.1.2 | Pending |
| REQ-03 | **Dashboard - Knowledge Base**: Upload PDF/TXT, Crawl URL (Firecrawl), Manage/Delete Sources. | PRD 4.1.3 | Pending |
| REQ-04 | **Dashboard - Install**: Generate and display embed code. | PRD 4.1.4 | Pending |
| REQ-05 | **RAG Engine**: Index docs via Gemini File Search, Retrieve and Generate answers with Citations. | PRD 4.2.2, 2.2 Tech Stack | Pending |
| REQ-06 | **Embeddable Widget**: Lightweight (<100KB), Customizable UI (Shadcn), Persistent History, Real-time streaming. | PRD 4.2.1, 5 Performance | Pending |
| REQ-07 | **Human Handoff**: Trigger (User/AI/Admin), Agent Notification, Real-time Agent Chat Interface. | PRD 4.2.3 | Pending |
| REQ-08 | **Monetization**: Subscription Tiers (Free/Pro/Business), Stripe Integration, Usage-based Billing (Message/Storage limits). | PRD 4.1.5, 7.1, 7.2 | Pending |
</file>

<file path=".gsd/TODO.md">

</file>

<file path="app/actions/stripe-products.ts">
"use server";

import { stripe } from "@/lib/stripe";
import { createClient } from "@/utils/supabase/server";
import { revalidatePath } from "next/cache";

const ADMIN_EMAIL = 'ThomasPerdana@gmail.com';

async function verifyAdmin() {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user || user.email !== ADMIN_EMAIL) {
        throw new Error("Unauthorized");
    }
}

export async function createProductAction(data: { name: string; description: string; price: number; interval: 'month' | 'year' }) {
    await verifyAdmin();

    const product = await stripe.products.create({
        name: data.name,
        description: data.description,
    });

    await stripe.prices.create({
        product: product.id,
        unit_amount: data.price * 100, // cents
        currency: 'usd',
        recurring: {
            interval: data.interval
        }
    });

    // We rely on webhook to sync to DB, but we could also manually insert if we want immediate feedback, 
    // but revalidatePath should show it once webhook lands. 
    // Actually, webhook is async. For better UX, we might wait or just accept eventual consistency.

    revalidatePath('/admin/products');
}

export async function deleteProductAction(productId: string) {
    await verifyAdmin();
    // Stripe doesn't allow true delete if it has transactions, so we archive.
    await stripe.products.update(productId, { active: false });
    revalidatePath('/admin/products');
}
</file>

<file path="app/admin/products/page.tsx">
import { createClient } from "@/utils/supabase/server";
import { notFound, redirect } from "next/navigation";
import { ProductForm } from "@/components/admin/product-form";
import { Button } from "@/components/ui/button";
import { deleteProductAction } from "@/app/actions/stripe-products";

// Server Component for the item to handle delete with client interaction (via form action)
function ProductItem({ product }: { product: any }) {
    return (
        <div className="flex justify-between items-center p-4 border rounded-lg">
            <div>
                <h4 className="font-bold">{product.name}</h4>
                <p className="text-sm text-muted-foreground">{product.description}</p>
                <div className="text-sm mt-1">
                    Status: <span className={product.active ? "text-green-600" : "text-red-600"}>{product.active ? 'Active' : 'Archived'}</span>
                </div>
            </div>
            <form action={async () => {
                "use server";
                await deleteProductAction(product.id);
            }}>
                <Button variant="destructive" size="sm" type="submit">Archive</Button>
            </form>
        </div>
    );
}

export default async function AdminProductsPage() {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user || user.email !== 'ThomasPerdana@gmail.com') {
        return notFound();
    }

    const { data: products } = await supabase
        .from('products')
        .select('*, prices(*)')
        .order('name');

    return (
        <div className="container max-w-4xl py-10 space-y-8">
            <div className="flex flex-col gap-2">
                <h1 className="text-3xl font-bold">Product Management</h1>
                <p className="text-muted-foreground">Manage Stripe products and prices.</p>
            </div>

            <ProductForm />

            <div className="space-y-4">
                <h2 className="text-xl font-semibold">Existing Products</h2>
                <div className="grid gap-4">
                    {(products as any[])?.map(product => (
                        <ProductItem key={product.id} product={product} />
                    ))}
                    {!products?.length && <p>No products found.</p>}
                </div>
            </div>
        </div>
    );
}
</file>

<file path="app/admin/users/page.tsx">
import { createClient } from "@/utils/supabase/server";
import {
    Table,
    TableBody,
    TableCell,
    TableHead,
    TableHeader,
    TableRow,
} from "@/components/ui/table";
import { Button } from "@/components/ui/button";

export default async function AdminUsersPage() {
    const supabase = await createClient();

    const { data: users, error } = await supabase
        .from("profiles")
        .select("*")
        .order("created_at", { ascending: false });

    const userList = (users || []) as any[];

    if (error) {
        return <div>Error loading users</div>;
    }

    return (
        <div className="space-y-4">
            <div className="flex justify-between items-center">
                <h2 className="text-3xl font-bold tracking-tight">Users</h2>
            </div>
            <div className="rounded-md border bg-card">
                <Table>
                    <TableHeader>
                        <TableRow>
                            <TableHead>Email</TableHead>
                            <TableHead>Role</TableHead>
                            <TableHead>Created At</TableHead>
                            <TableHead className="text-right">Actions</TableHead>
                        </TableRow>
                    </TableHeader>
                    <TableBody>
                        {userList.map((user) => (
                            <TableRow key={user.id}>
                                <TableCell className="font-medium">{user.email}</TableCell>
                                <TableCell>{user.role}</TableCell>
                                <TableCell>{new Date(user.created_at).toLocaleDateString()}</TableCell>
                                <TableCell className="text-right">
                                    <Button variant="ghost" size="sm">
                                        Edit
                                    </Button>
                                </TableCell>
                            </TableRow>
                        ))}
                    </TableBody>
                </Table>
            </div>
        </div>
    );
}
</file>

<file path="app/admin/layout.tsx">
import { createClient } from "@/utils/supabase/server";
import { redirect } from "next/navigation";
import Link from "next/link";
import { Button } from "@/components/ui/button";

export default async function AdminLayout({
    children,
}: {
    children: React.ReactNode;
}) {
    const supabase = await createClient();

    const {
        data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
        return redirect("/login");
    }

    const { data: profile } = await supabase
        .from("profiles")
        .select("role")
        .eq("id", user.id)
        .single();

    // Explicit check to handle potentially un-inferred types
    const userRole = (profile as any)?.role;

    if (userRole !== "super_admin") {
        return redirect("/dashboard");
    }

    return (
        <div className="flex min-h-screen flex-col">
            <header className="sticky top-0 z-40 border-b bg-background">
                <div className="container flex h-16 items-center justify-between py-4">
                    <div className="flex gap-6 md:gap-10">
                        <Link href="/admin" className="flex items-center space-x-2">
                            <span className="font-bold sm:inline-block">Admin Dashboard</span>
                        </Link>
                        <nav className="flex gap-6">
                            <Link
                                href="/admin"
                                className="flex items-center text-sm font-medium text-muted-foreground hover:text-foreground"
                            >
                                Overview
                            </Link>
                            <Link
                                href="/admin/users"
                                className="flex items-center text-sm font-medium text-muted-foreground hover:text-foreground"
                            >
                                Users
                            </Link>
                            <Link
                                href="/dashboard"
                                className="flex items-center text-sm font-medium text-muted-foreground hover:text-foreground"
                            >
                                App Dashboard
                            </Link>
                        </nav>
                    </div>
                    <div className="flex items-center space-x-4">
                        <div className="text-sm text-muted-foreground">
                            {user.email} (Super Admin)
                        </div>
                    </div>
                </div>
            </header>
            <main className="flex-1 space-y-4 p-8 pt-6">
                {children}
            </main>
        </div>
    );
}
</file>

<file path="app/admin/page.tsx">
import { createClient } from "@/utils/supabase/server";

export default async function AdminPage() {
    const supabase = await createClient();

    // Fetch some basic stats
    const { count: usersCount } = await supabase.from("profiles").select("*", { count: "exact", head: true });
    const { count: orgsCount } = await supabase.from("organizations").select("*", { count: "exact", head: true });
    const { count: chatbotsCount } = await supabase.from("chatbots").select("*", { count: "exact", head: true });

    return (
        <div className="space-y-4">
            <h2 className="text-3xl font-bold tracking-tight">Overview</h2>
            <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
                <div className="rounded-xl border bg-card text-card-foreground shadow-sm p-6">
                    <div className="flex flex-row items-center justify-between space-y-0 pb-2">
                        <h3 className="tracking-tight text-sm font-medium">Total Users</h3>
                        <svg
                            xmlns="http://www.w3.org/2000/svg"
                            viewBox="0 0 24 24"
                            fill="none"
                            stroke="currentColor"
                            strokeLinecap="round"
                            strokeLinejoin="round"
                            strokeWidth="2"
                            className="h-4 w-4 text-muted-foreground"
                        >
                            <path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2" />
                            <circle cx="9" cy="7" r="4" />
                            <path d="M22 21v-2a4 4 0 0 0-3-3.87M16 3.13a4 4 0 0 1 0 7.75" />
                        </svg>
                    </div>
                    <div className="text-2xl font-bold">{usersCount}</div>
                </div>
                <div className="rounded-xl border bg-card text-card-foreground shadow-sm p-6">
                    <div className="flex flex-row items-center justify-between space-y-0 pb-2">
                        <h3 className="tracking-tight text-sm font-medium">Organizations</h3>
                        <svg
                            xmlns="http://www.w3.org/2000/svg"
                            viewBox="0 0 24 24"
                            fill="none"
                            stroke="currentColor"
                            strokeLinecap="round"
                            strokeLinejoin="round"
                            strokeWidth="2"
                            className="h-4 w-4 text-muted-foreground"
                        >
                            <rect width="20" height="14" x="2" y="7" rx="2" ry="2" />
                            <path d="M16 21V5a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v16" />
                        </svg>
                    </div>
                    <div className="text-2xl font-bold">{orgsCount}</div>
                </div>
                <div className="rounded-xl border bg-card text-card-foreground shadow-sm p-6">
                    <div className="flex flex-row items-center justify-between space-y-0 pb-2">
                        <h3 className="tracking-tight text-sm font-medium">Chatbots</h3>
                        <svg
                            xmlns="http://www.w3.org/2000/svg"
                            viewBox="0 0 24 24"
                            fill="none"
                            stroke="currentColor"
                            strokeLinecap="round"
                            strokeLinejoin="round"
                            strokeWidth="2"
                            className="h-4 w-4 text-muted-foreground"
                        >
                            <path d="M12 2a2 2 0 0 1 2 2c0 .74-.4 1.39-1 1.73V7h1a7 7 0 0 1 7 7h1a1 1 0 0 1 1 1v3a1 1 0 0 1-1 1h-1v1a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-1H2a1 1 0 0 1-1-1v-3a1 1 0 0 1 1-1h1v-1.27A2 2 0 0 1 2 4a2 2 0 0 1 2-2" />
                        </svg>
                    </div>
                    <div className="text-2xl font-bold">{chatbotsCount}</div>
                </div>
            </div>
        </div>
    );
}
</file>

<file path="app/api/knowledge/crawl/route.ts">
import { NextResponse } from "next/server";
import { createClient } from "@/utils/supabase/server";
import { FirecrawlService } from "@/lib/ai/firecrawl";
import { GeminiService } from "@/lib/ai/gemini";

export async function POST(request: Request) {
    const supabase = await createClient();
    const {
        data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
        return new NextResponse("Unauthorized", { status: 401 });
    }

    try {
        const { url, chatbotId } = await request.json();

        if (!url || !chatbotId) {
            return new NextResponse("Missing url or chatbotId", { status: 400 });
        }

        // 1. Crawl Website
        const pages = await FirecrawlService.crawlWebsite(url);

        // 2. Process each page
        let successCount = 0;

        for (const page of pages) {
            if (!page.markdown) continue;

            // Create a separate file for each page to preserve context
            // We'll name it sanitized-pagetitle.md or similar
            // For simplicity, we use the URL as the name context
            const sanitizedName = page.url.replace(/[^a-z0-9]/gi, '_').substring(0, 50) + ".md";

            const file = new File([page.markdown], sanitizedName, { type: "text/markdown" });

            // Upload to Gemini
            const geminiFile = await GeminiService.uploadFile(file);

            // Store metadata
            await supabase.from("knowledge_base_sources").insert({
                chatbot_id: chatbotId,
                type: "url",
                content_uri: geminiFile.uri,
                source_url: page.url,
                status: "indexed"
            } as any);

            successCount++;
        }

        return NextResponse.json({ success: true, count: successCount });
    } catch (error) {
        console.error("Crawl error:", error);
        return new NextResponse(error instanceof Error ? error.message : "Internal Server Error", { status: 500 });
    }
}
</file>

<file path="app/api/knowledge/upload/route.ts">
import { NextResponse } from "next/server";
import { createClient } from "@/utils/supabase/server";
import { GeminiService } from "@/lib/ai/gemini";

export async function POST(request: Request) {
    const supabase = await createClient();
    const {
        data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
        return new NextResponse("Unauthorized", { status: 401 });
    }

    try {
        const formData = await request.formData();
        const file = formData.get("file") as File;
        const chatbotId = formData.get("chatbotId") as string;

        if (!file || !chatbotId) {
            return new NextResponse("Missing file or chatbotId", { status: 400 });
        }

        // 1. Upload to Gemini
        const geminiFile = await GeminiService.uploadFile(file);

        // 2. Store metadata in Supabase
        const { error } = await supabase.from("knowledge_base_sources").insert({
            chatbot_id: chatbotId,
            type: "file",
            content_uri: geminiFile.uri,
            source_url: file.name,
            status: "indexed",
        } as any);

        if (error) {
            console.error("Supabase error:", error);
            // Try to clean up Gemini file if DB fails? (Optional for now)
            return new NextResponse("Database Error", { status: 500 });
        }

        return NextResponse.json({ success: true, file: geminiFile });
    } catch (error) {
        console.error("Upload error:", error);
        return new NextResponse("Internal Server Error", { status: 500 });
    }
}
</file>

<file path="app/api/stripe/checkout/route.ts">
import { Stripe } from 'stripe';
import { stripe } from '@/lib/stripe';
import { createClient } from '@/utils/supabase/server';
import { NextResponse } from 'next/server';

export async function POST(request: Request) {
    try {
        const { priceId } = await request.json();
        const supabase = await createClient();

        // 1. Get User
        const { data: { user } } = await supabase.auth.getUser();
        if (!user) {
            return new NextResponse('Unauthorized', { status: 401 });
        }

        // 2. Get Organization
        const { data: profile } = await supabase
            .from('profiles')
            .select('org_id')
            .eq('id', user.id)
            .single() as any;

        if (!profile?.org_id) {
            return new NextResponse('Organization not found', { status: 404 });
        }

        const orgId = profile.org_id;

        const { data: org } = await supabase
            .from('organizations')
            .select('stripe_customer_id, email') // Assuming we might want email, but org doesn't have email usually. User has.
            .eq('id', orgId)
            .single() as any;

        if (!org) {
            return new NextResponse('Organization not found', { status: 404 });
        }

        let customerId = org.stripe_customer_id;

        // 3. Create Stripe Customer if needed
        if (!customerId) {
            const customer = await stripe.customers.create({
                email: user.email, // Use user's email for billing for now
                metadata: {
                    orgId: orgId
                }
            });
            customerId = customer.id;

            // Update Org
            await (supabase.from('organizations') as any).update({ stripe_customer_id: customerId }).eq('id', orgId);
        }

        // 4. Create Checkout Session
        const session = await stripe.checkout.sessions.create({
            customer: customerId,
            line_items: [
                {
                    price: priceId,
                    quantity: 1,
                },
            ],
            mode: 'subscription',
            success_url: `${process.env.NEXT_PUBLIC_APP_URL}/dashboard?checkout=success`,
            cancel_url: `${process.env.NEXT_PUBLIC_APP_URL}/dashboard?checkout=canceled`,
            metadata: {
                orgId: orgId
            },
            client_reference_id: orgId
        });

        return NextResponse.json({ url: session.url });
    } catch (error) {
        console.error('Stripe Checkout Error:', error);
        return new NextResponse('Internal Error', { status: 500 });
    }
}
</file>

<file path="app/api/stripe/portal/route.ts">
import { stripe } from '@/lib/stripe';
import { createClient } from '@/utils/supabase/server';
import { NextResponse } from 'next/server';

export async function POST(request: Request) {
    try {
        const supabase = await createClient();

        // 1. Get User
        const { data: { user } } = await supabase.auth.getUser();
        if (!user) {
            return new NextResponse('Unauthorized', { status: 401 });
        }

        // 2. Get Organization
        const { data: profile } = await supabase
            .from('profiles')
            .select('org_id')
            .eq('id', user.id)
            .single() as any;

        if (!profile?.org_id) {
            return new NextResponse('Organization not found', { status: 404 });
        }

        const orgId = profile.org_id;

        const { data: org } = await supabase
            .from('organizations')
            .select('stripe_customer_id')
            .eq('id', orgId)
            .single() as any;

        if (!org || !org.stripe_customer_id) {
            return new NextResponse('No billing account found', { status: 404 });
        }

        // 3. Create Portal Session
        const session = await stripe.billingPortal.sessions.create({
            customer: org.stripe_customer_id,
            return_url: `${process.env.NEXT_PUBLIC_APP_URL}/dashboard/settings`,
        });

        return NextResponse.json({ url: session.url });
    } catch (error) {
        console.error('Stripe Portal Error:', error);
        return new NextResponse('Internal Error', { status: 500 });
    }
}
</file>

<file path="app/api/stripe/webhook/route.ts">
import { stripe } from '@/lib/stripe';
import { createClient } from '@supabase/supabase-js';
import { headers } from 'next/headers';
import { NextResponse } from 'next/server';
import Stripe from 'stripe';

const supabaseAdmin = createClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL || 'https://dummy.supabase.co',
    process.env.SUPABASE_SERVICE_ROLE_KEY || 'dummy'
);

export async function POST(req: Request) {
    const body = await req.text();
    const signature = (await headers()).get('Stripe-Signature') as string;

    let event: Stripe.Event;

    try {
        event = stripe.webhooks.constructEvent(
            body,
            signature,
            process.env.STRIPE_WEBHOOK_SECRET!
        );
    } catch (error: any) {
        return new NextResponse(`Webhook Error: ${error.message}`, { status: 400 });
    }

    const session = event.data.object as Stripe.Checkout.Session;

    if (event.type === 'checkout.session.completed') {
        const subscriptionId = session.subscription as string;
        const orgId = session.client_reference_id;

        if (!orgId) {
            return new NextResponse('Org ID missing in metadata', { status: 400 });
        }

        // Retrieve subscription to get plan details (price id) if needed, 
        // or just rely on the fact it's active.
        const subscription = await stripe.subscriptions.retrieve(subscriptionId);
        const priceId = subscription.items.data[0].price.id;

        await supabaseAdmin
            .from('organizations')
            .update({
                subscription_status: 'active',
                stripe_customer_id: session.customer as string,
                plan_id: priceId
            })
            .eq('id', orgId);
    }

    if (event.type === 'customer.subscription.deleted') {
        const subscription = event.data.object as Stripe.Subscription;
        const customerId = subscription.customer as string;

        await supabaseAdmin
            .from('organizations')
            .update({
                subscription_status: 'canceled',
                plan_id: null
            })
            .eq('stripe_customer_id', customerId);
    }

    if (event.type === 'product.created' || event.type === 'product.updated') {
        const product = event.data.object as Stripe.Product;
        await supabaseAdmin.from('products').upsert({
            id: product.id,
            active: product.active,
            name: product.name,
            description: product.description,
            image: product.images?.[0] ?? null,
            metadata: product.metadata
        });
    }

    if (event.type === 'price.created' || event.type === 'price.updated') {
        const price = event.data.object as Stripe.Price;
        await supabaseAdmin.from('prices').upsert({
            id: price.id,
            product_id: price.product as string,
            active: price.active,
            currency: price.currency,
            description: price.nickname,
            type: price.type,
            unit_amount: price.unit_amount,
            interval: price.recurring?.interval,
            interval_count: price.recurring?.interval_count,
            trial_period_days: price.recurring?.trial_period_days,
            metadata: price.metadata
        });
    }

    return new NextResponse('Receiver', { status: 200 });
}
</file>

<file path="app/auth/callback/route.ts">
import { NextResponse } from 'next/server'
import { createClient } from '@/utils/supabase/server'

export async function GET(request: Request) {
    const { searchParams, origin } = new URL(request.url)
    const code = searchParams.get('code')
    const next = searchParams.get('next') ?? '/dashboard'

    if (code) {
        const supabase = await createClient()
        const { error } = await supabase.auth.exchangeCodeForSession(code)
        if (!error) {
            return NextResponse.redirect(`${origin}${next}`)
        }
    }

    // return the user to an error page with instructions
    return NextResponse.redirect(`${origin}/auth/auth-code-error`)
}
</file>

<file path="app/dashboard/chatbots/[id]/page.tsx">
import { createClient } from "@/utils/supabase/server";
import { KnowledgeUpload } from "@/components/knowledge-upload";
import { KnowledgeList } from "@/components/knowledge-list";
import { DeploymentCode } from "@/components/deployment-code";
import { redirect } from "next/navigation";
import Link from "next/link";
import { Button } from "@/components/ui/button";
import { ArrowLeft } from "lucide-react";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";

export default async function ChatbotDetailsPage({
    params,
}: {
    params: { id: string };
}) {
    const supabase = await createClient();
    const { id } = params;

    // Fetch Chatbot
    const { data: chatbot, error: botError } = await supabase
        .from("chatbots")
        .select("*")
        .eq("id", id)
        .single() as any;

    if (botError || !chatbot) {
        return <div>Chatbot not found</div>;
    }

    // Fetch Sources
    const { data: sources } = await supabase
        .from("knowledge_base_sources")
        .select("*")
        .eq("chatbot_id", id)
        .order("created_at", { ascending: false }) as any;

    // Cast sources
    const typedSources = (sources || []).map((s: any) => ({
        id: s.id,
        type: s.type,
        source_url: s.source_url,
        status: s.status,
        created_at: s.created_at
    }));

    return (
        <div className="flex flex-col gap-6 p-6 max-w-5xl mx-auto w-full">
            <div className="flex items-center gap-4">
                <Link href="/dashboard/chatbots">
                    <Button variant="ghost" size="icon">
                        <ArrowLeft className="h-4 w-4" />
                    </Button>
                </Link>
                <h1 className="text-2xl font-bold">{chatbot.name}</h1>
                <span className="bg-green-100 text-green-800 text-xs px-2 py-1 rounded-full">
                    {chatbot.status}
                </span>
            </div>

            <Tabs defaultValue="knowledge" className="w-full">
                <TabsList className="mb-4">
                    <TabsTrigger value="knowledge">Knowledge Base</TabsTrigger>
                    <TabsTrigger value="connect">Connect & Embed</TabsTrigger>
                </TabsList>

                <TabsContent value="knowledge">
                    <div className="grid gap-6 md:grid-cols-[350px_1fr]">
                        <div className="space-y-6">
                            <div>
                                <h2 className="text-lg font-semibold mb-2">Add Knowledge</h2>
                                <p className="text-sm text-muted-foreground mb-4">
                                    Upload PDF files or crawl websites to train your chatbot.
                                </p>
                                <KnowledgeUpload chatbotId={id} />
                            </div>
                        </div>

                        <div className="space-y-6">
                            <div>
                                <h2 className="text-lg font-semibold mb-2">Knowledge Sources</h2>
                                <KnowledgeList sources={typedSources} />
                            </div>
                        </div>
                    </div>
                </TabsContent>

                <TabsContent value="connect">
                    <div className="max-w-2xl">
                        <DeploymentCode chatbotId={id} />
                    </div>
                </TabsContent>
            </Tabs>
        </div>
    );
}
</file>

<file path="app/dashboard/chatbots/page.tsx">
import { createClient } from "@/utils/supabase/server";
import { Button } from "@/components/ui/button";
import Link from "next/link";
import { Plus } from "lucide-react";
import { redirect } from "next/navigation";

export default async function ChatbotsPage() {
    const supabase = await createClient();
    const {
        data: { user },
    } = await supabase.auth.getUser();

    if (!user) return redirect("/login");

    // Fetch chatbots
    const { data: chatbots } = await supabase
        .from("chatbots")
        .select("*")
        .order("created_at", { ascending: false }) as any;

    // Create Chatbot Action
    async function createChatbot() {
        "use server";
        const supabase = await createClient();
        const { data: { user } } = await supabase.auth.getUser();

        if (!user) {
            redirect("/login");
        }

        // Get Org ID (Hack: Just pick the first linked profile org or create one if missing? 
        // For now, assuming user has profile with org_id)
        const { data: profile } = await supabase.from("profiles").select("org_id").eq("id", user.id).single() as any;

        if (!profile?.org_id) {
            throw new Error("No organization found");
        }

        const { data, error } = await supabase.from("chatbots").insert({
            org_id: profile.org_id,
            name: "New Chatbot",
            status: "active"
        } as any).select().single() as any;

        if (data) {
            redirect(`/dashboard/chatbots/${data.id}`);
        }
    }

    return (
        <div className="flex flex-col gap-8 p-6">
            <div className="flex items-center justify-between">
                <h1 className="text-3xl font-bold tracking-tight">Chatbots</h1>
                <form action={createChatbot}>
                    <Button>
                        <Plus className="mr-2 h-4 w-4" /> New Chatbot
                    </Button>
                </form>
            </div>

            <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3">
                {chatbots?.map((bot: any) => (
                    <Link
                        key={bot.id}
                        href={`/dashboard/chatbots/${bot.id}`}
                        className="block p-6 border rounded-lg hover:border-primary transition-colors bg-card"
                    >
                        <div className="font-semibold text-lg">{bot.name}</div>
                        <div className="text-sm text-muted-foreground mt-1">
                            Status: {bot.status}
                        </div>
                    </Link>
                ))}
                {chatbots?.length === 0 && (
                    <div className="col-span-full text-center py-12 text-muted-foreground border-dashed border-2 rounded-lg">
                        No chatbots found. Create one to get started.
                    </div>
                )}
            </div>
        </div>
    );
}
</file>

<file path="app/dashboard/inbox/[id]/page.tsx">
import { createClient } from "@/utils/supabase/server";
import { AgentChatWindow } from "@/components/agent-chat-window";
import { redirect, notFound } from "next/navigation";

export default async function InboxChatPage({ params }: { params: { id: string } }) {
    const supabase = await createClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) return redirect("/login");

    const { id } = params;

    const { data: conversation } = await supabase
        .from("conversations")
        .select("*, chatbots(name)")
        .eq("id", id)
        .single();

    if (!conversation) return notFound();

    return (
        <div className="p-6 h-screen flex flex-col">
            <AgentChatWindow conversation={conversation} userId={user.id} />
        </div>
    );
}
</file>

<file path="app/dashboard/inbox/page.tsx">
import { createClient } from "@/utils/supabase/server";
import { InboxList } from "@/components/inbox-list";
import { redirect } from "next/navigation";

export default async function InboxPage() {
    const supabase = await createClient();
    const {
        data: { user },
    } = await supabase.auth.getUser();

    if (!user) return redirect("/login");

    // Initial Fetch logic matches the client side logic needed
    // We want: status=waiting OR (status=active AND assigned_to=me)
    // Supabase syntax for server side
    const { data: conversations } = await supabase
        .from("conversations")
        .select("*, chatbots(name)")
        .or(`status.eq.waiting,and(status.eq.active,assigned_to.eq.${user.id})`)
        .order("created_at", { ascending: false });

    return (
        <div className="p-6 max-w-4xl mx-auto">
            <h1 className="text-3xl font-bold mb-6">Agent Inbox</h1>
            <InboxList initialConversations={conversations || []} userId={user.id} />
        </div>
    );
}
</file>

<file path="app/dashboard/settings/page.tsx">
import { createClient } from "@/utils/supabase/server";
import { SubscriptionCard } from "@/components/subscription-card";
import { redirect } from "next/navigation";

export default async function SettingsPage() {
    const supabase = await createClient();

    const { data: { user } } = await supabase.auth.getUser();
    if (!user) {
        redirect("/login");
    }

    const { data: profile } = await supabase
        .from('profiles')
        .select('org_id')
        .eq('id', user.id)
        .single() as any;

    if (!profile?.org_id) {
        return <div>No Organization Found</div>;
    }

    const { data: org } = await supabase
        .from('organizations')
        .select('*')
        .eq('id', profile.org_id)
        .single() as any;

    return (
        <div className="p-8 max-w-4xl space-y-8">
            <div>
                <h1 className="text-3xl font-bold">Settings</h1>
                <p className="text-muted-foreground">Manage your organization and subscription.</p>
            </div>

            <div className="grid gap-6 md:grid-cols-2">
                <SubscriptionCard org={org} />
                {/* Additional settings can go here */}
            </div>
        </div>
    );
}
</file>

<file path="app/dashboard/layout.tsx">
import { createClient } from "@/utils/supabase/server";
import { redirect } from "next/navigation";
import { DashboardNav } from "@/components/dashboard-nav";
import Link from "next/link";
import { Button } from "@/components/ui/button";

export default async function DashboardLayout({
    children,
}: {
    children: React.ReactNode;
}) {
    const supabase = await createClient();
    const {
        data: { user },
    } = await supabase.auth.getUser();

    if (!user) {
        redirect("/login");
    }

    const signOut = async () => {
        "use server";
        const supabase = await createClient();
        await supabase.auth.signOut();
        redirect("/login");
    };

    return (
        <div className="flex min-h-screen flex-col space-y-6">
            <header className="sticky top-0 z-40 border-b bg-background">
                <div className="container flex h-16 items-center justify-between py-4">
                    <div className="font-bold text-xl tracking-tight">Chatbot Platform</div>
                    <div className="flex items-center gap-4">
                        <span className="text-sm text-muted-foreground mr-2">
                            {user.email}
                        </span>
                        <form action={signOut}>
                            <Button variant="outline" size="sm">Sign Out</Button>
                        </form>
                    </div>
                </div>
            </header>
            <div className="container grid flex-1 gap-12 md:grid-cols-[200px_1fr]">
                <aside className="hidden w-[200px] flex-col md:flex">
                    <DashboardNav />
                </aside>
                <main className="flex w-full flex-1 flex-col overflow-hidden">
                    {children}
                </main>
            </div>
        </div>
    );
}
</file>

<file path="app/dashboard/page.tsx">
import { createClient } from "@/utils/supabase/server";

export default async function DashboardPage() {
    const supabase = await createClient();
    const {
        data: { user },
    } = await supabase.auth.getUser();

    return (
        <div className="flex flex-col gap-4">
            <h1 className="text-3xl font-bold tracking-tight">Overview</h1>
            <div className="rounded-lg border bg-card text-card-foreground shadow-sm p-6">
                <h3 className="text-lg font-semibold leading-none tracking-tight">
                    Welcome back!
                </h3>
                <p className="text-sm text-muted-foreground mt-2">
                    You are logged in as <span className="font-medium text-foreground">{user?.email}</span>.
                </p>
            </div>

            <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-4">
                {/* Placeholder for future specific cards */}
                <div className="rounded-xl border bg-card text-card-foreground shadow p-6">
                    <div className="text-2xl font-bold">0</div>
                    <p className="text-xs text-muted-foreground">Active Chatbots</p>
                </div>
                <div className="rounded-xl border bg-card text-card-foreground shadow p-6">
                    <div className="text-2xl font-bold">0</div>
                    <p className="text-xs text-muted-foreground">Total Conversations</p>
                </div>
            </div>
        </div>
    );
}
</file>

<file path="app/embed/[chatbotId]/page.tsx">
import { ChatInterface } from "@/components/chat-interface";
import { createClient } from "@supabase/supabase-js";
import { notFound } from "next/navigation";

export default async function EmbedPage({
    params,
}: {
    params: { chatbotId: string };
}) {
    const { chatbotId } = params;

    // Use Service Role to fetch public chatbot info
    const supabase = createClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        process.env.SUPABASE_SERVICE_ROLE_KEY!
    );

    const { data: chatbot } = await supabase
        .from("chatbots")
        .select("name, status")
        .eq("id", chatbotId)
        .single();

    if (!chatbot) {
        return notFound();
    }

    // Optional: Check status
    if (chatbot.status !== "active") {
        return (
            <div className="flex h-screen items-center justify-center text-muted-foreground p-4 text-center">
                This chatbot is currently offline.
            </div>
        );
    }

    return <ChatInterface chatbotId={chatbotId} />;
}
</file>

<file path="app/forgot-password/page.tsx">
import { Label } from "@/components/ui/label";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { createClient } from "@/utils/supabase/server";
import { redirect } from "next/navigation";
import Link from "next/link";
import { headers } from "next/headers";

export default function ForgotPassword({
    searchParams,
}: {
    searchParams: { message: string };
}) {
    const startReset = async (formData: FormData) => {
        "use server";

        const email = formData.get("email") as string;
        const supabase = await createClient();
        const origin = (await headers()).get("origin");

        const { error } = await supabase.auth.resetPasswordForEmail(email, {
            redirectTo: `${origin}/auth/callback?next=/reset-password`,
        });

        if (error) {
            return redirect("/forgot-password?message=Could not send reset email. Check email and try again.");
        }

        return redirect("/forgot-password?message=Check your email to reset your password.");
    };

    return (
        <div className="flex-1 flex flex-col w-full px-8 sm:max-w-md justify-center gap-2">
            <Link
                href="/login"
                className="absolute left-8 top-8 py-2 px-4 rounded-md no-underline text-foreground bg-btn-background hover:bg-btn-background-hover flex items-center group text-sm"
            >
                <svg
                    xmlns="http://www.w3.org/2000/svg"
                    width="24"
                    height="24"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    strokeWidth="2"
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    className="mr-2 h-4 w-4 transition-transform group-hover:-translate-x-1"
                >
                    <polyline points="15 18 9 12 15 6" />
                </svg>
                Back
            </Link>

            <form
                className="animate-in flex-1 flex flex-col w-full justify-center gap-2 text-foreground"
                action={startReset}
            >
                <div className="flex flex-col gap-2 mb-4">
                    <h1 className="text-2xl font-bold">Reset Password</h1>
                    <p className="text-sm text-muted-foreground">
                        Enter your email address and we will send you a link to reset your password.
                    </p>
                </div>

                <Label className="text-md" htmlFor="email">
                    Email
                </Label>
                <Input
                    className="rounded-md px-4 py-2 bg-inherit border mb-6"
                    name="email"
                    placeholder="you@example.com"
                    required
                />

                <Button className="bg-green-700 rounded-md px-4 py-2 text-foreground mb-2">
                    Send Reset Link
                </Button>

                {searchParams?.message && (
                    <p className="mt-4 p-4 bg-foreground/10 text-foreground text-center">
                        {searchParams.message}
                    </p>
                )}
            </form>
        </div>
    );
}
</file>

<file path="app/reset-password/page.tsx">
import { Label } from "@/components/ui/label";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { createClient } from "@/utils/supabase/server";
import { redirect } from "next/navigation";
import { headers } from "next/headers";

export default async function ResetPassword({
    searchParams,
}: {
    searchParams: { message: string; code?: string };
}) {
    const resetPassword = async (formData: FormData) => {
        "use server";

        const password = formData.get("password") as string;
        const confirmPassword = formData.get("confirmPassword") as string;
        const supabase = await createClient();

        if (password !== confirmPassword) {
            return redirect("/reset-password?message=Passwords do not match");
        }

        const { error } = await supabase.auth.updateUser({
            password: password,
        });

        if (error) {
            return redirect("/reset-password?message=Could not reset password. Please try again.");
        }

        return redirect("/login?message=Password reset successfully. Please login with your new password.");
    };

    return (
        <div className="flex-1 flex flex-col w-full px-8 sm:max-w-md justify-center gap-2">
            <form
                className="animate-in flex-1 flex flex-col w-full justify-center gap-2 text-foreground"
                action={resetPassword}
            >
                <div className="flex flex-col gap-2 mb-4">
                    <h1 className="text-2xl font-bold">Set New Password</h1>
                    <p className="text-sm text-muted-foreground">
                        Enter your new password below.
                    </p>
                </div>

                <Label className="text-md" htmlFor="password">
                    New Password
                </Label>
                <Input
                    className="rounded-md px-4 py-2 bg-inherit border mb-6"
                    type="password"
                    name="password"
                    placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
                    required
                />

                <Label className="text-md" htmlFor="confirmPassword">
                    Confirm Password
                </Label>
                <Input
                    className="rounded-md px-4 py-2 bg-inherit border mb-6"
                    type="password"
                    name="confirmPassword"
                    placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
                    required
                />

                <Button className="bg-green-700 rounded-md px-4 py-2 text-foreground mb-2">
                    Update Password
                </Button>

                {searchParams?.message && (
                    <p className="mt-4 p-4 bg-foreground/10 text-foreground text-center">
                        {searchParams.message}
                    </p>
                )}
            </form>
        </div>
    );
}
</file>

<file path="app/signup/page.tsx">
import { headers } from "next/headers";
import { createClient } from "@/utils/supabase/server";
import { redirect } from "next/navigation";
import { Label } from "@/components/ui/label";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import Link from "next/link";

export default function Signup({
    searchParams,
}: {
    searchParams: { message: string };
}) {
    const signUp = async (formData: FormData) => {
        "use server";

        const origin = (await headers()).get("origin");
        const email = formData.get("email") as string;
        const password = formData.get("password") as string;
        const supabase = await createClient();

        const { error } = await supabase.auth.signUp({
            email,
            password,
            options: {
                emailRedirectTo: `${origin}/auth/callback`,
            },
        });

        if (error) {
            return redirect("/signup?message=Could not authenticate user");
        }

        return redirect("/signup?message=Check email to continue sign in process");
    };

    return (
        <div className="flex-1 flex flex-col w-full px-8 sm:max-w-md justify-center gap-2">
            <Link
                href="/"
                className="absolute left-8 top-8 py-2 px-4 rounded-md no-underline text-foreground bg-btn-background hover:bg-btn-background-hover flex items-center group text-sm"
            >
                <svg
                    xmlns="http://www.w3.org/2000/svg"
                    width="24"
                    height="24"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    strokeWidth="2"
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    className="mr-2 h-4 w-4 transition-transform group-hover:-translate-x-1"
                >
                    <polyline points="15 18 9 12 15 6" />
                </svg>
                Back
            </Link>

            <form
                className="animate-in flex-1 flex flex-col w-full justify-center gap-2 text-foreground"
                action={signUp}
            >
                <h1 className="text-2xl font-bold mb-4">Sign Up</h1>
                <Label className="text-md" htmlFor="email">
                    Email
                </Label>
                <Input
                    className="rounded-md px-4 py-2 bg-inherit border mb-6"
                    name="email"
                    placeholder="you@example.com"
                    required
                />
                <Label className="text-md" htmlFor="password">
                    Password
                </Label>
                <Input
                    className="rounded-md px-4 py-2 bg-inherit border mb-6"
                    type="password"
                    name="password"
                    placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
                    required
                />
                <Button className="bg-green-700 rounded-md px-4 py-2 text-foreground mb-2">
                    Sign Up
                </Button>
                <div className="text-center text-sm">
                    Already have an account? <Link href="/login" className="underline">Log In</Link>
                </div>
                {searchParams?.message && (
                    <p className="mt-4 p-4 bg-foreground/10 text-foreground text-center">
                        {searchParams.message}
                    </p>
                )}
            </form>
        </div>
    );
}
</file>

<file path="app/globals.css">
@import "tailwindcss";

@theme {
  --font-sans: 'Inter', sans-serif;
  --color-glass-border: rgba(255, 255, 255, 0.1);
  --color-glass-surface: rgba(255, 255, 255, 0.05);
  --color-glass-highlight: rgba(255, 255, 255, 0.15);
}

/* 
 * Background Setup 
 * Rich deep blue with cyan highlights behind glass elements.
 */
body {
    background-color: #020617;
    background-image: 
        radial-gradient(at 20% 30%, rgba(30, 144, 255, 0.4) 0, transparent 50%),
        radial-gradient(at 0% 0%, rgba(56, 189, 248, 0.4) 0, transparent 50%), 
        radial-gradient(at 100% 0%, rgba(30, 58, 138, 0.5) 0, transparent 50%), 
        radial-gradient(at 100% 100%, rgba(15, 23, 42, 1) 0, transparent 50%), 
        radial-gradient(at 0% 100%, rgba(30, 64, 175, 0.3) 0, transparent 50%),
        radial-gradient(at 50% 50%, #0f172a 0, transparent 60%);
    background-attachment: fixed;
    background-size: cover;
    min-height: 100vh;
    color: white;
}

@utility glass-panel {
    background: rgba(255, 255, 255, 0.08);
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    border: 1px solid var(--color-glass-border);
    box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
}

@utility glass-inner {
    background: var(--color-glass-surface);
    border: 1px solid var(--color-glass-surface);
}

@utility btn-signup {
    background: linear-gradient(to bottom, #3b82f6, #2563eb);
    border-top: 1px solid rgba(255,255,255,0.3);
    box-shadow: 0 4px 15px rgba(37, 99, 235, 0.2), inset 0 1px 2px rgba(255,255,255,0.1);
    color: white;
    transition: all 0.3s ease;

    &:hover {
        box-shadow: 0 6px 20px rgba(37, 99, 235, 0.4), inset 0 1px 2px rgba(255,255,255,0.2);
        transform: translateY(-1px);
    }
}

@utility btn-login {
    background: transparent;
    border: 1px solid rgba(255, 255, 255, 0.3);
    color: white;
    transition: background 0.3s ease;
    display: flex;
    align-items: center;
    justify-content: center;

    &:hover {
        background: rgba(255, 255, 255, 0.1);
    }
}
</file>

<file path="app/layout.tsx">
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
    title: "Embeddable RAG Chatbot",
    description: "Deploy custom AI support agents to your website in minutes.",
};

export default function RootLayout({
    children,
}: Readonly<{
    children: React.ReactNode;
}>) {
    return (
        <html lang="en">
            <body className={inter.className}>{children}</body>
        </html>
    );
}
</file>

<file path="components/admin/product-form.tsx">
"use client";

import { createProductAction } from "@/app/actions/stripe-products";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { useState } from "react";

export function ProductForm() {
    const [name, setName] = useState("");
    const [desc, setDesc] = useState("");
    const [price, setPrice] = useState("");
    const [interval, setInterval] = useState<'month' | 'year'>('month');
    const [loading, setLoading] = useState(false);

    async function handleSubmit(e: React.FormEvent) {
        e.preventDefault();
        setLoading(true);
        try {
            await createProductAction({
                name,
                description: desc,
                price: parseFloat(price),
                interval
            });
            // Reset form
            setName("");
            setDesc("");
            setPrice("");
        } catch (error) {
            console.error(error);
            alert("Failed to create product");
        } finally {
            setLoading(false);
        }
    }

    return (
        <form onSubmit={handleSubmit} className="space-y-4 border p-4 rounded-lg bg-card text-card-foreground">
            <h3 className="font-semibold text-lg">Create New Product</h3>
            <div>
                <label className="text-sm">Name</label>
                <Input value={name} onChange={e => setName(e.target.value)} required />
            </div>
            <div>
                <label className="text-sm">Description</label>
                <Input value={desc} onChange={e => setDesc(e.target.value)} />
            </div>
            <div className="flex gap-4">
                <div className="flex-1">
                    <label className="text-sm">Price (USD)</label>
                    <Input type="number" step="0.01" value={price} onChange={e => setPrice(e.target.value)} required />
                </div>
                <div className="flex-1">
                    <label className="text-sm">Interval</label>
                    <Select value={interval} onValueChange={(v: any) => setInterval(v)}>
                        <SelectTrigger>
                            <SelectValue />
                        </SelectTrigger>
                        <SelectContent>
                            <SelectItem value="month">Monthly</SelectItem>
                            <SelectItem value="year">Yearly</SelectItem>
                        </SelectContent>
                    </Select>
                </div>
            </div>
            <Button type="submit" disabled={loading}>
                {loading ? "Creating..." : "Create Product"}
            </Button>
        </form>
    );
}
</file>

<file path="components/auth/google-sign-in.tsx">
"use client";

import { createClient } from "@/utils/supabase/client";
import { Button } from "@/components/ui/button";

export function GoogleSignIn() {
    const handleLogin = async () => {
        const supabase = createClient();
        await supabase.auth.signInWithOAuth({
            provider: "google",
            options: {
                redirectTo: `${location.origin}/auth/callback`,
            },
        });
    };

    return (
        <Button
            onClick={handleLogin}
            className="w-full bg-white text-black border border-gray-300 hover:bg-gray-100 flex items-center justify-center mt-4"
            type="button"
        >
            <svg className="mr-2 h-4 w-4" aria-hidden="true" focusable="false" data-prefix="fab" data-icon="google" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 488 512">
                <path fill="currentColor" d="M488 261.8C488 403.3 391.1 504 248 504 110.8 504 0 393.2 0 256S110.8 8 248 8c66.8 0 123 24.5 166.3 64.9l-67.5 64.9C258.5 52.6 94.3 116.6 94.3 256c0 86.5 69.1 156.6 153.7 156.6 98.2 0 135-70.4 140.8-106.9H248v-85.3h236.1c2.3 12.7 3.9 24.9 3.9 41.4z"></path>
            </svg>
            Sign in with Google
        </Button>
    );
}
</file>

<file path="components/ui/alert.tsx">
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive:
          "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  />
))
Alert.displayName = "Alert"

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
))
AlertTitle.displayName = "AlertTitle"

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
))
AlertDescription.displayName = "AlertDescription"

export { Alert, AlertTitle, AlertDescription }
</file>

<file path="components/ui/avatar.tsx">
"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

const Avatar = React.forwardRef<
    React.ElementRef<typeof AvatarPrimitive.Root>,
    React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
    <AvatarPrimitive.Root
        ref={ref}
        className={cn(
            "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full",
            className
        )}
        {...props}
    />
))
Avatar.displayName = AvatarPrimitive.Root.displayName

const AvatarImage = React.forwardRef<
    React.ElementRef<typeof AvatarPrimitive.Image>,
    React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
    <AvatarPrimitive.Image
        ref={ref}
        className={cn("aspect-square h-full w-full", className)}
        {...props}
    />
))
AvatarImage.displayName = AvatarPrimitive.Image.displayName

const AvatarFallback = React.forwardRef<
    React.ElementRef<typeof AvatarPrimitive.Fallback>,
    React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
    <AvatarPrimitive.Fallback
        ref={ref}
        className={cn(
            "flex h-full w-full items-center justify-center rounded-full bg-muted",
            className
        )}
        {...props}
    />
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName

export { Avatar, AvatarImage, AvatarFallback }
</file>

<file path="components/ui/button.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }
</file>

<file path="components/ui/card.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-lg border bg-card text-card-foreground shadow-sm",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "text-2xl font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }
</file>

<file path="components/ui/dropdown-menu.tsx">
"use client"

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const DropdownMenu = DropdownMenuPrimitive.Root

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger

const DropdownMenuGroup = DropdownMenuPrimitive.Group

const DropdownMenuPortal = DropdownMenuPrimitive.Portal

const DropdownMenuSub = DropdownMenuPrimitive.Sub

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup

const DropdownMenuSubTrigger = React.forwardRef<
    React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
    React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
        inset?: boolean
    }
>(({ className, inset, children, ...props }, ref) => (
    <DropdownMenuPrimitive.SubTrigger
        ref={ref}
        className={cn(
            "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent",
            inset && "pl-8",
            className
        )}
        {...props}
    >
        {children}
        <ChevronRight className="ml-auto h-4 w-4" />
    </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName =
    DropdownMenuPrimitive.SubTrigger.displayName

const DropdownMenuSubContent = React.forwardRef<
    React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
    React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
    <DropdownMenuPrimitive.SubContent
        ref={ref}
        className={cn(
            "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
            className
        )}
        {...props}
    />
))
DropdownMenuSubContent.displayName =
    DropdownMenuPrimitive.SubContent.displayName

const DropdownMenuContent = React.forwardRef<
    React.ElementRef<typeof DropdownMenuPrimitive.Content>,
    React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
    <DropdownMenuPrimitive.Portal>
        <DropdownMenuPrimitive.Content
            ref={ref}
            sideOffset={sideOffset}
            className={cn(
                "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
                className
            )}
            {...props}
        />
    </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef<
    React.ElementRef<typeof DropdownMenuPrimitive.Item>,
    React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
        inset?: boolean
    }
>(({ className, inset, ...props }, ref) => (
    <DropdownMenuPrimitive.Item
        ref={ref}
        className={cn(
            "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
            inset && "pl-8",
            className
        )}
        {...props}
    />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

const DropdownMenuCheckboxItem = React.forwardRef<
    React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
    React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
    <DropdownMenuPrimitive.CheckboxItem
        ref={ref}
        className={cn(
            "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
            className
        )}
        checked={checked}
        {...props}
    >
        <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
            <DropdownMenuPrimitive.ItemIndicator>
                <Check className="h-4 w-4" />
            </DropdownMenuPrimitive.ItemIndicator>
        </span>
        {children}
    </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName =
    DropdownMenuPrimitive.CheckboxItem.displayName

const DropdownMenuRadioItem = React.forwardRef<
    React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
    React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
    <DropdownMenuPrimitive.RadioItem
        ref={ref}
        className={cn(
            "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
            className
        )}
        {...props}
    >
        <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
            <DropdownMenuPrimitive.ItemIndicator>
                <Circle className="h-2 w-2 fill-current" />
            </DropdownMenuPrimitive.ItemIndicator>
        </span>
        {children}
    </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName

const DropdownMenuLabel = React.forwardRef<
    React.ElementRef<typeof DropdownMenuPrimitive.Label>,
    React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
        inset?: boolean
    }
>(({ className, inset, ...props }, ref) => (
    <DropdownMenuPrimitive.Label
        ref={ref}
        className={cn(
            "px-2 py-1.5 text-sm font-semibold",
            inset && "pl-8",
            className
        )}
        {...props}
    />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName

const DropdownMenuSeparator = React.forwardRef<
    React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
    React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
    <DropdownMenuPrimitive.Separator
        ref={ref}
        className={cn("-mx-1 my-1 h-px bg-muted", className)}
        {...props}
    />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName

const DropdownMenuShortcut = ({
    className,
    ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
    return (
        <span
            className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
            {...props}
        />
    )
}
DropdownMenuShortcut.displayName = "DropdownMenuShortcut"

export {
    DropdownMenu,
    DropdownMenuTrigger,
    DropdownMenuContent,
    DropdownMenuItem,
    DropdownMenuCheckboxItem,
    DropdownMenuRadioItem,
    DropdownMenuLabel,
    DropdownMenuSeparator,
    DropdownMenuShortcut,
    DropdownMenuGroup,
    DropdownMenuPortal,
    DropdownMenuSub,
    DropdownMenuSubContent,
    DropdownMenuSubTrigger,
    DropdownMenuRadioGroup,
}
</file>

<file path="components/ui/input.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

const Input = React.forwardRef<HTMLInputElement, React.ComponentProps<"input">>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }
</file>

<file path="components/ui/label.tsx">
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }
</file>

<file path="components/ui/select.tsx">
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "@/lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
    React.ElementRef<typeof SelectPrimitive.Trigger>,
    React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
    <SelectPrimitive.Trigger
        ref={ref}
        className={cn(
            "flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
            className
        )}
        {...props}
    >
        {children}
        <SelectPrimitive.Icon asChild>
            <ChevronDown className="h-4 w-4 opacity-50" />
        </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
    React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
    React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
    <SelectPrimitive.ScrollUpButton
        ref={ref}
        className={cn(
            "flex cursor-default items-center justify-center py-1",
            className
        )}
        {...props}
    >
        <ChevronUp className="h-4 w-4" />
    </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
    React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
    React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
    <SelectPrimitive.ScrollDownButton
        ref={ref}
        className={cn(
            "flex cursor-default items-center justify-center py-1",
            className
        )}
        {...props}
    >
        <ChevronDown className="h-4 w-4" />
    </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
    SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
    React.ElementRef<typeof SelectPrimitive.Content>,
    React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
    <SelectPrimitive.Portal>
        <SelectPrimitive.Content
            ref={ref}
            className={cn(
                "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
                position === "popper" &&
                "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
                className
            )}
            position={position}
            {...props}
        >
            <SelectScrollUpButton />
            <SelectPrimitive.Viewport
                className={cn(
                    "p-1",
                    position === "popper" &&
                    "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
                )}
            >
                {children}
            </SelectPrimitive.Viewport>
            <SelectScrollDownButton />
        </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
    React.ElementRef<typeof SelectPrimitive.Label>,
    React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
    <SelectPrimitive.Label
        ref={ref}
        className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)}
        {...props}
    />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
    React.ElementRef<typeof SelectPrimitive.Item>,
    React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
    <SelectPrimitive.Item
        ref={ref}
        className={cn(
            "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
            className
        )}
        {...props}
    >
        <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
            <SelectPrimitive.ItemIndicator>
                <Check className="h-4 w-4" />
            </SelectPrimitive.ItemIndicator>
        </span>

        <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
    React.ElementRef<typeof SelectPrimitive.Separator>,
    React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
    <SelectPrimitive.Separator
        ref={ref}
        className={cn("-mx-1 my-1 h-px bg-muted", className)}
        {...props}
    />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
    Select,
    SelectGroup,
    SelectValue,
    SelectTrigger,
    SelectContent,
    SelectLabel,
    SelectItem,
    SelectSeparator,
    SelectScrollUpButton,
    SelectScrollDownButton,
}
</file>

<file path="components/ui/table.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
))
Table.displayName = "Table"

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
))
TableHeader.displayName = "TableHeader"

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
))
TableBody.displayName = "TableBody"

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
      className
    )}
    {...props}
  />
))
TableFooter.displayName = "TableFooter"

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className
    )}
    {...props}
  />
))
TableRow.displayName = "TableRow"

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0",
      className
    )}
    {...props}
  />
))
TableHead.displayName = "TableHead"

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn("p-4 align-middle [&:has([role=checkbox])]:pr-0", className)}
    {...props}
  />
))
TableCell.displayName = "TableCell"

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
))
TableCaption.displayName = "TableCaption"

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}
</file>

<file path="components/ui/tabs.tsx">
"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }
</file>

<file path="components/agent-chat-window.tsx">
"use client";

import { useRealtimeChat } from "@/hooks/use-realtime-chat";
import { useState, useRef, useEffect } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { createClient } from "@/utils/supabase/client";
import { useRouter } from "next/navigation";
import { cn } from "@/lib/utils";
import { Send, ArrowLeft } from "lucide-react";
import Link from "next/link";

export function AgentChatWindow({ conversation, userId }: { conversation: any, userId: string }) {
    const { messages, sendMessage: sendMessageToChat } = useRealtimeChat(conversation.id);
    const [input, setInput] = useState("");
    const supabase = createClient();
    const router = useRouter();
    const scrollRef = useRef<HTMLDivElement>(null);

    useEffect(() => {
        if (scrollRef.current) {
            scrollRef.current.scrollTop = scrollRef.current.scrollHeight;
        }
    }, [messages]);

    async function sendMessage(e: React.FormEvent) {
        e.preventDefault();
        if (!input.trim()) return;

        const content = input;
        setInput("");

        await sendMessageToChat(content, "assistant");
    }

    async function updateStatus(status: string) {
        await (supabase as any).from("conversations").update({
            status,
            assigned_to: status === 'waiting' ? null : userId
        } as any).eq("id", conversation.id);
        router.refresh();
        if (status === 'closed') router.push('/dashboard/inbox');
    }

    return (
        <div className="flex flex-col h-[calc(100vh-100px)] border rounded-lg bg-background">
            {/* Header */}
            <div className="p-4 border-b flex items-center justify-between bg-muted/20">
                <div className="flex items-center gap-3">
                    <Link href="/dashboard/inbox">
                        <Button variant="ghost" size="icon">
                            <ArrowLeft className="h-4 w-4" />
                        </Button>
                    </Link>
                    <div>
                        <h3 className="font-semibold">{conversation.chatbots?.name}</h3>
                        <div className="text-xs text-muted-foreground">Visitor: {conversation.visitor_id || "Anon"}</div>
                    </div>
                </div>
                <div className="flex gap-2">
                    <Button size="sm" variant="outline" onClick={() => updateStatus('waiting')}>
                        Release
                    </Button>
                    <Button size="sm" variant="destructive" onClick={() => updateStatus('closed')}>
                        Close Chat
                    </Button>
                </div>
            </div>

            {/* Messages */}
            <div className="flex-1 overflow-y-auto p-4 space-y-4" ref={scrollRef}>
                {messages.map((m) => (
                    <div
                        key={m.id}
                        className={cn(
                            "max-w-[80%] rounded-lg px-3 py-2 text-sm",
                            m.role === 'assistant'
                                ? "ml-auto bg-primary text-primary-foreground"
                                : "bg-muted text-muted-foreground"
                        )}
                    >
                        <div className="text-[10px] opacity-70 mb-1 capitalize">{m.role}</div>
                        {m.content}
                    </div>
                ))}
            </div>

            {/* Input */}
            <form onSubmit={sendMessage} className="p-4 border-t flex gap-2">
                <Input
                    value={input}
                    onChange={e => setInput(e.target.value)}
                    placeholder="Reply as agent..."
                />
                <Button type="submit" size="icon">
                    <Send className="h-4 w-4" />
                </Button>
            </form>
        </div>
    );
}
</file>

<file path="components/deployment-code.tsx">
"use client";

import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Copy } from "lucide-react";
import { useState, useEffect } from "react";

export function DeploymentCode({ chatbotId }: { chatbotId: string }) {
    const [host, setHost] = useState("");

    useEffect(() => {
        setHost(window.location.origin);
    }, []);

    const scriptCode = `<script src="${host}/widget.js" data-chatbot-id="${chatbotId}"></script>`;

    const copyToClipboard = () => {
        navigator.clipboard.writeText(scriptCode);
        alert("Copied to clipboard!");
    };

    return (
        <Card>
            <CardHeader>
                <CardTitle>Embed Widget</CardTitle>
                <CardDescription>
                    Copy and paste this code into your website's HTML, before the closing &lt;/body&gt; tag.
                </CardDescription>
            </CardHeader>
            <CardContent className="space-y-4">
                <div className="bg-muted p-4 rounded-md font-mono text-sm break-all relative group">
                    {scriptCode}
                    <Button
                        size="icon"
                        variant="secondary"
                        className="absolute top-2 right-2 opacity-0 group-hover:opacity-100 transition-opacity"
                        onClick={copyToClipboard}
                    >
                        <Copy className="h-4 w-4" />
                    </Button>
                </div>
            </CardContent>
        </Card>
    );
}
</file>

<file path="components/inbox-list.tsx">
"use client";

import { useState } from "react";
import { createClient } from "@/utils/supabase/client";
import { Button } from "@/components/ui/button";
import { Card, CardContent } from "@/components/ui/card";
import Link from "next/link";
import { formatDistanceToNow } from "date-fns";
import { RefreshCcw } from "lucide-react";

export function InboxList({ initialConversations, userId }: { initialConversations: any[], userId: string }) {
    const [conversations, setConversations] = useState<any[]>(initialConversations);
    const supabase = createClient();
    const [loading, setLoading] = useState(false);

    async function fetchConversations() {
        setLoading(true);
        // Fetch waiting or assigned to me
        const { data } = await supabase
            .from("conversations")
            .select("*, chatbots(name)")
            .or(`status.eq.waiting,and(status.eq.active,assigned_to.eq.${userId})`)
            .order("created_at", { ascending: false });

        if (data) setConversations(data);
        setLoading(false);
    }

    async function claimChat(id: string) {
        await (supabase as any).from("conversations").update({
            status: "active",
            assigned_to: userId
        } as any).eq("id", id);
        fetchConversations();
    }

    return (
        <div className="space-y-4">
            <div className="flex justify-between items-center">
                <h2 className="text-xl font-semibold">Active & Waiting</h2>
                <Button size="sm" variant="outline" onClick={fetchConversations} disabled={loading}>
                    <RefreshCcw className={`h-4 w-4 mr-2 ${loading ? "animate-spin" : ""}`} />
                    Refresh
                </Button>
            </div>

            <div className="grid gap-4">
                {conversations.length === 0 && (
                    <div className="text-center py-10 text-muted-foreground border rounded bg-muted/20">
                        No conversations found.
                    </div>
                )}
                {conversations.map((conv) => (
                    <Card key={conv.id} className={conv.status === 'waiting' ? 'border-l-4 border-l-yellow-400' : 'border-l-4 border-l-green-400'}>
                        <CardContent className="p-4 flex items-center justify-between">
                            <div>
                                <div className="font-semibold">{conv.chatbots?.name || "Accessory Bot"}</div>
                                <div className="text-xs text-muted-foreground">
                                    Visitor: {conv.visitor_id || "Anonymous"} ‚Ä¢ {formatDistanceToNow(new Date(conv.created_at))} ago
                                </div>
                                <div className="mt-1">
                                    <span className={`text-xs px-2 py-0.5 rounded-full capitalize ${conv.status === 'waiting' ? 'bg-yellow-100 text-yellow-800' : 'bg-green-100 text-green-800'
                                        }`}>
                                        {conv.status}
                                    </span>
                                </div>
                            </div>
                            <div className="flex gap-2">
                                {conv.status === 'waiting' && (
                                    <Button size="sm" onClick={() => claimChat(conv.id)}>Claim</Button>
                                )}
                                <Link href={`/dashboard/inbox/${conv.id}`}>
                                    <Button size="sm" variant="secondary">View</Button>
                                </Link>
                            </div>
                        </CardContent>
                    </Card>
                ))}
            </div>
        </div>
    );
}
</file>

<file path="components/knowledge-list.tsx">
import {
    Table,
    TableBody,
    TableCell,
    TableHead,
    TableHeader,
    TableRow,
} from "@/components/ui/table";
import { formatDistanceToNow } from "date-fns";

type Source = {
    id: string;
    type: string;
    source_url: string | null;
    status: string | null;
    created_at: string;
};

export function KnowledgeList({ sources }: { sources: Source[] }) {
    if (sources.length === 0) {
        return (
            <div className="text-center py-8 text-muted-foreground border rounded-lg bg-muted/20">
                No knowledge sources added yet.
            </div>
        );
    }

    return (
        <div className="border rounded-md">
            <Table>
                <TableHeader>
                    <TableRow>
                        <TableHead>Source</TableHead>
                        <TableHead>Type</TableHead>
                        <TableHead>Status</TableHead>
                        <TableHead className="text-right">Added</TableHead>
                    </TableRow>
                </TableHeader>
                <TableBody>
                    {sources.map((source) => (
                        <TableRow key={source.id}>
                            <TableCell className="font-medium truncate max-w-[200px]" title={source.source_url || ""}>
                                {source.source_url}
                            </TableCell>
                            <TableCell className="capitalize">{source.type}</TableCell>
                            <TableCell>
                                <span
                                    className={`px-2 py-1 rounded-full text-xs font-medium ${source.status === "indexed"
                                            ? "bg-green-100 text-green-700"
                                            : source.status === "failed"
                                                ? "bg-red-100 text-red-700"
                                                : "bg-yellow-100 text-yellow-700"
                                        }`}
                                >
                                    {source.status}
                                </span>
                            </TableCell>
                            <TableCell className="text-right text-muted-foreground">
                                {formatDistanceToNow(new Date(source.created_at), { addSuffix: true })}
                            </TableCell>
                        </TableRow>
                    ))}
                </TableBody>
            </Table>
        </div>
    );
}
</file>

<file path="components/knowledge-upload.tsx">
"use client";

import { useState } from "react";
import { useRouter } from "next/navigation";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Card, CardContent } from "@/components/ui/card";
import { Label } from "@/components/ui/label";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";

export function KnowledgeUpload({ chatbotId }: { chatbotId: string }) {
    const router = useRouter();
    const [loading, setLoading] = useState(false);
    const [message, setMessage] = useState<{ type: "success" | "error"; text: string } | null>(null);

    async function handleFileUpload(event: React.FormEvent<HTMLFormElement>) {
        event.preventDefault();
        setLoading(true);
        setMessage(null);

        const formData = new FormData(event.currentTarget);
        formData.append("chatbotId", chatbotId);

        try {
            const res = await fetch("/api/knowledge/upload", {
                method: "POST",
                body: formData,
            });

            if (!res.ok) throw new Error("Upload failed");

            setMessage({ type: "success", text: "File uploaded successfully" });
            router.refresh();
            (event.target as HTMLFormElement).reset();
        } catch (error) {
            setMessage({ type: "error", text: "Failed to upload file" });
        } finally {
            setLoading(false);
        }
    }

    async function handleCrawl(event: React.FormEvent<HTMLFormElement>) {
        event.preventDefault();
        setLoading(true);
        setMessage(null);

        const formData = new FormData(event.currentTarget);
        const url = formData.get("url") as string;

        try {
            const res = await fetch("/api/knowledge/crawl", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ url, chatbotId }),
            });

            if (!res.ok) throw new Error("Crawl failed");

            const data = await res.json();
            setMessage({ type: "success", text: `Crawled ${data.count} pages` });
            router.refresh();
            (event.target as HTMLFormElement).reset();
        } catch (error) {
            setMessage({ type: "error", text: "Failed to crawl website" });
        } finally {
            setLoading(false);
        }
    }

    return (
        <Card className="w-full">
            <CardContent className="pt-6">
                <Tabs defaultValue="file" className="w-full">
                    <TabsList className="grid w-full grid-cols-2 mb-4">
                        <TabsTrigger value="file">File Upload</TabsTrigger>
                        <TabsTrigger value="website">Website Crawl</TabsTrigger>
                    </TabsList>

                    <TabsContent value="file">
                        <form onSubmit={handleFileUpload} className="space-y-4">
                            <div className="space-y-2">
                                <Label htmlFor="file">Upload PDF or Text</Label>
                                <Input id="file" name="file" type="file" accept=".pdf,.txt,.md" required />
                            </div>
                            <Button type="submit" disabled={loading} className="w-full">
                                {loading ? "Uploading..." : "Upload File"}
                            </Button>
                        </form>
                    </TabsContent>

                    <TabsContent value="website">
                        <form onSubmit={handleCrawl} className="space-y-4">
                            <div className="space-y-2">
                                <Label htmlFor="url">Website URL</Label>
                                <Input id="url" name="url" type="url" placeholder="https://example.com" required />
                            </div>
                            <Button type="submit" disabled={loading} className="w-full">
                                {loading ? "Start Crawling" : "Crawl Website"}
                            </Button>
                        </form>
                    </TabsContent>
                </Tabs>

                {message && (
                    <Alert className={`mt-4 ${message.type === "error" ? "bg-red-50" : "bg-green-50"}`}>
                        <AlertTitle>{message.type === "success" ? "Success" : "Error"}</AlertTitle>
                        <AlertDescription>{message.text}</AlertDescription>
                    </Alert>
                )}
            </CardContent>
        </Card>
    );
}
</file>

<file path="components/subscription-card.tsx">
"use client";

import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card";
import { useState } from "react";

interface Organization {
    id: string;
    name: string;
    subscription_status: string | null;
    messages_count: number | null;
}

export function SubscriptionCard({ org }: { org: Organization }) {
    const [loading, setLoading] = useState(false);

    const isPro = org.subscription_status === 'active';
    const limit = isPro ? 100000 : 50;
    const usage = org.messages_count || 0;
    const percentage = Math.min((usage / limit) * 100, 100);

    async function handleUpgrade() {
        setLoading(true);
        try {
            // Use dummy or env var for price ID
            const priceId = process.env.NEXT_PUBLIC_PRO_PRICE_ID || 'price_1Q...';
            if (!priceId || priceId.startsWith('price_1Q')) {
                alert("Please configure NEXT_PUBLIC_PRO_PRICE_ID in .env.local");
                setLoading(false);
                return;
            }

            const res = await fetch('/api/stripe/checkout', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ priceId }),
            });
            const data = await res.json();
            window.location.href = data.url;
        } catch (error) {
            console.error(error);
            setLoading(false);
        }
    }

    async function handleManage() {
        setLoading(true);
        try {
            const res = await fetch('/api/stripe/portal', {
                method: 'POST'
            });
            const data = await res.json();
            window.location.href = data.url;
        } catch (error) {
            console.error(error);
            setLoading(false);
        }
    }

    return (
        <Card>
            <CardHeader>
                <CardTitle>Subscription</CardTitle>
                <CardDescription>Manage your plan and usage.</CardDescription>
            </CardHeader>
            <CardContent className="space-y-4">
                <div className="flex justify-between items-center">
                    <div>
                        <p className="font-medium">Current Plan</p>
                        <p className="text-sm text-muted-foreground capitalize">{org.subscription_status || 'Free'}</p>
                    </div>
                    {isPro && <span className="bg-green-100 text-green-800 text-xs px-2 py-1 rounded">Pro Active</span>}
                </div>

                <div className="space-y-2">
                    <div className="flex justify-between text-sm">
                        <span>Message Usage</span>
                        <span>{usage} / {limit}</span>
                    </div>
                    <div className="h-2 w-full bg-secondary rounded-full overflow-hidden">
                        <div
                            className="h-full bg-primary transition-all duration-300"
                            style={{ width: `${percentage}%` }}
                        />
                    </div>
                    {percentage >= 90 && <p className="text-xs text-red-500">Approaching limit!</p>}
                </div>
            </CardContent>
            <CardFooter>
                {!isPro ? (
                    <Button onClick={handleUpgrade} disabled={loading}>
                        {loading ? 'Redirecting...' : 'Upgrade to Pro'}
                    </Button>
                ) : (
                    <Button variant="outline" onClick={handleManage} disabled={loading}>
                        {loading ? 'Redirecting...' : 'Manage Subscription'}
                    </Button>
                )}
            </CardFooter>
        </Card>
    );
}
</file>

<file path="lib/ai/firecrawl.ts">
export interface CrawlResult {
    url: string;
    markdown: string;
}

export const FirecrawlService = {
    /**
     * Crawls a website and returns the markdown content for each page.
     */
    async crawlWebsite(url: string, limit: number = 10): Promise<CrawlResult[]> {
        const apiKey = process.env.FIRECRAWL_API_KEY;
        if (!apiKey) {
            throw new Error("FIRECRAWL_API_KEY is not configured");
        }

        // 1. Start the crawl
        const startResponse = await fetch("https://api.firecrawl.dev/v1/crawl", {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                Authorization: `Bearer ${apiKey}`,
            },
            body: JSON.stringify({
                url,
                limit, // Limit pages to avoid huge costs/time for now
                scrapeOptions: {
                    formats: ["markdown"]
                }
            }),
        });

        if (!startResponse.ok) {
            const errorText = await startResponse.text();
            throw new Error(`Firecrawl start failed: ${errorText}`);
        }

        const startData = await startResponse.json();
        const jobId = startData.id;

        if (!jobId) {
            // If synchronous response (sometimes happens for single page), handle it? 
            // But crawl is usually async.
            if (startData.data) {
                return startData.data.map((item: any) => ({
                    url: item.metadata?.sourceURL || url,
                    markdown: item.markdown
                }));
            }
            throw new Error("No job ID returned from Firecrawl");
        }

        // 2. Poll for results
        while (true) {
            const statusResponse = await fetch(`https://api.firecrawl.dev/v1/crawl/${jobId}`, {
                headers: {
                    Authorization: `Bearer ${apiKey}`,
                },
            });

            if (!statusResponse.ok) {
                throw new Error("Firecrawl status check failed");
            }

            const statusData = await statusResponse.json();
            const status = statusData.status;

            if (status === "completed") {
                return statusData.data.map((item: any) => ({
                    url: item.metadata?.sourceURL || item.url,
                    markdown: item.markdown,
                }));
            }

            if (status === "failed") {
                throw new Error("Firecrawl job failed");
            }

            // Wait 2s
            await new Promise((resolve) => setTimeout(resolve, 2000));
        }
    },
};
</file>

<file path="lib/ai/gemini.ts">
import { GoogleGenerativeAI } from "@google/generative-ai";
import { GoogleAIFileManager, FileState } from "@google/generative-ai/server";
import fs from "fs";
import path from "path";
import os from "os";

// Initialize Gemini
const genAI = new GoogleGenerativeAI(process.env.GOOGLE_API_KEY!);
const fileManager = new GoogleAIFileManager(process.env.GOOGLE_API_KEY!);

export const GeminiService = {
    /**
     * Uploads a file to Gemini Files API
     */
    async uploadFile(file: File): Promise<{ uri: string; name: string; mimeType: string }> {
        // We need to write the File object to a temp path because GoogleAIFileManager reads from path
        // In a real Vercel environment with limited fs, this might need buffer handling or /tmp
        const tempDir = os.tmpdir();
        const tempPath = path.join(tempDir, file.name);

        // Convert File to Buffer
        const arrayBuffer = await file.arrayBuffer();
        const buffer = Buffer.from(arrayBuffer);
        fs.writeFileSync(tempPath, buffer);

        try {
            const uploadResponse = await fileManager.uploadFile(tempPath, {
                mimeType: file.type,
                displayName: file.name,
            });

            // Poll for active state
            let fileRecord = await fileManager.getFile(uploadResponse.file.name);
            while (fileRecord.state === FileState.PROCESSING) {
                await new Promise((resolve) => setTimeout(resolve, 2000));
                fileRecord = await fileManager.getFile(uploadResponse.file.name);
            }

            if (fileRecord.state === FileState.FAILED) {
                throw new Error("Gemini file processing failed");
            }

            return {
                uri: fileRecord.uri,
                name: fileRecord.name,
                mimeType: fileRecord.mimeType,
            };
        } finally {
            // Cleanup temp file
            if (fs.existsSync(tempPath)) {
                fs.unlinkSync(tempPath);
            }
        }
    },

    /**
     * Deletes a file from Gemini
     */
    async deleteFile(name: string) {
        try {
            await fileManager.deleteFile(name);
        } catch (error) {
            console.error("Error deleting file from Gemini:", error);
            // Suppress error if already deleted or not found
        }
    },

    /**
     * Generates an answer using File Search
     */
    async generateAnswer(query: string, fileUris: string[]) {
        const model = genAI.getGenerativeModel({
            model: "gemini-1.5-flash",
            tools: [
                {
                    // @ts-ignore - Valid in newer SDK versions
                    fileSearch: {},
                },
            ],
        });

        // Create a chat session with the files
        const result = await model.generateContent({
            contents: [
                {
                    role: "user",
                    parts: [
                        ...fileUris.map((uri) => ({
                            fileData: {
                                mimeType: "application/pdf", // Simplified for now, should map
                                fileUri: uri
                            }
                        })),
                        { text: query },
                    ],
                },
            ],
            generationConfig: {
                // @ts-ignore
                temperature: 0.5,
            }
        });

        return result.response.text();
    },
};
</file>

<file path="lib/database.types.ts">
export type Json =
    | string
    | number
    | boolean
    | null
    | { [key: string]: Json | undefined }
    | Json[]

export interface Database {
    public: {
        Tables: {
            organizations: {
                Row: {
                    id: string
                    name: string
                    stripe_customer_id: string | null
                    subscription_status: string | null
                    plan_id: string | null
                    messages_count: number | null
                    last_reset: string | null
                    created_at: string
                }
                Insert: {
                    id?: string
                    name: string
                    stripe_customer_id?: string | null
                    subscription_status?: string | null
                    plan_id?: string | null
                    messages_count?: number | null
                    last_reset?: string | null
                    created_at?: string
                }
                Update: {
                    id?: string
                    name?: string
                    stripe_customer_id?: string | null
                    subscription_status?: string | null
                    plan_id?: string | null
                    messages_count?: number | null
                    last_reset?: string | null
                    created_at?: string
                }
            }
            profiles: {
                Row: {
                    id: string
                    email: string | null
                    org_id: string | null
                    role: string | null
                    created_at: string
                }
                Insert: {
                    id: string
                    email?: string | null
                    org_id?: string | null
                    role?: string | null
                    created_at?: string
                }
                Update: {
                    id?: string
                    email?: string | null
                    org_id?: string | null
                    role?: string | null
                    created_at?: string
                }
            }
            chatbots: {
                Row: {
                    id: string
                    org_id: string
                    name: string
                    config: Json | null
                    status: string | null
                    created_at: string
                    updated_at: string
                }
                Insert: {
                    id?: string
                    org_id: string
                    name: string
                    config?: Json | null
                    status?: string | null
                    created_at?: string
                    updated_at?: string
                }
                Update: {
                    id?: string
                    org_id?: string
                    name?: string
                    config?: Json | null
                    status?: string | null
                    created_at?: string
                    updated_at?: string
                }
            }
            knowledge_base_sources: {
                Row: {
                    id: string
                    chatbot_id: string
                    type: "file" | "url"
                    content_uri: string | null
                    source_url: string | null
                    status: string | null
                    created_at: string
                }
                Insert: {
                    id?: string
                    chatbot_id: string
                    type: "file" | "url"
                    content_uri?: string | null
                    source_url?: string | null
                    status?: string | null
                    created_at?: string
                }
                Update: {
                    id?: string
                    chatbot_id?: string
                    type?: "file" | "url"
                    content_uri?: string | null
                    source_url?: string | null
                    status?: string | null
                    created_at?: string
                }
            }
            conversations: {
                Row: {
                    id: string
                    chatbot_id: string
                    visitor_id: string | null
                    status: "ai" | "waiting" | "active" | "closed"
                    assigned_to: string | null
                    unread_count: number
                    created_at: string
                }
                Insert: {
                    id?: string
                    chatbot_id: string
                    visitor_id?: string | null
                    status?: "ai" | "waiting" | "active" | "closed"
                    assigned_to?: string | null
                    unread_count?: number
                    created_at?: string
                }
                Update: {
                    id?: string
                    chatbot_id?: string
                    visitor_id?: string | null
                    status?: "ai" | "waiting" | "active" | "closed"
                    assigned_to?: string | null
                    unread_count?: number
                    created_at?: string
                }
            }
            messages: {
                Row: {
                    id: string
                    conversation_id: string
                    role: "user" | "assistant" | "system"
                    content: string
                    created_at: string
                }
                Insert: {
                    id?: string
                    conversation_id: string
                    role: "user" | "assistant" | "system"
                    content: string
                    created_at?: string
                }
                Update: {
                    id?: string
                    conversation_id?: string
                    role?: "user" | "assistant" | "system"
                    content?: string
                    created_at?: string
                }
            }
            products: {
                Row: {
                    id: string
                    active: boolean | null
                    name: string | null
                    description: string | null
                    image: string | null
                    metadata: Json | null
                }
                Insert: {
                    id: string
                    active?: boolean | null
                    name?: string | null
                    description?: string | null
                    image?: string | null
                    metadata?: Json | null
                }
                Update: {
                    id?: string
                    active?: boolean | null
                    name?: string | null
                    description?: string | null
                    image?: string | null
                    metadata?: Json | null
                }
            }
            prices: {
                Row: {
                    id: string
                    product_id: string | null
                    active: boolean | null
                    description: string | null
                    unit_amount: number | null
                    currency: string | null
                    type: "one_time" | "recurring" | null
                    interval: "day" | "week" | "month" | "year" | null
                    interval_count: number | null
                    trial_period_days: number | null
                    metadata: Json | null
                }
                Insert: {
                    id: string
                    product_id?: string | null
                    active?: boolean | null
                    description?: string | null
                    unit_amount?: number | null
                    currency?: string | null
                    type?: "one_time" | "recurring" | null
                    interval?: "day" | "week" | "month" | "year" | null
                    interval_count?: number | null
                    trial_period_days?: number | null
                    metadata?: Json | null
                }
                Update: {
                    id?: string
                    product_id?: string | null
                    active?: boolean | null
                    description?: string | null
                    unit_amount?: number | null
                    currency?: string | null
                    type?: "one_time" | "recurring" | null
                    interval?: "day" | "week" | "month" | "year" | null
                    interval_count?: number | null
                    trial_period_days?: number | null
                    metadata?: Json | null
                }
            }
        }
    }
}
</file>

<file path="lib/stripe.ts">
import Stripe from 'stripe';

// if (!process.env.STRIPE_SECRET_KEY) {
//     throw new Error('STRIPE_SECRET_KEY is missing. Please set it in your .env.local file.');
// }

export const stripe = new Stripe(process.env.STRIPE_SECRET_KEY || 'dummy', {
    appInfo: {
        name: 'RAG Chatbot SaaS',
        version: '0.1.0'
    },
    typescript: true,
});
</file>

<file path="lib/utils.ts">
import { type ClassValue, clsx } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
    return twMerge(clsx(inputs))
}
</file>

<file path="public/file.svg">
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>
</file>

<file path="public/globe.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>
</file>

<file path="public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="public/vercel.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>
</file>

<file path="public/widget.js">
(function () {
    const script = document.currentScript;
    const chatbotId = script.getAttribute("data-chatbot-id");
    const host = new URL(script.src).origin;

    if (!chatbotId) {
        console.error("Chatbot Widget: Missing data-chatbot-id attribute");
        return;
    }

    // Create Container
    const container = document.createElement("div");
    container.id = "rag-chatbot-widget";
    container.style.position = "fixed";
    container.style.bottom = "20px";
    container.style.right = "20px";
    container.style.zIndex = "9999";
    container.style.display = "flex";
    container.style.flexDirection = "column";
    container.style.alignItems = "flex-end";
    container.style.gap = "10px";
    document.body.appendChild(container);

    // Create IFrame (Hidden initially)
    const iframe = document.createElement("iframe");
    iframe.src = `${host}/embed/${chatbotId}`;
    iframe.style.width = "400px";
    iframe.style.height = "600px";
    iframe.style.maxHeight = "80vh";
    iframe.style.maxWidth = "calc(100vw - 40px)";
    iframe.style.border = "none";
    iframe.style.borderRadius = "12px";
    iframe.style.boxShadow = "0 4px 12px rgba(0,0,0,0.15)";
    iframe.style.display = "none";
    container.appendChild(iframe);

    // Create Launcher Button
    const button = document.createElement("button");
    button.innerHTML = `
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg>
  `;
    button.style.width = "56px";
    button.style.height = "56px";
    button.style.borderRadius = "50%";
    button.style.backgroundColor = "#000";
    button.style.color = "#fff";
    button.style.border = "none";
    button.style.cursor = "pointer";
    button.style.display = "flex";
    button.style.alignItems = "center";
    button.style.justifyContent = "center";
    button.style.boxShadow = "0 4px 12px rgba(0,0,0,0.15)";
    button.style.transition = "transform 0.2s";

    let isOpen = false;

    button.onclick = () => {
        isOpen = !isOpen;
        iframe.style.display = isOpen ? "block" : "none";
        button.innerHTML = isOpen
            ? `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>`
            : `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg>`;
    };

    container.appendChild(button);
})();
</file>

<file path="public/window.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>
</file>

<file path="supabase/migrations/0001_sources.sql">
-- Knowledge Base Sources Table
create table knowledge_base_sources (
  id uuid default uuid_generate_v4() primary key,
  chatbot_id uuid references chatbots on delete cascade not null,
  type text not null check (type in ('file', 'url')),
  content_uri text, -- Gemini URI
  source_url text, -- Original filename or URL
  status text default 'pending', -- pending, indexed, failed
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- RLS
alter table knowledge_base_sources enable row level security;

create policy "Users can view own chatbot sources"
  on knowledge_base_sources for select
  using (
    chatbot_id in (
      select id from chatbots where org_id in (
        select org_id from profiles where id = auth.uid()
      )
    )
  );

create policy "Users can insert own chatbot sources"
  on knowledge_base_sources for insert
  with check (
    chatbot_id in (
      select id from chatbots where org_id in (
        select org_id from profiles where id = auth.uid()
      )
    )
  );

create policy "Users can delete own chatbot sources"
  on knowledge_base_sources for delete
  using (
    chatbot_id in (
      select id from chatbots where org_id in (
        select org_id from profiles where id = auth.uid()
      )
    )
  );
</file>

<file path="supabase/migrations/0002_chat.sql">
-- Conversations Table
create table conversations (
  id uuid default uuid_generate_v4() primary key,
  chatbot_id uuid references chatbots on delete cascade not null,
  visitor_id text, -- optional tracking
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Messages Table
create table messages (
  id uuid default uuid_generate_v4() primary key,
  conversation_id uuid references conversations on delete cascade not null,
  role text not null check (role in ('user', 'assistant', 'system')),
  content text not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- RLS
alter table conversations enable row level security;
alter table messages enable row level security;

-- OWNER POLICIES (Dashboard access)
create policy "Owners can view own chatbot conversations"
  on conversations for select
  using (
    chatbot_id in (
      select id from chatbots where org_id in (
        select org_id from profiles where id = auth.uid()
      )
    )
  );

create policy "Owners can view own conversation messages"
  on messages for select
  using (
    conversation_id in (
      select id from conversations where chatbot_id in (
        select id from chatbots where org_id in (
          select org_id from profiles where id = auth.uid()
        )
      )
    )
  );
</file>

<file path="supabase/migrations/0003_realtime.sql">
-- Create ENUM for conversation status IF NOT EXISTS (but Postgres doesn't support IF NOT EXISTS for TYPE easily, so we usually just create it or use text check)
-- Simplest is to use text constraint or try create type catching error.
-- We will use text check constraint for simplicity and robustness in migrations.

ALTER TABLE conversations 
ADD COLUMN status text DEFAULT 'ai' CHECK (status IN ('ai', 'waiting', 'active', 'closed')),
ADD COLUMN assigned_to uuid REFERENCES profiles(id),
ADD COLUMN unread_count integer DEFAULT 0;

-- Enable Realtime
-- Note: 'supabase_realtime' publication exists by default in Supabase projects.
ALTER PUBLICATION supabase_realtime ADD TABLE messages;
ALTER PUBLICATION supabase_realtime ADD TABLE conversations;
</file>

<file path="supabase/migrations/0004_stripe.sql">
-- Create Products table to sync from Stripe
create table products (
  id text primary key,
  active boolean,
  name text,
  description text,
  image text,
  metadata jsonb
);

-- Create Prices table to sync from Stripe
create table prices (
  id text primary key,
  product_id text references products,
  active boolean,
  unit_amount bigint,
  currency text check (char_length(currency) = 3),
  type text,
  interval text,
  interval_count integer,
  trial_period_days integer,
  metadata jsonb
);

-- Alter organizations to track subscription and usage
alter table organizations
add column stripe_customer_id text,
add column subscription_status text default 'free',
add column plan_id text,
add column messages_count integer default 0,
add column last_reset timestamp with time zone default now();

-- Enable RLS for new tables (public read-only, service role write)
alter table products enable row level security;
alter table prices enable row level security;

create policy "Allow public read access" on products for select using (true);
create policy "Allow public read access" on prices for select using (true);
</file>

<file path="supabase/migrations/0005_roles_and_2fa.sql">
-- Add super_admin role support to profiles
alter table public.profiles
  drop constraint if exists profiles_role_check;

alter table public.profiles
  add constraint profiles_role_check check (role in ('member', 'admin', 'super_admin'));

-- Create function to auto-assign super_admin role to ThomasPerdana@gmail.com
create or replace function public.handle_super_admin()
returns trigger
language plpgsql
security definer set search_path = public
as $$
begin
  if new.email = 'ThomasPerdana@gmail.com' then
    update public.profiles
    set role = 'super_admin'
    where id = new.id;
  end if;
  return new;
end;
$$;

-- Trigger to check for super admin on profile creation
create trigger on_profile_created_super_admin
  after insert on public.profiles
  for each row execute procedure public.handle_super_admin();

-- 2FA Support (using standard TOTP factors in auth.mfa_factors)
-- No extra schema needed for basic TOTP as Supabase handles it in auth schema,
-- but we might want to store recovery codes or status in profiles if we want custom UI state,
-- though usually querying auth.mfa_factors is better. 
-- For this MVP, we will rely on Supabase Auth API for 2FA status.

-- RLS Policies for Super Admin

-- Super Admin can view all profiles
create policy "Super Admins can view all profiles"
  on profiles for select
  using (
    (select role from profiles where id = auth.uid()) = 'super_admin'
  );

-- Super Admin can update all profiles
create policy "Super Admins can update all profiles"
  on profiles for update
  using (
    (select role from profiles where id = auth.uid()) = 'super_admin'
  );

-- Super Admin can view all organizations
create policy "Super Admins can view all organizations"
  on organizations for select
  using (
    (select role from profiles where id = auth.uid()) = 'super_admin'
  );

-- Super Admin can update all organizations
create policy "Super Admins can update all organizations"
  on organizations for update
  using (
    (select role from profiles where id = auth.uid()) = 'super_admin'
  );

-- Super Admin can delete all organizations
create policy "Super Admins can delete all organizations"
  on organizations for delete
  using (
    (select role from profiles where id = auth.uid()) = 'super_admin'
  );

-- Super Admin can view all chatbots
create policy "Super Admins can view all chatbots"
  on chatbots for select
  using (
    (select role from profiles where id = auth.uid()) = 'super_admin'
  );

-- Super Admin can update all chatbots
create policy "Super Admins can update all chatbots"
  on chatbots for update
  using (
    (select role from profiles where id = auth.uid()) = 'super_admin'
  );

-- Super Admin can delete all chatbots
create policy "Super Admins can delete all chatbots"
  on chatbots for delete
  using (
    (select role from profiles where id = auth.uid()) = 'super_admin'
  );
</file>

<file path="supabase/schema.sql">
-- Enable UUID extension
create extension if not exists "uuid-ossp";

-- Organizations Table
create table organizations (
  id uuid default uuid_generate_v4() primary key,
  name text not null,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Profiles Table (Links to auth.users)
create table profiles (
  id uuid references auth.users on delete cascade not null primary key,
  email text,
  org_id uuid references organizations on delete set null,
  role text default 'member',
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Chatbots Table
create table chatbots (
  id uuid default uuid_generate_v4() primary key,
  org_id uuid references organizations on delete cascade not null,
  name text not null,
  config jsonb default '{}'::jsonb,
  status text default 'active',
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at timestamp with time zone default timezone('utc'::text, now()) not null
);

-- Enable RLS
alter table organizations enable row level security;
alter table profiles enable row level security;
alter table chatbots enable row level security;

-- RLS Policies

-- Profiles: Users can view/edit their own profile
create policy "Users can view own profile"
  on profiles for select
  using ( auth.uid() = id );

create policy "Users can update own profile"
  on profiles for update
  using ( auth.uid() = id );

-- Organizations: Users can view their own organization
create policy "Users can view own organization"
  on organizations for select
  using (
    id in (
      select org_id from profiles where id = auth.uid()
    )
  );

-- Chatbots: Users can view chatbots in their organization
create policy "Users can view org chatbots"
  on chatbots for select
  using (
    org_id in (
      select org_id from profiles where id = auth.uid()
    )
  );

create policy "Users can insert org chatbots"
  on chatbots for insert
  with check (
    org_id in (
      select org_id from profiles where id = auth.uid()
    )
  );

create policy "Users can update org chatbots"
  on chatbots for update
  using (
    org_id in (
      select org_id from profiles where id = auth.uid()
    )
  );

create policy "Users can delete org chatbots"
  on chatbots for delete
  using (
    org_id in (
      select org_id from profiles where id = auth.uid()
    )
  );

-- Function to handle new user signup
create or replace function public.handle_new_user()
returns trigger
language plpgsql
security definer set search_path = public
as $$
declare
  new_org_id uuid;
begin
  -- Create a new organization for the user
  insert into public.organizations (name)
  values (new.email || '''s Org')
  returning id into new_org_id;

  -- Create a profile for the user linked to the new org
  insert into public.profiles (id, email, org_id, role)
  values (new.id, new.email, new_org_id, 'admin');

  return new;
end;
$$;

-- Trigger for new user signup
create or replace trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();
</file>

<file path="components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "app/globals.css",
    "baseColor": "slate",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils"
  }
}
</file>

<file path="eslint.config.mjs">
import { defineConfig, globalIgnores } from "eslint/config";
import nextVitals from "eslint-config-next/core-web-vitals";
import nextTs from "eslint-config-next/typescript";

const eslintConfig = defineConfig([
  ...nextVitals,
  ...nextTs,
  // Override default ignores of eslint-config-next.
  globalIgnores([
    // Default ignores of eslint-config-next:
    ".next/**",
    "out/**",
    "build/**",
    "next-env.d.ts",
  ]),
]);

export default eslintConfig;
</file>

<file path="middleware.ts">
import { type NextRequest } from 'next/server'
import { updateSession } from '@/utils/supabase/middleware'

export async function middleware(request: NextRequest) {
    return await updateSession(request)
}

export const config = {
    matcher: [
        /*
         * Match all request paths except for the ones starting with:
         * - _next/static (static files)
         * - _next/image (image optimization files)
         * - favicon.ico (favicon file)
         * Feel free to modify this pattern to include more paths.
         */
        '/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)',
    ],
}
</file>

<file path="next.config.ts">
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;
</file>

<file path="postcss.config.mjs">
const config = {
  plugins: {
    "@tailwindcss/postcss": {},
  },
};

export default config;
</file>

<file path="README.md">
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "react-jsx",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": [
        "./*"
      ]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    ".next/dev/types/**/*.ts",
    "**/*.mts"
  ],
  "exclude": [
    "node_modules"
  ]
}
</file>

<file path=".gsd/SPEC.md">
# SPEC.md ‚Äî Project Specification

> **Status**: `FINALIZED`

## Vision
Empower website owners with a powerful, easy-to-integrate, and customizable chatbot that provides instant, accurate, and context-aware support to their users. By leveraging a sophisticated Retrieval-Augmented Generation (RAG) model (Google Gemini), the chatbot will answer user queries based on a custom knowledge base, enhancing engagement and reducing support burden.

## Goals
1. **Core Platform**: Build a multi-tenant SaaS dashboard for managing chatbots, knowledge bases, and subscriptions.
2. **RAG Engine**: Implement a robust ingestion pipeline using Gemini File Search and Firecrawl to create accurate knowledge bases from files and URLs.
3. **Embeddable Widget**: Develop a lightweight, performant, and customizable chat widget that works on any website.
4. **Human Handoff**: specific feature to allow seamless transition from AI to human agents.

## Non-Goals (Out of Scope for v1)
- Advanced Analytics Dashboard (Post-v1)
- Proactive Chat Triggers (Post-v1)
- CRM Integrations (HubSpot/Salesforce) (Post-v1)
- Data sources beyond PDF, TXT, and Web Crawl (e.g. Notion, Drive) (Post-v1)
- Data sources beyond PDF, TXT, and Web Crawl (e.g. Notion, Drive) (Post-v1)
- Multi-language auto-detection (Post-v1)

## Advanced Auth & Admin (Phase 6)
- **REQ-09: Advanced Auth**: Google Social Login, Remember Me, TOTP 2FA, Password Reset.
- **REQ-10: Admin Roles**:
    - **Super Admin**: (ThomasPerdana@gmail.com) Immutable, full access to all orgs/users.
    - **Admin**: Full access to own org features.
    - **Admin Dashboard**: Super admin interface to CRUD users.

## Users
- **Account Owners (Admins)**: SMBs, SaaS founders, Creators who set up the bot, manage subscriptions, and provide support.
- **End Users**: Visitors on the customers' websites interacting with the chatbot.
- **Support Agents**: Humans responding to handoff requests (often the same as Account Owners in v1).

## Constraints
- **Tech Stack**: Next.js (App Router), Supabase (Auth/DB/Realtime), Google Gemini API, Stripe, Firecrawl.
- **Performance**: Widget script < 100KB, AI Time-to-first-token < 2s.
- **Security**: Strict Row-Level Security (RLS) for multi-tenancy.
- **Deployment**: Vercel.

## Success Criteria
- [ ] User can sign up and create a chatbot organization.
- [ ] User can upload a PDF and crawl a URL, successfully indexing them into Gemini.
- [ ] Widget works when embedded on a verified external HTML page.
- [ ] Chatbot answers queries accurately based *only* on the provided knowledge interactions.
- [ ] "Talk to human" triggers a real-time alert/handoff state in the dashboard.
- [ ] Stripe subscription limits are enforced (e.g. message caps).
</file>

<file path="app/api/chat/route.ts">
import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";
import { RAGService } from "@/lib/ai/rag";

export async function POST(request: Request) {
    try {
        const { chatbotId, message, conversationId } = await request.json();

        if (!chatbotId || !message) {
            return new NextResponse("Missing chatbotId or message", { status: 400 });
        }

        // Initialize Admin Client (Bypass RLS for public chat)
        const supabase = createClient(
            process.env.NEXT_PUBLIC_SUPABASE_URL!,
            process.env.SUPABASE_SERVICE_ROLE_KEY!
        );

        let activeConversationId = conversationId;

        // 1. Create/Validate Conversation
        if (!activeConversationId) {
            const { data: conv, error: convError } = await supabase
                .from("conversations")
                .insert({ chatbot_id: chatbotId })
                .select()
                .single();

            if (convError || !conv) {
                throw new Error("Failed to create conversation");
            }
            activeConversationId = conv.id;
        }

        // 2. Check Conversation Status
        const { data: conversation } = await supabase
            .from("conversations")
            .select("status")
            .eq("id", activeConversationId)
            .single();

        const status = conversation?.status || 'ai';

        // 3. Store User Message
        await supabase.from("messages").insert({
            conversation_id: activeConversationId,
            role: "user",
            content: message
        });

        if (status === 'active' || status === 'waiting') {
            // Handoff mode: distinct logic
            return NextResponse.json({
                conversationId: activeConversationId,
                message: null, // No AI response
                status
            });
        }


        // 4. Check Usage Limits
        const { data: chatbot } = await supabase
            .from('chatbots')
            .select('org_id')
            .eq('id', chatbotId)
            .single();

        if (!chatbot) {
            return new NextResponse("Chatbot not found", { status: 404 });
        }

        const { data: org } = await supabase
            .from('organizations')
            .select('subscription_status, messages_count')
            .eq('id', chatbot.org_id)
            .single();

        if (org) {
            const limit = org.subscription_status === 'active' ? 100000 : 50;
            if ((org.messages_count || 0) >= limit) {
                return NextResponse.json({
                    conversationId: activeConversationId,
                    message: "Usage limit reached. Please upgrade your plan.",
                    status: 'limit_reached'
                });
            }
        }

        // 5. Generate Answer (only if status is 'ai')
        const answer = await RAGService.chat(chatbotId, message);

        // 6. Store Assistant Message
        await supabase.from("messages").insert({
            conversation_id: activeConversationId,
            role: "assistant",
            content: answer
        });

        // 7. Increment Usage
        if (org) {
            await supabase.from('organizations').update({ messages_count: (org.messages_count || 0) + 1 }).eq('id', chatbot.org_id);
        }

        return NextResponse.json({
            conversationId: activeConversationId,
            message: answer,
            status: 'ai'
        });

    } catch (error) {
        console.error("Chat error:", error);
        return new NextResponse("Internal Server Error", { status: 500 });
    }
}
</file>

<file path="app/login/page.tsx">
import { headers } from "next/headers";
import { createClient } from "@/utils/supabase/server";
import { redirect } from "next/navigation";
import { Label } from "@/components/ui/label";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import Link from "next/link";
import { GoogleSignIn } from "@/components/auth/google-sign-in";

export default function Login({
    searchParams,
}: {
    searchParams: { message: string };
}) {
    const signIn = async (formData: FormData) => {
        "use server";

        const email = formData.get("email") as string;
        const password = formData.get("password") as string;
        const remember = formData.get("remember");
        const supabase = await createClient();

        // Note: Supabase SSR handles session persistence via cookies automatically.
        // There isn't a direct "remember me" flag in signInWithPassword on the server
        // that alters the cookie expiration dynamically in this pattern easily without custom cookie logic.
        // However, standard Supabase sessions are persistent by default (refresh tokens).

        const { error } = await supabase.auth.signInWithPassword({
            email,
            password,
        });

        if (error) {
            return redirect("/login?message=Could not authenticate user");
        }

        return redirect("/dashboard");
    };

    return (
        <div className="flex-1 flex flex-col w-full px-8 sm:max-w-md justify-center gap-2">
            <Link
                href="/"
                className="absolute left-8 top-8 py-2 px-4 rounded-md no-underline text-foreground bg-btn-background hover:bg-btn-background-hover flex items-center group text-sm"
            >
                <svg
                    xmlns="http://www.w3.org/2000/svg"
                    width="24"
                    height="24"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    strokeWidth="2"
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    className="mr-2 h-4 w-4 transition-transform group-hover:-translate-x-1"
                >
                    <polyline points="15 18 9 12 15 6" />
                </svg>
                Back
            </Link>

            <form
                className="animate-in flex-1 flex flex-col w-full justify-center gap-2 text-foreground"
                action={signIn}
            >
                <h1 className="text-2xl font-bold mb-4">Login</h1>

                <Label className="text-md" htmlFor="email">
                    Email
                </Label>
                <Input
                    className="rounded-md px-4 py-2 bg-inherit border mb-6"
                    name="email"
                    placeholder="you@example.com"
                    required
                />
                <Label className="text-md" htmlFor="password">
                    Password
                </Label>
                <Input
                    className="rounded-md px-4 py-2 bg-inherit border mb-2"
                    type="password"
                    name="password"
                    placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
                    required
                />

                <div className="flex justify-between items-center mb-6">
                    <div className="flex items-center space-x-2">
                        <input
                            type="checkbox"
                            id="remember"
                            name="remember"
                            className="rounded border-gray-300 text-blue-600 focus:ring-blue-500"
                        />
                        <label
                            htmlFor="remember"
                            className="text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
                        >
                            Remember me
                        </label>
                    </div>
                    <Link href="/forgot-password" className="text-sm text-blue-500 hover:underline">
                        Forgot password?
                    </Link>
                </div>

                <Button className="bg-green-700 rounded-md px-4 py-2 text-foreground mb-4 w-full">
                    Sign In
                </Button>

                <div className="relative">
                    <div className="absolute inset-0 flex items-center">
                        <span className="w-full border-t border-gray-300" />
                    </div>
                    <div className="relative flex justify-center text-xs uppercase">
                        <span className="bg-background px-2 text-muted-foreground">
                            Or continue with
                        </span>
                    </div>
                </div>

                <GoogleSignIn />

                <div className="text-center text-sm mt-4">
                    Don't have an account? <Link href="/signup" className="underline">Sign Up</Link>
                </div>

                {searchParams?.message && (
                    <p className="mt-4 p-4 bg-foreground/10 text-foreground text-center">
                        {searchParams.message}
                    </p>
                )}
            </form>
        </div>
    );
}
</file>

<file path="components/landing/navbar.tsx">
"use client";

import Link from "next/link";
import { User } from "@supabase/supabase-js";
import { UserNav } from "@/components/landing/user-nav";
import { Button } from "@/components/ui/button";

interface NavbarProps {
    user: User | null;
    role?: string | null;
}

export function Navbar({ user, role }: NavbarProps) {
    return (
        <header className="sticky top-0 z-50 w-full border-b bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60">
            <div className="container flex h-14 items-center">
                <div className="mr-4 hidden md:flex">
                    <Link href="/" className="mr-6 flex items-center space-x-2">
                        <span className="hidden font-bold sm:inline-block">
                            RAGMatch
                        </span>
                    </Link>
                    <nav className="flex items-center space-x-6 text-sm font-medium">
                        <Link
                            href="/"
                            className="transition-colors hover:text-foreground/80 text-foreground"
                        >
                            Home
                        </Link>
                        {/* Add more links here if needed */}
                    </nav>
                </div>
                <div className="flex flex-1 items-center justify-between space-x-2 md:justify-end">
                    <div className="w-full flex-1 md:w-auto md:flex-none">
                        {/* Search or other items */}
                    </div>
                    <nav className="flex items-center gap-2">
                        {user ? (
                            <UserNav user={user} role={role} />
                        ) : (
                            <>
                                <Link href="/login">
                                    <Button variant="ghost" size="sm">
                                        Login
                                    </Button>
                                </Link>
                                <Link href="/signup">
                                    <Button size="sm">
                                        Sign Up
                                    </Button>
                                </Link>
                            </>
                        )}
                    </nav>
                </div>
            </div>
        </header>
    );
}
</file>

<file path="components/landing/user-nav.tsx">
"use client";

import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Button } from "@/components/ui/button";
import {
    DropdownMenu,
    DropdownMenuContent,
    DropdownMenuGroup,
    DropdownMenuItem,
    DropdownMenuLabel,
    DropdownMenuSeparator,
    DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { createClient } from "@/utils/supabase/client";
import { User } from "@supabase/supabase-js";
import { useRouter } from "next/navigation";
import Link from "next/link";
import { LogOut, User as UserIcon, LayoutDashboard, Settings } from "lucide-react";

interface UserNavProps {
    user: User;
    role?: string | null;
}

export function UserNav({ user, role }: UserNavProps) {
    const router = useRouter();
    const supabase = createClient();

    const handleSignOut = async () => {
        await supabase.auth.signOut();
        router.refresh();
    };

    return (
        <DropdownMenu>
            <DropdownMenuTrigger asChild>
                <Button variant="ghost" className="relative h-8 w-8 rounded-full">
                    <Avatar className="h-8 w-8">
                        <AvatarImage src={user.user_metadata?.avatar_url} alt={user.email || ""} />
                        <AvatarFallback>{user.email?.slice(0, 2).toUpperCase()}</AvatarFallback>
                    </Avatar>
                </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent className="w-56" align="end" forceMount>
                <DropdownMenuLabel className="font-normal">
                    <div className="flex flex-col space-y-1">
                        <p className="text-sm font-medium leading-none">Account</p>
                        <p className="text-xs leading-none text-muted-foreground">
                            {user.email}
                        </p>
                    </div>
                </DropdownMenuLabel>
                <DropdownMenuSeparator />
                <DropdownMenuGroup>
                    {role === "super_admin" && (
                        <Link href="/admin">
                            <DropdownMenuItem>
                                <LayoutDashboard className="mr-2 h-4 w-4" />
                                <span>Admin Dashboard</span>
                            </DropdownMenuItem>
                        </Link>
                    )}
                    <Link href="/dashboard">
                        <DropdownMenuItem>
                            <LayoutDashboard className="mr-2 h-4 w-4" />
                            <span>Dashboard</span>
                        </DropdownMenuItem>
                    </Link>
                    <Link href="/dashboard/settings">
                        <DropdownMenuItem>
                            <Settings className="mr-2 h-4 w-4" />
                            <span>Settings</span>
                        </DropdownMenuItem>
                    </Link>
                </DropdownMenuGroup>
                <DropdownMenuSeparator />
                <DropdownMenuItem onClick={handleSignOut}>
                    <LogOut className="mr-2 h-4 w-4" />
                    <span>Log out</span>
                </DropdownMenuItem>
            </DropdownMenuContent>
        </DropdownMenu>
    );
}
</file>

<file path="components/chat-interface.tsx">
"use client";

import { useState, useRef, useEffect } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Send, Bot, User } from "lucide-react";
import { cn } from "@/lib/utils";

import { useRealtimeChat } from "@/hooks/use-realtime-chat";

type Message = {
    id: string;
    role: "user" | "assistant";
    content: string;
};

export function ChatInterface({
    chatbotId,
    initialMessages = [],
}: {
    chatbotId: string;
    initialMessages?: Message[];
}) {
    const [conversationId, setConversationId] = useState<string | null>(null);
    const { messages: realtimeMessages } = useRealtimeChat(conversationId);

    // We combine initial messages (history) with realtime messages
    // Ideally, realtimeMessages should handle all messages if we pass conversationId. 
    // But initially conversationId is null.
    // So we rely on local 'messages' state until conversationId is established?
    // Actually, once conversationId is established, useRealtimeChat fetches all messages.
    // So distinct modes:
    // 1. No conversation -> local state
    // 2. Conversation -> realtime state

    const [localMessages, setLocalMessages] = useState<Message[]>(initialMessages);
    const [input, setInput] = useState("");
    const [isLoading, setIsLoading] = useState(false);
    const scrollRef = useRef<HTMLDivElement>(null);
    const [status, setStatus] = useState<'ai' | 'waiting' | 'active'>('ai');

    const messages = conversationId ? realtimeMessages : localMessages;

    useEffect(() => {
        if (scrollRef.current) {
            scrollRef.current.scrollTop = scrollRef.current.scrollHeight;
        }
    }, [messages]);

    async function handleSubmit(e: React.FormEvent) {
        e.preventDefault();
        if (!input.trim() || isLoading) return;

        const content = input;

        // Optimistic update for local only (if no conversation yet)
        if (!conversationId) {
            setLocalMessages(prev => [...prev, {
                id: Date.now().toString(),
                role: 'user',
                content
            }]);
        }

        setInput("");
        setIsLoading(true);

        try {
            const res = await fetch("/api/chat", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                    chatbotId,
                    message: content,
                    conversationId,
                }),
            });

            if (!res.ok) throw new Error("Failed to send message");

            const data = await res.json();

            if (data.conversationId && !conversationId) {
                setConversationId(data.conversationId);
            }

            if (data.status) {
                setStatus(data.status);
            }

            // If message is returned (AI response), add it.
            // But if we switched to realtime (conversationId set), the hook will pick it up.
            // The hook subscribes to INSERTs.
            // The API inserts the AI message.
            // So we might duplicate if we manually add it AND hook adds it.
            // So if conversationId is set, DO NOT manually add response.

            if (!data.conversationId && data.message) {
                // Fallback if no conversation ID returned (unlikely)
                setLocalMessages(prev => [...prev, {
                    id: (Date.now() + 1).toString(),
                    role: 'assistant',
                    content: data.message
                }]);
            }

        } catch (error) {
            console.error(error);
        } finally {
            setIsLoading(false);
        }
    }

    async function requestAgent() {
        if (!conversationId) return; // Must start chat first? Or validation needed.

        try {
            // We can call a server action or an API route to update status.
            // For now, let's reuse a simple API or supabase client if available.
            // Since this is a client component, we can import createClient.
            const { createClient } = await import("@/utils/supabase/client");
            const supabase = createClient();

            await (supabase.from("conversations") as any).update({ status: 'waiting' }).eq('id', conversationId);
            setStatus('waiting');
        } catch (e) {
            console.error("Failed to request agent", e);
        }
    }

    return (
        <div className="flex flex-col h-screen bg-background text-foreground">
            {/* Header */}
            <div className="p-4 border-b bg-card flex items-center justify-between shadow-sm">
                <div className="flex items-center gap-2">
                    <div className="bg-primary/10 p-2 rounded-full">
                        <Bot className="h-5 w-5 text-primary" />
                    </div>
                    <div>
                        <h3 className="font-semibold text-sm">AI Support</h3>
                        <p className="text-xs text-muted-foreground">
                            {status === 'ai' ? 'Ask me anything' :
                                status === 'waiting' ? 'Waiting for agent...' : 'Talking to Agent'}
                        </p>
                    </div>
                </div>
                {status === 'ai' && conversationId && (
                    <Button size="sm" variant="outline" onClick={requestAgent}>
                        Talk to Human
                    </Button>
                )}
            </div>

            {/* Messages */}
            <div className="flex-1 overflow-y-auto p-4 space-y-4" ref={scrollRef}>
                {messages.length === 0 && (
                    <div className="text-center text-sm text-muted-foreground mt-8">
                        Send a message to start chatting.
                    </div>
                )}
                {messages.map((m) => (
                    <div
                        key={m.id}
                        className={cn(
                            "flex w-max max-w-[80%] flex-col gap-2 rounded-lg px-3 py-2 text-sm",
                            m.role === "user"
                                ? "ml-auto bg-primary text-primary-foreground"
                                : "bg-muted text-muted-foreground"
                        )}
                    >
                        {m.content}
                    </div>
                ))}
                {isLoading && !conversationId && (
                    <div className="flex w-max max-w-[80%] flex-col gap-2 rounded-lg px-3 py-2 text-sm bg-muted text-muted-foreground">
                        <span className="animate-pulse">Thinking...</span>
                    </div>
                )}
            </div>

            {/* Input */}
            <form onSubmit={handleSubmit} className="p-4 border-t bg-background">
                <div className="flex gap-2">
                    <Input
                        value={input}
                        onChange={(e) => setInput(e.target.value)}
                        placeholder="Type your message..."
                        disabled={isLoading && !conversationId}
                        className="flex-1"
                    />
                    <Button type="submit" size="icon" disabled={(isLoading && !conversationId) || !input.trim()}>
                        <Send className="h-4 w-4" />
                        <span className="sr-only">Send</span>
                    </Button>
                </div>
                <div className="text-center mt-2">
                    <p className="text-[10px] text-muted-foreground">Powered by RAG Chatbot</p>
                </div>
            </form>
        </div>
    );
}
</file>

<file path="components/dashboard-nav.tsx">
import Link from "next/link";
import { cn } from "@/lib/utils";

const items = [
    {
        title: "Overview",
        href: "/dashboard",
    },
    {
        title: "Chatbots",
        href: "/dashboard/chatbots",
    },
    {
        title: "Inbox",
        href: "/dashboard/inbox",
    },
    {
        title: "Settings",
        href: "/dashboard/settings",
    },
];

interface DashboardNavProps extends React.HTMLAttributes<HTMLElement> {
    pathname?: string;
}

export function DashboardNav({ className, pathname, ...props }: DashboardNavProps) {
    return (
        <nav
            className={cn(
                "flex space-y-2 lg:flex-col lg:space-x-0 lg:space-y-1",
                className
            )}
            {...props}
        >
            {items.map((item) => (
                <Link
                    key={item.href}
                    href={item.href}
                    className={cn(
                        "justify-start text-sm font-medium transition-colors hover:text-primary px-3 py-2 rounded-md",
                        pathname === item.href
                            ? "bg-muted text-primary"
                            : "text-muted-foreground"
                    )}
                >
                    {item.title}
                </Link>
            ))}
        </nav>
    );
}
</file>

<file path="hooks/use-realtime-chat.ts">
"use client";

import { useEffect, useState } from "react";
import { createClient } from "@/utils/supabase/client";
import { Database } from "@/lib/database.types";

type Message = Database["public"]["Tables"]["messages"]["Row"];

export function useRealtimeChat(conversationId: string | null) {
    const [messages, setMessages] = useState<Message[]>([]);
    const supabase = createClient();

    useEffect(() => {
        if (!conversationId) {
            setMessages([]);
            return;
        }

        // 1. Fetch initial messages
        const fetchMessages = async () => {
            const { data, error } = await supabase
                .from("messages")
                .select("*")
                .eq("conversation_id", conversationId)
                .order("created_at", { ascending: true });

            if (data) {
                setMessages(data);
            }
        };

        fetchMessages();

        // 2. Subscribe to new messages
        const channel = supabase
            .channel(`conversation:${conversationId}`)
            .on(
                "postgres_changes",
                {
                    event: "INSERT",
                    schema: "public",
                    table: "messages",
                    filter: `conversation_id=eq.${conversationId}`,
                },
                (payload) => {
                    const newMessage = payload.new as Message;
                    setMessages((prev) => [...prev, newMessage]);
                }
            )
            .subscribe();

        return () => {
            supabase.removeChannel(channel);
        };
    }, [conversationId, supabase]);

    const sendMessage = async (content: string, role: "user" | "assistant" = "user") => {
        if (!conversationId) return;

        const { error } = await (supabase.from("messages") as any).insert({
            conversation_id: conversationId,
            role,
            content,
        });

        if (error) {
            console.error("Error sending message:", error);
        }
    };

    return { messages, setMessages, sendMessage };
}
</file>

<file path="lib/ai/rag.ts">
import { GeminiService } from "@/lib/ai/gemini";

export const RAGService = {
    async chat(chatbotId: string, query: string): Promise<string> {


        // 1. Fetch sources
        // Note: We use the service role or ensure the calling user has access.
        // Since this is called from API route, we might need a Service Role client if the user is 'anon'
        // But wait, createClient uses cookies. If this is a public chat, it might be anonymous.
        // The RLS allows owners to view sources. Anon users CANNOT view sources.
        // So we need a Service Role client here to fetch sources for the chatbot.
        // HOWEVER, we shouldn't expose sources content to anon, but we use them server-side.

        // For now, let's assume valid session or upgradeto admin for retrieval.
        // Actually better: Use a specific function or just use Service Role for this specific query.
        // I don't have a service_role helper yet.
        // I'll stick to `createClient` but `knowledge_base_sources` RLS prevents anon read.
        // I MUST IMPLEMENT SERVICE ROLE CLIENT for public chat RAG.

        // Temporary: I will assume I need to create a service role client.
        // But I don't want to complicate `utils/supabase/server.ts`.
        // I'll skip RLS check by using `supbase-js` directly with Service Key if needed? 
        // Recommended: Use `createClient` with cookies from headers, but if no cookie -> anon.

        // Changing approach: The `/api/chat` route will be hit by the Public Widget (No Auth Cookies).
        // So `createClient` will be Anon.
        // Anon cannot read `knowledge_base_sources` due to RLS.
        // So I need to use `process.env.SUPABASE_SERVICE_ROLE_KEY`.

        // FIX: Import `createClient` from `@supabase/supabase-js` for admin operations.
        // I will write a local helper or just import here.

        const { createClient: createAdmin } = await import("@supabase/supabase-js");
        const adminAuthClient = createAdmin(
            process.env.NEXT_PUBLIC_SUPABASE_URL!,
            process.env.SUPABASE_SERVICE_ROLE_KEY!
        );

        const { data: sources } = await adminAuthClient
            .from("knowledge_base_sources")
            .select("content_uri")
            .eq("chatbot_id", chatbotId)
            .eq("status", "indexed");

        if (!sources || sources.length === 0) {
            // Fallback or just answer without context?
            // Gemini can answer generic questions.
            // But for RAG, we might return "I don't have any knowledge about this."
            // Let's try to answer anyway (or return a standard message).
            // Let's answer with empty context list.
            return GeminiService.generateAnswer(query, []);
        }

        const fileUris = sources.map((s) => s.content_uri).filter((uri): uri is string => typeof uri === 'string');

        // 2. Generate Answer
        // We might want to pass history here too?
        // Gemini supports `history` array.
        // `GeminiService.generateAnswer` currently handles single turn.
        // I will stick to single turn + RAG context for this MVP iteration.

        const answer = await GeminiService.generateAnswer(query, fileUris);
        return answer;
    }
};
</file>

<file path="utils/supabase/client.ts">
import { createBrowserClient } from '@supabase/ssr'
import { Database } from '@/lib/database.types'

export function createClient() {
    return createBrowserClient<Database>(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
    )
}
</file>

<file path="utils/supabase/middleware.ts">
import { createServerClient } from '@supabase/ssr'
import { NextResponse, type NextRequest } from 'next/server'

export async function updateSession(request: NextRequest) {
    let response = NextResponse.next({
        request: {
            headers: request.headers,
        },
    })

    const supabase = createServerClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
        {
            cookies: {
                getAll() {
                    return request.cookies.getAll()
                },
                setAll(cookiesToSet) {
                    cookiesToSet.forEach(({ name, value }) =>
                        request.cookies.set(name, value)
                    )
                    response = NextResponse.next({
                        request: {
                            headers: request.headers,
                        },
                    })
                    cookiesToSet.forEach(({ name, value, options }) =>
                        response.cookies.set(name, value, options)
                    )
                },
            },
        }
    )

    const {
        data: { user },
    } = await supabase.auth.getUser()

    if (
        !user &&
        !request.nextUrl.pathname.startsWith('/login') &&
        !request.nextUrl.pathname.startsWith('/auth')
    ) {
        // no user, potentially respond with 401 or redirect
        // mostly handled by RLS in this pattern, or explicit protection
    }

    return response
}
</file>

<file path="utils/supabase/server.ts">
import { createServerClient } from '@supabase/ssr'
import { cookies } from 'next/headers'
import { Database } from '@/lib/database.types'

export async function createClient() {
    const cookieStore = await cookies()

    return createServerClient<Database>(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
        {
            cookies: {
                getAll() {
                    return cookieStore.getAll()
                },
                setAll(cookiesToSet) {
                    try {
                        cookiesToSet.forEach(({ name, value, options }) =>
                            cookieStore.set(name, value, options)
                        )
                    } catch {
                        // The `setAll` method was called from a Server Component.
                        // This can be ignored if you have middleware refreshing
                        // user sessions.
                    }
                },
            },
        }
    )
}
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

# my own documentation
.privy

# secrets
client_secret*.json
</file>

<file path="package.json">
{
  "name": "temp-app",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "eslint"
  },
  "dependencies": {
    "@google/generative-ai": "^0.24.1",
    "@radix-ui/react-avatar": "^1.1.11",
    "@radix-ui/react-dropdown-menu": "^2.1.16",
    "@radix-ui/react-label": "^2.1.8",
    "@radix-ui/react-select": "^2.2.6",
    "@radix-ui/react-slot": "^1.2.4",
    "@radix-ui/react-tabs": "^1.1.13",
    "@supabase/ssr": "^0.8.0",
    "@supabase/supabase-js": "^2.93.3",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "date-fns": "^4.1.0",
    "lucide-react": "^0.563.0",
    "next": "16.1.6",
    "react": "19.2.3",
    "react-dom": "19.2.3",
    "stripe": "^20.3.0",
    "tailwind-merge": "^3.4.0"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "16.1.6",
    "tailwindcss": "^4",
    "tw-animate-css": "^1.4.0",
    "typescript": "^5"
  }
}
</file>

<file path=".gsd/STATE.md">
# STATE.md

> **Updated**: 2026-02-01

## Current Position
- **Phase**: Complete
- **Status**: Live / Maintenance
- **Goal**: Project successfully implemented.

## Recent Accomplishments
- **All Phases Complete**: Foundation, RAG, Widget, Handoff, Monetization.
- **Verification**: All builds passed.

## Next Steps
- Production Deployment.
- Monitor Usage.
</file>

<file path="app/page.tsx">
import { createClient } from "@/utils/supabase/server";
import { Navbar } from "@/components/landing/navbar";
import Link from "next/link";
import { Button } from "@/components/ui/button";

export default async function Home() {
    const supabase = await createClient();
    const {
        data: { user },
    } = await supabase.auth.getUser();

    let userRole = null;
    if (user) {
        const { data: profile } = await supabase
            .from("profiles")
            .select("role")
            .eq("id", user.id)
            .single();
        userRole = (profile as any)?.role;
    }

    return (
        <div className="flex min-h-screen flex-col">
            <Navbar user={user} role={userRole} />

            <main className="flex-1">
                <section className="space-y-6 pb-8 pt-6 md:pb-12 md:pt-10 lg:py-32">
                    <div className="container flex max-w-[64rem] flex-col items-center gap-4 text-center">
                        <h1 className="font-heading text-3xl sm:text-5xl md:text-6xl lg:text-7xl font-bold tracking-tight">
                            Embeddable RAG Chatbot
                        </h1>
                        <p className="max-w-[42rem] leading-normal text-muted-foreground sm:text-xl sm:leading-8">
                            Deploy custom AI support agents to your website in minutes. Powered by your data.
                        </p>
                        <div className="space-x-4">
                            {!user && (
                                <Link href="/signup">
                                    <Button size="lg" className="px-8">
                                        Get Started
                                    </Button>
                                </Link>
                            )}
                            <Link href={user ? "/dashboard" : "/login"}>
                                <Button variant="outline" size="lg" className="px-8">
                                    {user ? "Go to Dashboard" : "Login"}
                                </Button>
                            </Link>
                        </div>
                    </div>
                </section>

                <section className="container space-y-6 bg-slate-50 py-8 dark:bg-transparent md:py-12 lg:py-24 rounded-lg">
                    <div className="mx-auto flex max-w-[58rem] flex-col items-center space-y-4 text-center">
                        <h2 className="font-heading text-3xl leading-[1.1] sm:text-3xl md:text-6xl">
                            Features
                        </h2>
                        <p className="max-w-[85%] leading-normal text-muted-foreground sm:text-lg sm:leading-7">
                            Everything you need to build your own custom Support AI.
                        </p>
                    </div>
                    {/* Feature grid could go here */}
                </section>
            </main>
        </div>
    );
}
</file>

<file path=".gsd/ROADMAP.md">
# ROADMAP.md

> **Current Phase**: Not started
> **Milestone**: v1.0

## Must-Haves (from SPEC)
- [ ] Multi-tenant Authentication & Data Isolation
- [ ] Knowledge Base Ingestion (File + Web)
- [ ] RAG Chat Pipeline with Citations
- [ ] Embeddable Widget Component
- [ ] Human Handoff Workflow
- [ ] Stripe Subscription Gating

## Phases

### Phase 1: Foundation & Authentication
**Status**: ‚úÖ Done
**Objective**: Set up the Next.js Supabase project with secure multi-tenancy and basic dashboard layout.
**Requirements**: REQ-01

### Phase 2: RAG Engine & Knowledge Base
**Status**: ‚úÖ Done
**Objective**: Implement file upload, web crawling (Firecrawl), and Gemini indexing/retrieval pipeline.
**Requirements**: REQ-03, REQ-05

### Phase 3: The Embeddable Widget
**Status**: ‚úÖ Done
**Objective**: Build the standalone chat widget, generating embed codes, and enabling end-user chat APIs.
**Requirements**: REQ-04, REQ-06, REQ-02 (Config)

### Phase 4: Human Handoff & Realtime
**Status**: ‚úÖ Done
**Objective**: Implement the Agent Dashboard for live support and the logic to switch conversation modes.
**Requirements**: REQ-07

### Phase 5: Monetization & Launch
**Status**: ‚úÖ Done
**Objective**: Integrate Stripe for subscriptions and enforce usage limits. Final polish.
**Requirements**: REQ-08

### Phase 6: Advanced Auth & Admin
**Status**: ‚è≥ Not Started
**Objective**: Implement social login, 2FA, password recovery, and role-based access control with a dedicated admin dashboard.
**Requirements**: REQ-09, REQ-10
</file>

</files>
