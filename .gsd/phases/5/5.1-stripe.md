---
phase: 5
plan: 1
wave: 1
depends_on: []
files_modified:
  - app/api/stripe/webhook/route.ts
  - app/api/stripe/checkout/route.ts
  - lib/stripe.ts
  - supabase/migrations/0004_stripe.sql
  - types/supabase.ts
  - middleware.ts
autonomous: true
user_setup:
  - "Add STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET, NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY to .env.local"
  - "Create Products in Stripe Dashboard (Free, Pro)"

must_haves:
  truths:
    - "Schema: organization has subscription_status, stripe_customer_id"
    - "Schema: organization has usage limits (messages_count, max_messages)"
    - "Webhook handles checkout.session.completed"
    - "Webhook handles invoice.payment_succeeded"
    - "API blocks chat if limit exceeded"
  artifacts:
    - "supabase/migrations/0004_stripe.sql exists"
---

# Plan 5.1: Stripe Integration & Usage Limits

<objective>
Implement monetization system.
1. Database: Track subscription status and usage.
2. Stripe: Checkout flow and Webhooks.
3. Enforcement: Block actions if limits exceeded.

Purpose: specific instructions to billing infrastructure.
Output: specific instructions to payment flow.
</objective>

<context>
Load for context:
- .gsd/SPEC.md
</context>

<tasks>

<task type="auto">
  <name>Schema Updates for Billing</name>
  <files>supabase/migrations/0004_stripe.sql, types/supabase.ts</files>
  <action>
    Create migration:
    - Create `products` table (id, name, description, active, metadata).
    - Create `prices` table (id, product_id, unit_amount, currency, type, interval).
    - Alter `organizations`:
      - Add `stripe_customer_id` (text).
      - Add `subscription_status` (text) default 'active' (or 'free').
      - Add `plan_id` (text).
      - Add `messages_count` (int) default 0.
      - Add `last_reset` (timestamp) default now().
    
    Update TypeScript types.
  </action>
  <verify>ls supabase/migrations/0004_stripe.sql</verify>
  <done>Billing schema ready</done>
</task>

<task type="auto">
  <name>Stripe Lib & Checkout</name>
  <files>lib/stripe.ts, app/api/stripe/checkout/route.ts</files>
  <action>
    - `lib/stripe.ts`: Initialize Stripe client.
    - `POST /api/stripe/checkout`:
      - Takes `priceId`.
      - Creates Checkout Session (mode: subscription).
      - Returns URL.
  </action>
  <verify>ls app/api/stripe/checkout/route.ts</verify>
  <done>Checkout route created</done>
</task>

<task type="auto">
  <name>Stripe Webhook</name>
  <files>app/api/stripe/webhook/route.ts</files>
  <action>
    - Handle `product.created/updated`: Upsert `products`.
    - Handle `price.created/updated`: Upsert `prices`.
    - Handle `checkout.session.completed`:
      - Update `organizations`: set `stripe_customer_id`, `subscription_status`, `plan_id`.
    - Handle `customer.subscription.deleted`:
      - Set status to 'canceled'.
  </action>
  <verify>ls app/api/stripe/webhook/route.ts</verify>
  <done>Webhook handler created</done>
</task>

<task type="auto">
  <name>Admin Product Management</name>
  <files>app/admin/products/page.tsx, components/admin/product-form.tsx, app/actions/stripe-products.ts</files>
  <action>
    - **Security**: Allow ONLY `ThomasPerdana@gmail.com`.
    - Create `app/admin/products/page.tsx`:
      - Server-side check: `if (user.email !== 'ThomasPerdana@gmail.com') return notFound()`.
      - List products from `products` table.
      - "Create New Product" button.
    - Create `app/actions/stripe-products.ts`:
      - Verify user email again in server actions.
      - `createProduct(data)`: Calls `stripe.products.create` and `stripe.prices.create`.
      - `updateProduct(id, data)`: Calls `stripe.products.update`.
      - `deleteProduct(id)`: Calls `stripe.products.update(active: false)` (Archive).
  </action>
  <verify>ls app/admin/products/page.tsx</verify>
  <done>Admin Product CRUD ready</done>
</task>

<task type="auto">
  <name>Enforce Limits</name>
  <files>app/api/chat/route.ts</files>
  <action>
    - In `POST /api/chat`:
      - Fetch org for the chatbot.
      - Check `messages_count` vs Limit (based on `plan_id` -> lookup `products` metadata or hardcoded logic).
      - If limit exceeded, return 403 "Limit Reached".
      - Else, increment `messages_count`.
  </action>
  <verify>grep "messages_count" app/api/chat/route.ts</verify>
  <done>Limits enforced</done>
</task>

</tasks>

<verification>
After all tasks, verify:
- [ ] Schema applied
- [ ] Checkout redirects to Stripe
- [ ] Webhook updates DB
- [ ] Chat increments count
</verification>
